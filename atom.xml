<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-29T02:26:58.190Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/07/01/Redis/"/>
    <id>http://example.com/2021/07/01/Redis/</id>
    <published>2021-07-01T10:42:11.741Z</published>
    <updated>2021-06-29T02:26:58.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NoSQL概述"><a href="#NoSQL概述" class="headerlink" title="NoSQL概述"></a>NoSQL概述</h1><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><blockquote><h2 id="单机MySQL"><a href="#单机MySQL" class="headerlink" title="单机MySQL"></a>单机MySQL</h2></blockquote><p>在90年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！在那个时候，更多的都是静态网页，动态交互类型的网站不多。上述架构下，我们来看看数据存储的瓶颈是什么？</p><ol><li>数据量的总大小，一个机器放不下时</li><li>数据的索引（B+ Tree）一个机器的内存放不下时</li><li>访问量（读写混合）一个实例不能承受<br>如果满足了上述 1 or 3个，进化….<br>DAL：数据库访问层  </li></ol><p><img src="Redis.assets/image-20210625214024956.png" alt="image-20210625214024956"></p><blockquote><h2 id="Memcached（缓存）-MySQL-垂直拆分"><a href="#Memcached（缓存）-MySQL-垂直拆分" class="headerlink" title="Memcached（缓存）+ MySQL + 垂直拆分"></a>Memcached（缓存）+ MySQL + 垂直拆分</h2></blockquote><p>​       后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注在功能上，同时也在追求性能。程序猿们开始大量使用缓存技术来缓解数据库的压力，优化数据库的结构和索引，开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的IO压力，在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</p><p><img src="Redis.assets/image-20210625214412936.png" alt="image-20210625214412936"></p><blockquote><h2 id="MySQL主从读写分离"><a href="#MySQL主从读写分离" class="headerlink" title="MySQL主从读写分离"></a>MySQL主从读写分离</h2></blockquote><p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力，读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用<strong>主从复制</strong>技术来达到读写分离，以提高读写性能和读库的可扩展性，MySQL的master-slave模式成为这个时候的网站标配了。  </p><p><img src="Redis.assets/image-20210625214505323.png" alt="image-20210625214505323"></p><blockquote><h2 id="分表分库-水平拆分-Mysql-集群"><a href="#分表分库-水平拆分-Mysql-集群" class="headerlink" title="分表分库 + 水平拆分 + Mysql 集群"></a>分表分库 + 水平拆分 + Mysql 集群</h2></blockquote><p>​        在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题，这个时候，分表分库成了一个热门技术，是面试的热门问题，也是业界讨论的热门技术问题。也就是在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的需求，只是在高可靠性上提供了非常大的保证。  </p><p><img src="Redis.assets/image-20210625215043219.png" alt="image-20210625215043219"></p><blockquote><h2 id="MySQL-的扩展性瓶颈"><a href="#MySQL-的扩展性瓶颈" class="headerlink" title="MySQL 的扩展性瓶颈"></a>MySQL 的扩展性瓶颈</h2></blockquote><p>​        MySQL数据库也经常存储一些大文本的字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库，比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变的非常的小，关系数据库很强大，但是它并不能很好的应付所有的应用场景，MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题  。</p><img src="Redis.assets/image-20210625215153581.png" alt="image-20210625215153581" style="zoom:67%;" /><blockquote><h2 id="为什么用NoSQL？"><a href="#为什么用NoSQL？" class="headerlink" title="为什么用NoSQL？"></a>为什么用NoSQL？</h2></blockquote><p>​        今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大的数据。</p><h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><p>NoSQL = Not Only SQL，意思：不仅仅是SQL；<br>泛指非关系型的数据库，随着互联网Web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的社交网络服务类型的Web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展，NoSQL数据库的产生就是为了解决大规模数据集合多种数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。  </p><h3 id="NoSQL的特点"><a href="#NoSQL的特点" class="headerlink" title="NoSQL的特点"></a>NoSQL的特点</h3><p><strong>1、易扩展</strong><br>NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。<br>数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。<br><strong>2、大数据量高性能</strong>  </p><p>NoSQL数据库都具有非常高的读写性能，尤其是在大数据量下，同样表现优秀。这得益于它的非关系性，数据库的结构简单。<br>一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大力度的Cache，在针对Web2.0的交互频繁应用，Cache性能不高，而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。<br>官方记录：Redis 一秒可以写8万次，读11万次  </p><p><strong>3、多样灵活的数据模型</strong>  </p><p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是噩梦  。</p><p><strong>4、传统的RDBMS VS NoSQL</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传统的关系型数据库 RDBMS- 高度组织化结构化数据- 结构化查询语言（SQL）- 数据和关系都存储在单独的表中- 数据操纵语言，数据定义语言- 严格的一致性- 基础事务NoSQL- 代表着不仅仅是SQL- 没有声明性查询语言- 没有预定义的模式- 键值对存储，列存储，文档存储，图形数据库- 最终一致性，而非ACID属性- 非结构化和不可预知的数据- CAP定理- 高性能，高可用性 和 可伸缩性</span><br></pre></td></tr></table></figure><h2 id="经典应用分析"><a href="#经典应用分析" class="headerlink" title="经典应用分析"></a>经典应用分析</h2><p>1、商品的基本信息  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称、价格、出厂日期、生产厂商等关系型数据库：mysql、oracle目前淘宝在去O化（也即，拿掉Oracle）注意，淘宝内部用的MySQL是里面的大牛自己改造过的。为什么去IOE：2008年,王坚博士加入阿里巴巴，成为首席架构师。把云计算植入阿里IT基因。2013年5月17日，阿里集团最后一台IBM小机在支付宝下线。这是自2009年“去IOE”战略透露以来，“去IOE”非常重要的一个节点。“去 IOE”指的是摆脱掉IT部署中原有的IBM小型机、Oracle数据库以及EMC存储的过度依赖。告别最后一台小机，意味着整个阿里集团尽管还有一些Oracle数据库和EMC存储，但是IBM小型机已全部被替换。2013年7月10日，淘宝重中之重的广告系统使用的Oracle数据库下线，也是整个淘宝最后一个 Oracle数据库。这两件事合在一起是阿里巴巴技术发展过程中的一个重要里程碑</span><br></pre></td></tr></table></figure><p>2、商品描述、详情、评价信息（多文字类）  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多文字信息描述类，IO读写性能变差存在文档数据库MongDB中</span><br></pre></td></tr></table></figure><p>3、商品的图片  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">商品图片展现类分布式文件系统中- 淘宝自己的 TFS- Google的 GFS- Hadoop的 HDFS</span><br></pre></td></tr></table></figure><p>4、商品的关键字  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索引擎，淘宝内用ISearch：多隆一高兴一个人开发的</span><br></pre></td></tr></table></figure><p>5、商品的波段性的热点高频信息  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存数据库Tair、Redis、Memcache等</span><br></pre></td></tr></table></figure><p>6、商品的交易，价格计算，积分累计  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部系统，外部第三方支付接口支付宝外部系统，外部第三方支付接口支付宝</span><br></pre></td></tr></table></figure><h1 id="NoSQL四大分类"><a href="#NoSQL四大分类" class="headerlink" title="NoSQL四大分类"></a>NoSQL四大分类</h1><ul><li><p>KV键值：</p><p>​    新浪：BerkeleyDB+redis<br>​    美团：redis+tair<br>​    阿里、百度：memcache+redis</p></li><li><p>文档型数据库(bson格式比较多)：<br>CouchDB<br>MongoDB<br>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p></li><li><p>列存储数据库：<br>Cassandra, HBase<br>分布式文件系统</p></li><li><p>图关系数据库<br>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统、社交网络，推荐系统等。专注于构建关系图谱<br>Neo4J, InfoGrid  </p></li></ul><blockquote><h2 id="四者对比"><a href="#四者对比" class="headerlink" title="四者对比"></a>四者对比</h2></blockquote><p><img src="Redis.assets/image-20210625220533411.png" alt="image-20210625220533411"></p><blockquote><h2 id="CAP（三进二）"><a href="#CAP（三进二）" class="headerlink" title="CAP（三进二）"></a>CAP（三进二）</h2></blockquote><ul><li>C : Consistency（强一致性）</li><li>A : Availability（可用性）</li><li>P : Partition tolerance（分区容错性）  </li></ul><p><strong>CAP理论的核心是</strong>：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP原则和满足 AP 原则三大类：</p><ul><li>  CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li><li>  CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li><li>  AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。  </li></ul><blockquote><h2 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h2></blockquote><p>BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性  。</p><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。<br>BASE其实是下面三个术语的缩写：</p><ul><li>基本可用(Basically Available)： 基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</li><li>软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。MySQL Replication 的异步复制也是一种体现。</li><li>最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这<br>些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法！<br><strong>解释：</strong><br>   1、分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc通信和调用，对外<br>提供服务和组内协作。<br>2、集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供<br>服务和访问。  </li></ul><h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2></blockquote><p>Redis：REmote DIctionary Server（远程字典服务器）<br>        是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（Key/Value）分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为数据结构服务器<br>Redis与其他key-value缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的 key-value 类型的数据，同时还提供list、set、zset、hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。  </li></ul><blockquote><h2 id="Redis能干嘛"><a href="#Redis能干嘛" class="headerlink" title="Redis能干嘛"></a>Redis能干嘛</h2></blockquote><ul><li>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li><li>取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面</li><li>发布、订阅消息系统</li><li>地图信息分析</li><li>定时器、计数器  </li></ul><blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2></blockquote><ul><li><p>数据类型、基本操作和配置</p></li><li><p>持久化和复制，RDB、AOF</p></li><li><p>事务的控制  </p></li></ul><h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><p>下载地址：<a href="https://github.com/dmajkic/redis/downloads">https://github.com/dmajkic/redis/downloads</a>  </p><p><img src="Redis.assets/image-20210625221602570.png" alt="image-20210625221602570"></p><p>双击 redis-server.exe 启动即可  </p><img src="Redis.assets/image-20210625221616614.png" alt="image-20210625221616614" style="zoom: 80%;" /><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><p>下载地址 <a href="http://download.redis.io/releases/redis-5.0.7.tar.gz">http://download.redis.io/releases/redis-5.0.7.tar.gz</a>  </p><img src="Redis.assets/image-20210625221656416.png" alt="image-20210625221656416" style="zoom: 67%;" /><blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2></blockquote><ul><li><p>1、下载获得 redis-6.2.4.tar.gz 后将它放到我们Linux的目录下 /opt</p></li><li><p>2、/opt 目录下，解压命令 ： tar -zxvf redis-6.2.4.tar.gz</p></li><li><p>3、解压完成后出现文件夹：redis-6.2.4</p></li><li><p>4、进入目录： cd redis-6.2.4</p></li><li><p>5、在 redis-6.2.4 目录下执行 make 命令  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">运行make命令时故意出现的错误解析：</span><br><span class="line">1. 安装gcc (gcc是linux下的一个编译程序，是c程序的编译工具)</span><br><span class="line">能上网: yum install gcc-c++</span><br><span class="line">版本测试: gcc-v</span><br><span class="line">2. make</span><br><span class="line">3. Jemalloc/jemalloc.h: 没有那个文件或目录</span><br><span class="line">运行 make distclean 之后再make</span><br><span class="line">4. make install</span><br><span class="line">5. <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</span><br><span class="line">6. mkdir myredis</span><br><span class="line">7. cp /home/software/redis-6.2.4/redis.conf myredis</span><br><span class="line">8. vim redis.conf</span><br><span class="line">修改为 daemonize:yes</span><br><span class="line">9. 创建快捷方式 cp -r /home/software/redis-6.2.4/src/redis-cli /usr/bin</span><br><span class="line">10. 启动测试</span><br><span class="line"><span class="comment"># 【shell】启动redis服务</span></span><br><span class="line">[root@192 bin]<span class="comment"># cd /usr/local/bin</span></span><br><span class="line">[root@192 bin]<span class="comment"># redis-server /opt/redis-6.2.4/redis.conf</span></span><br><span class="line"><span class="comment"># redis客户端连接===&gt; 观察地址的变化，如果连接ok,是直接连上的，redis默认端口号 6379</span></span><br><span class="line">[root@192 bin]<span class="comment"># redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 helloworld</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="comment"># 【shell】ps显示系统当前进程信息</span></span><br><span class="line">[root@192 myredis]<span class="comment"># ps -ef|grep redis</span></span><br><span class="line">root 16005 1 0 04:45 ? 00:00:00 redis-server</span><br><span class="line">127.0.0.1:6379</span><br><span class="line">root 16031 15692 0 04:47 pts/0 00:00:00 redis-cli -p 6379</span><br><span class="line">root 16107 16076 0 04:51 pts/2 00:00:00 grep --color=auto redis</span><br><span class="line"><span class="comment"># 【redis】关闭连接</span></span><br><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 【shell】ps显示系统当前进程信息</span></span><br><span class="line">[root@192 myredis]<span class="comment"># ps -ef|grep redis</span></span><br><span class="line">root 16140 16076 0 04:53 pts/2 00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ash: ls: command not found，无法使用Linux命令</span><br><span class="line">是因为环境变量PATH被修改了</span><br><span class="line">只需在命令行执行</span><br><span class="line">export PATH=/bin:/usr/bin:$PATH</span><br><span class="line">即可</span><br></pre></td></tr></table></figure><h2 id="redis压力测试工具—–Redis-benchmark"><a href="#redis压力测试工具—–Redis-benchmark" class="headerlink" title="redis压力测试工具—–Redis-benchmark"></a>redis压力测试工具—–Redis-benchmark</h2><img src="Redis.assets/image-20210625222652928.png" alt="image-20210625222652928" style="zoom: 80%;" /><p>默认16个数据库，类似数组下标从零开始，初始默认使用零号库  </p><p>Select命令切换数据库  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[7]&gt;</span><br><span class="line"><span class="comment"># 不同的库可以存不同的数据</span></span><br></pre></td></tr></table></figure><p>Dbsize查看当前数据库的key的数量  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[7]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[7]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看具体的key</span></span><br><span class="line">1) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">2) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;myset:__rand_int__&quot;</span></span><br><span class="line">5) <span class="string">&quot;key:__rand_int__&quot;</span></span><br></pre></td></tr></table></figure><p>Flushdb：清空当前库<br>Flushall：清空全部的库  </p><h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><p>1）以前一直有个误区，以为：高性能服务器 一定是多线程来实现的<br>原因很简单因为误区二导致的：多线程 一定比单线程效率高，其实不然！<br>在说这个事前希望大家都能对 CPU 、 内存 、 硬盘的速度都有了解了！<br>2）redis 核心就是 如果我的数据全都在内存里，我单线程的去操作就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案。因为一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us，假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，那么就有1500ns *1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不算你每次读一点数据的时间 。</p><h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><p>​        Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流的地理空间索引。Redis具有内置的复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区提供了高可用性。  </p><h2 id="String-（字符串类型）"><a href="#String-（字符串类型）" class="headerlink" title="String （字符串类型）"></a>String （字符串类型）</h2><p>​        String是redis最基本的类型，你可以理解成Memcached一模一样的类型，一个key对应一个value。String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。String类型是redis最基本的数据类型，一个redis中字符串value最多可以是512M。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# set、get、del、append、strlen# ===================================================127.0.0.1:6379&gt; set key1 value1 # 设置值OK127.0.0.1:6379&gt; get key1 # 获得key&quot;value1&quot;127.0.0.1:6379&gt; del key1 # 删除key(integer) 1127.0.0.1:6379&gt; keys * # 查看全部的key(empty list or set)127.0.0.1:6379&gt; exists key1 # 确保 key1 不存在(integer) 0127.0.0.1:6379&gt; append key1 &quot;hello&quot; # 对不存在的 key 进行 APPEND ，等同于 SETkey1 &quot;hello&quot;(integer) 5 # 字符长度127.0.0.1:6379&gt; APPEND key1 &quot;-2333&quot; # 对已存在的字符串进行 APPEND(integer) 10 # 长度从 5 个字符增加到 10 个字符127.0.0.1:6379&gt; get key1&quot;hello-2333&quot;127.0.0.1:6379&gt; STRLEN key1 # # 获取字符串的长度(integer) 10# ===================================================# incr、decr 一定要是数字才能进行加减，+1 和 -1。# incrby、decrby 命令将 key 中储存的数字加上指定的增量值。# ===================================================127.0.0.1:6379&gt; set views 0 # 设置浏览量为0OK127.0.0.1:6379&gt; incr views # 浏览 + 1(integer) 1127.0.0.1:6379&gt; incr views # 浏览 + 1(integer) 2127.0.0.1:6379&gt; decr views # 浏览 - 1(integer) 1127.0.0.1:6379&gt; incrby views 10 # +10(integer) 11127.0.0.1:6379&gt; decrby views 10 # -10(integer) 1# ===================================================# range [范围]# getrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部# ===================================================127.0.0.1:6379&gt; set key2 abcd123456 # 设置key2的值OK127.0.0.1:6379&gt; getrange key2 0 -1 # 获得全部的值&quot;abcd123456&quot;127.0.0.1:6379&gt; getrange key2 0 2 # 截取部分字符串&quot;abc&quot;# ===================================================# setrange 设置指定区间范围内的值，格式是setrange key值 具体值# ===================================================127.0.0.1:6379&gt; get key2&quot;abcd123456&quot;127.0.0.1:6379&gt; SETRANGE key2 1 xx # 替换值(integer) 10127.0.0.1:6379&gt; get key2&quot;axxd123456&quot;# ===================================================# setex（set with expire）键秒值# setnx（set if not exist）# ===================================================127.0.0.1:6379&gt; setex key3 60 expire # 设置过期时间OK127.0.0.1:6379&gt; ttl key3 # 查看剩余的时间(integer) 55127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果不存在就设置，成功返回1(integer) 1127.0.0.1:6379&gt; setnx mykey &quot;mongodb&quot; # 如果存在就设置，失败返回0(integer) 0127.0.0.1:6379&gt; get mykey&quot;redis&quot;# ===================================================# mset Mset 命令用于同时设置一个或多个 key-value 对。# mget Mget 命令返回所有(一个或多个)给定 key 的值。# 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。# msetnx 当所有 key 都成功设置，返回 1 。# 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。原子操作 #===================================================127.0.0.1:6379&gt; mset k10 v10 k11 v11 k12 v12OK127.0.0.1:6379&gt; keys *1) &quot;k12&quot;2) &quot;k11&quot;3) &quot;k10&quot;127.0.0.1:6379&gt; mget k10 k11 k12 k131) &quot;v10&quot;2) &quot;v11&quot;3) &quot;v12&quot;4) (nil)127.0.0.1:6379&gt; msetnx k10 v10 k15 v15 # 原子性操作！(integer) 0127.0.0.1:6379&gt; get key15(nil)# 传统对象缓存set user:1 value(json数据)# 可以用来缓存对象mset user:1:name zhangsan user:1:age 2mget user:1:name user:1:age# ===================================================# getset（先get再set）# ===================================================127.0.0.1:6379&gt; getset db mongodb # 没有旧值，返回 nil(nil)127.0.0.1:6379&gt; get db&quot;mongodb&quot;127.0.0.1:6379&gt; getset db redis # 返回旧值 mongodb&quot;mongodb&quot;127.0.0.1:6379&gt; get db&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。常规key-value缓存应用：<br>常规计数：微博数，粉丝数等。  </p><h2 id="Hash（哈希，类似-Java里的Map）"><a href="#Hash（哈希，类似-Java里的Map）" class="headerlink" title="Hash（哈希，类似 Java里的Map）"></a>Hash（哈希，类似 Java里的Map）</h2><p>​        Redis hash 是一个键值对集合。Redis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# hset、hget 命令用于为哈希表中的字段赋值 。# hmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段。# hgetall 用于返回哈希表中，所有的字段和值。# hdel 用于删除哈希表 key 中的一个或多个指定字段# ===================================================127.0.0.1:6379&gt; hset myhash field1 &quot;liu&quot;(integer) 1127.0.0.1:6379&gt; hget myhash field1&quot;liu&quot;127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;OK127.0.0.1:6379&gt; HGET myhash field1&quot;Hello&quot;127.0.0.1:6379&gt; HGET myhash field2&quot;World&quot;127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;Hello&quot;3) &quot;field2&quot;4) &quot;World&quot;127.0.0.1:6379&gt; HDEL myhash field1(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;World&quot;# ===================================================# hlen 获取哈希表中字段的数量。# ===================================================127.0.0.1:6379&gt; hlen myhash(integer) 1127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;OK127.0.0.1:6379&gt; hlen myhash(integer) 2# ===================================================# hexists 查看哈希表的指定字段是否存在。# ===================================================127.0.0.1:6379&gt; hexists myhash field1(integer) 1127.0.0.1:6379&gt; hexists myhash field3(integer) 0# ===================================================# hkeys 获取哈希表中的所有域（field）。# hvals 返回哈希表所有域(field)的值。# ===================================================127.0.0.1:6379&gt; HKEYS myhash1) &quot;field2&quot;2) &quot;field1&quot;127.0.0.1:6379&gt; HVALS myhash1) &quot;World&quot;2) &quot;Hello&quot;# ===================================================# hincrby 为哈希表中的字段值加上指定增量值。# ===================================================127.0.0.1:6379&gt; hset myhash field 5(integer) 1127.0.0.1:6379&gt; HINCRBY myhash field 1(integer) 6127.0.0.1:6379&gt; HINCRBY myhash field -1(integer) 5127.0.0.1:6379&gt; HINCRBY myhash field -10(integer) -5# ===================================================# hsetnx 为哈希表中不存在的的字段赋值 。# ===================================================127.0.0.1:6379&gt; HSETNX myhash field1 &quot;hello&quot;(integer) 1 # 设置成功，返回 1 。127.0.0.1:6379&gt; HSETNX myhash field1 &quot;world&quot;(integer) 0 # 如果给定字段已经存在，返回 0 。127.0.0.1:6379&gt; HGET myhash field1&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><pre><code>     Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际是个链表 !  </code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# Lpush：将一个或多个值插入到列表头部。（左）# rpush：将一个或多个值插入到列表尾部。（右）# lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。# 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。# 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。# ===================================================127.0.0.1:6379&gt; LPUSH list &quot;one&quot;(integer) 1127.0.0.1:6379&gt; LPUSH list &quot;two&quot;(integer) 2127.0.0.1:6379&gt; RPUSH list &quot;right&quot;(integer) 3127.0.0.1:6379&gt; Lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;right&quot;127.0.0.1:6379&gt; Lrange list 0 11) &quot;two&quot;2) &quot;one&quot;# ===================================================# lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。# rpop 移除列表的最后一个元素，返回值为移除的元素。# ===================================================127.0.0.1:6379&gt; Lpop list&quot;two&quot;127.0.0.1:6379&gt; Rpop list&quot;right&quot;127.0.0.1:6379&gt; Lrange list 0 -11) &quot;one&quot;# ===================================================# Lindex，按照索引下标获得元素（-1代表最后一个，0代表是第一个）# ===================================================127.0.0.1:6379&gt; Lindex list 1(nil)127.0.0.1:6379&gt; Lindex list 0&quot;one&quot;127.0.0.1:6379&gt; Lindex list -1&quot;one&quot;# ===================================================# llen 用于返回列表的长度。# ===================================================127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; Lpush list &quot;one&quot;(integer) 1127.0.0.1:6379&gt; Lpush list &quot;two&quot;(integer) 2127.0.0.1:6379&gt; Lpush list &quot;three&quot;(integer) 3127.0.0.1:6379&gt; Llen list # 返回列表的长度(integer) 3# ===================================================# lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。# ===================================================127.0.0.1:6379&gt; lrem list 1 &quot;two&quot;(integer) 1127.0.0.1:6379&gt; Lrange list 0 -11) &quot;three&quot;2) &quot;one&quot;# ===================================================# Ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。# ===================================================127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot;(integer) 2127.0.0.1:6379&gt; RPUSH mylist &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; RPUSH mylist &quot;hello3&quot;(integer) 4127.0.0.1:6379&gt; ltrim mylist 1 2OK127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello&quot;2) &quot;hello2&quot;# ===================================================# rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。# ===================================================127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush mylist &quot;foo&quot;(integer) 2127.0.0.1:6379&gt; rpush mylist &quot;bar&quot;(integer) 3127.0.0.1:6379&gt; rpoplpush mylist myotherlist&quot;bar&quot;127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello&quot;2) &quot;foo&quot;127.0.0.1:6379&gt; lrange myotherlist 0 -11) &quot;bar&quot;# ===================================================# lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。# ===================================================127.0.0.1:6379&gt; exists list # 对空列表(key 不存在)进行 LSET(integer) 0127.0.0.1:6379&gt; lset list 0 item # 报错(error) ERR no such key127.0.0.1:6379&gt; lpush list &quot;value1&quot; # 对非空列表进行 LSET(integer) 1127.0.0.1:6379&gt; lrange list 0 01) &quot;value1&quot;127.0.0.1:6379&gt; lset list 0 &quot;new&quot; # 更新值OK127.0.0.1:6379&gt; lrange list 0 01) &quot;new&quot;127.0.0.1:6379&gt; lset list 1 &quot;new&quot; # index 超出范围报错(error) ERR index out of range# ===================================================# linsert key before/after pivot value 用于在列表的元素前或者后插入元素。# 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。# ===================================================redis&gt; RPUSH mylist &quot;Hello&quot;(integer) 1redis&gt; RPUSH mylist &quot;World&quot;(integer) 2redis&gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;(integer) 3redis&gt; LRANGE mylist 0 -11) &quot;Hello&quot;2) &quot;There&quot;3) &quot;World&quot;</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="性能总结"><a href="#性能总结" class="headerlink" title="性能总结"></a>性能总结</h3></blockquote><ul><li><p>它是一个字符串链表，left，right 都可以插入添加</p></li><li><p>如果键不存在，创建新的链表</p></li><li><p>如果键已存在，新增内容</p></li><li><p>如果值全移除，对应的键也就消失了</p></li><li><p>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</p></li></ul><p>​        list就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。  </p><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>​        Redis的Set是String类型的无序集合，它是通过HashTable实现的 !  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# sadd 将一个或多个成员元素加入到集合中，不能重复# smembers 返回集合中的所有的成员。# sismember 命令判断成员元素是否是集合的成员。# ===================================================127.0.0.1:6379&gt; sadd myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;(integer) 0127.0.0.1:6379&gt; SMEMBERS myset1) &quot;kuangshen&quot;2) &quot;hello&quot;127.0.0.1:6379&gt; SISMEMBER myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; SISMEMBER myset &quot;world&quot;(integer) 0# ===================================================# scard，获取集合里面的元素个数# ===================================================127.0.0.1:6379&gt; scard myset(integer) 2# ===================================================# srem key value 用于移除集合中的一个或多个成员元素# ===================================================127.0.0.1:6379&gt; srem myset &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;hello&quot;# ===================================================# srandmember key 命令用于返回集合中的一个随机元素。# ===================================================127.0.0.1:6379&gt; SMEMBERS myset1) &quot;kuangshen&quot;2) &quot;world&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;hello&quot;127.0.0.1:6379&gt; SRANDMEMBER myset 21) &quot;world&quot;2) &quot;kuangshen&quot;127.0.0.1:6379&gt; SRANDMEMBER myset 21) &quot;kuangshen&quot;2) &quot;hello&quot;# ===================================================# spop key 用于移除集合中的指定 key 的一个或多个随机元素# ===================================================127.0.0.1:6379&gt; SMEMBERS myset1) &quot;kuangshen&quot;2) &quot;world&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; spop myset&quot;world&quot;127.0.0.1:6379&gt; spop myset&quot;kuangshen&quot;127.0.0.1:6379&gt; spop myset&quot;hello&quot;# ===================================================# smove SOURCE DESTINATION MEMBER# 将指定成员 member 元素从 source 集合移动到 destination 集合。# ===================================================127.0.0.1:6379&gt; sadd myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;world&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; sadd myset2 &quot;set2&quot;(integer) 1127.0.0.1:6379&gt; smove myset myset2 &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;world&quot;2) &quot;hello&quot;127.0.0.1:6379&gt; SMEMBERS myset21) &quot;kuangshen&quot;2) &quot;set2&quot;# ===================================================- 数字集合类- 差集： sdiff- 交集： sinter- 并集： sunion# ===================================================127.0.0.1:6379&gt; sadd key1 &quot;a&quot;(integer) 1127.0.0.1:6379&gt; sadd key1 &quot;b&quot;(integer) 1127.0.0.1:6379&gt; sadd key1 &quot;c&quot;(integer) 1127.0.0.1:6379&gt; sadd key2 &quot;c&quot;(integer) 1127.0.0.1:6379&gt; sadd key2 &quot;d&quot;(integer) 1127.0.0.1:6379&gt; sadd key2 &quot;e&quot;(integer) 1127.0.0.1:6379&gt; SDIFF key1 key2 # 差集1) &quot;a&quot;2) &quot;b&quot;127.0.0.1:6379&gt; SINTER key1 key2 # 交集1) &quot;c&quot;127.0.0.1:6379&gt; SUNION key1 key2 # 并集1) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;e&quot;5) &quot;d&quot;</span></span><br></pre></td></tr></table></figure><p>​        在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中  。</p><h2 id="Zset（sorted-set：有序集合）"><a href="#Zset（sorted-set：有序集合）" class="headerlink" title="Zset（sorted set：有序集合）"></a>Zset（sorted set：有序集合）</h2><p>​        Redis zset 和 set 一样，也是String类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。<br>Redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（Score）却可以重复。  </p><p>​        在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# zadd 将一个或多个成员元素及其分数值加入到有序集当中。# zrange 返回有序集中，指定区间内的成员# ===================================================127.0.0.1:6379&gt; zadd myset 1 &quot;one&quot;(integer) 1127.0.0.1:6379&gt; zadd myset 2 &quot;two&quot; 3 &quot;three&quot;(integer) 2127.0.0.1:6379&gt; ZRANGE myset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;# ===================================================# zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。# ===================================================127.0.0.1:6379&gt; zadd salary 2500 xiaoming(integer) 1127.0.0.1:6379&gt; zadd salary 5000 xiaohong(integer) 1127.0.0.1:6379&gt; zadd salary 500 ll(integer) 1# Inf无穷大量+∞,同样地,-∞可以表示为-Inf。127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf # 显示整个有序集1) &quot;ll&quot;2) &quot;xiaoming&quot;3) &quot;xiaohong&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 递增排列1) &quot;ll&quot;2) &quot;500&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;5) &quot;xiaohong&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 WITHSCORES # 递减排列1) &quot;xiaohong&quot;2) &quot;5000&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;5) &quot;ll&quot;6) &quot;500&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 WITHSCORES # 显示工资 &lt;=2500的所有成员1) &quot;ll&quot;2) &quot;500&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;# ===================================================# zrem 移除有序集中的一个或多个成员# ===================================================127.0.0.1:6379&gt; ZRANGE salary 0 -11) &quot;ll&quot;2) &quot;xiaoming&quot;3) &quot;xiaohong&quot;127.0.0.1:6379&gt; zrem salary ll(integer) 1127.0.0.1:6379&gt; ZRANGE salary 0 -11) &quot;xiaoming&quot;2) &quot;xiaohong&quot;# ===================================================# zcard 命令用于计算集合中元素的数量。# ===================================================127.0.0.1:6379&gt; zcard salary(integer) 2OK# ===================================================# zcount 计算有序集合中指定分数区间的成员数量。# ===================================================127.0.0.1:6379&gt; zadd myset 1 &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; zadd myset 2 &quot;world&quot; 3 &quot;lisi&quot;(integer) 2127.0.0.1:6379&gt; ZCOUNT myset 1 3(integer) 3127.0.0.1:6379&gt; ZCOUNT myset 1 2(integer) 2# ===================================================# zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。# ===================================================127.0.0.1:6379&gt; zadd salary 2500 xiaoming(integer) 1127.0.0.1:6379&gt; zadd salary 5000 xiaohong(integer) 1127.0.0.1:6379&gt; zadd salary 500 lisi(integer) 1127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES # 显示所有成员及其 score 值1) &quot;lis&quot;2) &quot;500&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;5) &quot;xiaohong&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; zrank salary lisi # 显示 lisi 的薪水排名，最少(integer) 0127.0.0.1:6379&gt; zrank salary xiaohong # 显示 xiaohong 的薪水排名，第三(integer) 2# ===================================================# zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。# ===================================================127.0.0.1:6379&gt; ZREVRANK salary lisi # lisi第三(integer) 2127.0.0.1:6379&gt; ZREVRANK salary xiaohong # 小红第一(integer) 0</span></span><br></pre></td></tr></table></figure><p>​        和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。排行榜应用，取TOP N操作 ！  </p><h2 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *查看当前库所有key    (匹配：keys *1)exists key判断某个key是否存在<span class="built_in">type</span> key 查看你的key是什么类型del key       删除指定的key数据unlink key   根据value选择非阻塞删除仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。expire key 10   10秒钟：为给定的key设置过期时间ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期select命令切换数据库dbsize查看当前数据库的key的数量flushdb清空当前库flushall通杀全部库</span><br></pre></td></tr></table></figure><h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="GEO地理位置"><a href="#GEO地理位置" class="headerlink" title="GEO地理位置"></a>GEO地理位置</h2><blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3></blockquote><p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo的数据类型为zset。</p><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><p>GEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash<br>官方文档：<a href="https://www.redis.net.cn/order/3685.html">https://www.redis.net.cn/order/3685.html</a>  </p><blockquote><h3 id="geoadd-添加地理位置（经度，纬度，名称）"><a href="#geoadd-添加地理位置（经度，纬度，名称）" class="headerlink" title="geoadd  添加地理位置（经度，纬度，名称）"></a>geoadd  添加地理位置（经度，纬度，名称）</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法geoadd key longitude latitude member ...# 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。# 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的命令可以在之后通过位置查询取得这些元素。# geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。# geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。# 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。，当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 北京(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.2130.20 杭州(integer) 3127.0.0.1:6379&gt; geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.0230.58 武汉(integer) 3</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="geopos-获得指定地区的坐标值"><a href="#geopos-获得指定地区的坐标值" class="headerlink" title="geopos  获得指定地区的坐标值"></a>geopos  获得指定地区的坐标值</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法geopos key member [member...]#从key里返回所有给定位置元素的位置（经度和纬度）127.0.0.1:6379&gt; geopos china:city 北京1) 1) &quot;116.23000055551528931&quot;   2) &quot;40.2200010338739844&quot;127.0.0.1:6379&gt; geopos china:city 上海 重庆1) 1) &quot;121.48000091314315796&quot;   2) &quot;31.40000025319353938&quot;2) 1) &quot;106.54000014066696167&quot;   2) &quot;29.39999880018641676&quot;127.0.0.1:6379&gt; geopos china:city 新疆1) (nil)</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="geodist-获取两个位置之间的直线距离"><a href="#geodist-获取两个位置之间的直线距离" class="headerlink" title="geodist  获取两个位置之间的直线距离"></a>geodist  获取两个位置之间的直线距离</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法geodist key member1 member2 [unit]# 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。# 指定单位的参数unit必须是以下单位的其中一个：# m表示单位为米# km表示单位为千米# mi表示单位为英里# ft表示单位为英尺# 如果用户没有显式地指定单位参数,那么geodist默认使用米作为单位。#geodist命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成0.5%的误差。127.0.0.1:6379&gt; geodist china:city 北京 上海&quot;1088785.4302&quot;127.0.0.1:6379&gt; geodist china:city 北京 上海 km&quot;1088.7854&quot;127.0.0.1:6379&gt; geodist china:city 重庆 北京 km&quot;1491.6716&quot;</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="georadius-以给定的经纬度为中心，找出某一半径内的元素"><a href="#georadius-以给定的经纬度为中心，找出某一半径内的元素" class="headerlink" title="georadius  以给定的经纬度为中心，找出某一半径内的元素"></a>georadius  以给定的经纬度为中心，找出某一半径内的元素</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法georadius key longitude latitude radius m|km|ft|mi [withcoord][withdist][withhash][asc|desc][count count]# 以给定的经纬度为中心， 找出某一半径内的元素</span></span><br></pre></td></tr></table></figure><p>重新连接 redis-cli，增加参数 –raw ，可以强制输出中文，不然会乱码  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lhy bin]<span class="comment"># redis-cli --raw -p 6379# 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市127.0.0.1:6379&gt; georadius china:city 100 30 1000 km重庆西安# withdist 返回位置名称和中心距离127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withdist重庆635.2850西安963.3171# withcoord 返回位置名称和经纬度127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord重庆106.5400001406669616729.39999880018641676西安108.9299985766410827634.23000121926852302# withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count1 重庆635.2850106.5400001406669616729.39999880018641676127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count2 重庆635.2850106.5400001406669616729.39999880018641676西安963.3171108.9299985766410827634.23000121926852302</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="georadiusbymember"><a href="#georadiusbymember" class="headerlink" title="georadiusbymember"></a>georadiusbymember</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法georadiusbymember key member radius m|km|ft|mi [withcoord][withdist][withhash][asc|desc][count count]# 找出位于指定范围内的元素，中心点是由给定的位置元素决定</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 北京 1000 km北京西安127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 上海 400 km杭州上海</span><br></pre></td></tr></table></figure><blockquote><h3 id="geohash"><a href="#geohash" class="headerlink" title="geohash"></a>geohash</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法geohash key member [member...]# Redis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确,两个字符串越相似表示距离越近。127.0.0.1:6379&gt; geohash china:city 北京 重庆wx4sucu47r0wm5z22h53v0127.0.0.1:6379&gt; geohash china:city 北京 上海wx4sucu47r0wtw6sk5n300</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="zrem"><a href="#zrem" class="headerlink" title="zrem"></a>zrem</h3></blockquote><p>GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 beijin1 127.0.0.1:6379&gt; zrange china:city 0 -1 <span class="comment"># 查看全部的元素重庆西安深圳武汉杭州上海beijin北京127.0.0.1:6379&gt; zrem china:city beijin # 移除元素1127.0.0.1:6379&gt; zrem china:city 北京 # 移除元素1 127.0.0.1:6379&gt; zrange china:city 0 -1重庆西安深圳武汉杭州上海</span></span><br></pre></td></tr></table></figure><h2 id="HyperLog"><a href="#HyperLog" class="headerlink" title="HyperLog"></a>HyperLog</h2><blockquote><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3></blockquote><p>​        Redis 在 2.8.9 版本添加了 HyperLogLog 结构。<br>​        Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog则是一种算法，它提供了不精确的去重计数方案。<br>​        举个例子：假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。  </p><blockquote><h3 id="什么是基数"><a href="#什么是基数" class="headerlink" title="什么是基数"></a>什么是基数</h3></blockquote><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。基数估计就是在误差可接受的范围内，快速计算基数。   </p><blockquote><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3></blockquote><p><img src="Redis.assets/image-20210627154114830.png" alt="image-20210627154114830"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD mykey a b c d e f g h i j1 127.0.0.1:6379&gt; PFCOUNT mykey10127.0.0.1:6379&gt; PFADD mykey2 i j z x c v b n m1 127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2OK127.0.0.1:6379&gt; PFCOUNT mykey315</span><br></pre></td></tr></table></figure><h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>​        现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图:</p><p><img src="Redis.assets/image-20210627154347176.png" alt="image-20210627154347176"></p><p>​        合理地使用操作位能够有效地提高内存使用率和开发效率。Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li></ol><p><img src="Redis.assets/image-20210627154431289.png" alt="image-20210627154431289"></p><blockquote><h3 id="setbit-设置操作"><a href="#setbit-设置操作" class="headerlink" title="setbit 设置操作"></a>setbit 设置操作</h3></blockquote><p>SETBIT key offset value : 设置 key 的第 offset 位为value (1或0)  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：# 周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）127.0.0.1:6379&gt; setbit sign 0 10 127.0.0.1:6379&gt; setbit sign 1 00 127.0.0.1:6379&gt; setbit sign 2 00 127.0.0.1:6379&gt; setbit sign 3 10 127.0.0.1:6379&gt; setbit sign 4 10 127.0.0.1:6379&gt; setbit sign 5 00 127.0.0.1:6379&gt; setbit sign 6 00</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="getbit-获取操作"><a href="#getbit-获取操作" class="headerlink" title="getbit 获取操作"></a>getbit 获取操作</h3></blockquote><p>GETBIT key offset 获取offset设置的值，未设置过默认返回0  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3 <span class="comment"># 查看周四是否打卡1 127.0.0.1:6379&gt; getbit sign 6 # 查看周七是否打卡0</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="bitcount-统计操作"><a href="#bitcount-统计操作" class="headerlink" title="bitcount 统计操作"></a>bitcount 统计操作</h3></blockquote><p>bitcount key [start, end] 统计 key 上位为1的个数  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计这周打卡的记录，可以看到只有3天是打卡的状态：127.0.0.1:6379&gt; bitcount sign3</span></span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><ul><li><p><strong>Redis事务的概念</strong>：<br>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p></li><li><p><strong>Redis事务没有隔离级别的概念：</strong><br>批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！</p></li><li><p><strong>Redis不保证原子性：</strong><br>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p></li><li><p><strong>Redis事务的三个阶段：</strong>  </p><ol><li>开始事务</li><li>命令入队</li><li>执行事务  </li></ol></li></ul><p><strong>Redis事务相关命令：</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 key2 ... <span class="comment">#监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）multi # 标记一个事务块的开始（ queued ）exec # 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）discard # 取消事务，放弃事务块中的所有命令unwatch # 取消watch对所有key的监控</span></span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><h3 id="正常执行事务"><a href="#正常执行事务" class="headerlink" title="正常执行事务"></a>正常执行事务</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI         <span class="comment">#开启事务OK127.0.0.1:6379(TX)&gt; set k1 v1  #命令入队QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; exec #执行事务1) OK#输出结果2) OK3) OK</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1QUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 vvQUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3QUEUED127.0.0.1:6379(TX)&gt; DISCARDOK127.0.0.1:6379&gt; get k2<span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"><a href="#若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行" class="headerlink" title="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"></a>若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> m1 n1QUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> m2 n2QUEUED127.0.0.1:6379(TX)&gt; getset m3(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> command127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> m4 n4QUEUED127.0.0.1:6379(TX)&gt; EXEC<span class="comment">#执行事务报错(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get m4#命令未执行(nil)127.0.0.1:6379&gt; </span></span><br></pre></td></tr></table></figure><blockquote><h3 id="若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。"><a href="#若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。" class="headerlink" title="若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。"></a>若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; INCR k1    QUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 22QUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 33QUEUED127.0.0.1:6379(TX)&gt; get k3QUEUED127.0.0.1:6379(TX)&gt; EXEC1) (error) ERR value is not an <span class="built_in">integer</span> or out of range2) OK3) OK4) <span class="string">&quot;33&quot;</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="Watch-监控"><a href="#Watch-监控" class="headerlink" title="Watch 监控"></a>Watch 监控</h3></blockquote><ul><li><strong>悲观锁：</strong><pre><code>悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。</code></pre></li><li><strong>乐观锁：</strong><pre><code>乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能执行更新。</code></pre></li><li><strong>测试：</strong>  </li></ul><p>1、初始化信用卡可用余额和欠额  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> balance 100OK127.0.0.1:6379&gt; <span class="built_in">set</span> debt 0OK</span><br></pre></td></tr></table></figure><p>2、使用watch检测balance，事务期间balance数据未变动，事务执行成功  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch balanceOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; decrby balance 20QUEUED127.0.0.1:6379&gt; incrby debt 20QUEUED127.0.0.1:6379&gt; exec1) (<span class="built_in">integer</span>) 802) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><p>3、使用watch检测balance，事务期间balance数据变动，事务执行失败  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 窗口一127.0.0.1:6379&gt; watch balanceOK127.0.0.1:6379&gt; MULTI # 执行完毕后，执行窗口二代码测试OK127.0.0.1:6379&gt; decrby balance 20QUEUED127.0.0.1:6379&gt; incrby debt 20QUEUED127.0.0.1:6379&gt; exec # 修改失败！(nil) # 修改失败！# 窗口二127.0.0.1:6379&gt; get balance&quot;80&quot;127.0.0.1:6379&gt; set balance 200OK#解决方案：# 窗口一：出现问题后放弃监视，然后重来！127.0.0.1:6379&gt; UNWATCH # 放弃监视OK127.0.0.1:6379&gt; watch balanceOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; decrby balance 20QUEUED127.0.0.1:6379&gt; incrby debt 20QUEUED127.0.0.1:6379&gt; exec # 成功！1) (integer) 1802) (integer) 40</span></span><br></pre></td></tr></table></figure><p>说明：<br>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。  </p><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能写成漂亮的代码 。</p><h2 id="测试联通"><a href="#测试联通" class="headerlink" title="测试联通"></a>测试联通</h2><p>1、新建一个普通的Maven项目</p><p>2、导入redis的依赖！  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/redis.clients/jedis --&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;            &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.58&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</span></span><br></pre></td></tr></table></figure><p>3、编写测试代码  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);        System.out.println(<span class="string">&quot;连接成功&quot;</span>);<span class="comment">//查看服务是否运行        System.out.println(&quot;服务正在运行: &quot;+jedis.ping());    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>4、启动redis服务</p><p>5、启动测试，结果  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地测试连接成功服务正在运行: PONG一. 配置redis.conf    1.设置访问redis的密码：requirepass 要设置密码    2.注释<span class="built_in">bind</span> 127.0.0.1    (重启redis-server服务,进入redis后要先验证密码,用这个命令：auth 密码 ,然后ping一下看有没有配置成功)二 . idea访问时添加auth密码  Jedis jedis = new Jedis(服务器的外网ip,6379);  jedis.auth(redis的密码);  System.out.println(jedis.ping());（输出PONG的话就成功了）</span><br></pre></td></tr></table></figure><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassword</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);<span class="comment">//验证密码，如果没有设置密码这段代码省略// jedis.auth(&quot;password&quot;);        jedis.connect(); //连接        jedis.disconnect(); //断开连接        jedis.flushAll(); //清空所有的key    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="对key操作的命令"><a href="#对key操作的命令" class="headerlink" title="对key操作的命令"></a>对key操作的命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestKey</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);        System.out.println(<span class="string">&quot;清空数据：&quot;</span>+jedis.flushDB());        System.out.println(<span class="string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>));        System.out.println(<span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>));        System.out.println(<span class="string">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>));        System.out.print(<span class="string">&quot;系统中所有的键如下：&quot;</span>);        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);        System.out.println(keys);        System.out.println(<span class="string">&quot;删除键password:&quot;</span>+jedis.del(<span class="string">&quot;password&quot;</span>));        System.out.println(<span class="string">&quot;判断键password是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;password&quot;</span>));        System.out.println(<span class="string">&quot;查看键username所存储的值的类型：&quot;</span>+jedis.type(<span class="string">&quot;username&quot;</span>));        System.out.println(<span class="string">&quot;随机返回key空间的一个：&quot;</span>+jedis.randomKey());        System.out.println(<span class="string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;name&quot;</span>));        System.out.println(<span class="string">&quot;取出改后的name：&quot;</span>+jedis.get(<span class="string">&quot;name&quot;</span>));        System.out.println(<span class="string">&quot;按索引查询：&quot;</span>+jedis.select(<span class="number">0</span>));        System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span>+jedis.flushDB());        System.out.println(<span class="string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize());        System.out.println(<span class="string">&quot;删除所有数据库中的所有key：&quot;</span>+jedis.flushAll());    &#125;&#125;#运行结果清空数据：OK判断某个键是否存在：<span class="keyword">false</span>新增&lt;<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;kuangshen&#x27;</span>&gt;的键值对：OK新增&lt;<span class="string">&#x27;password&#x27;</span>,<span class="string">&#x27;password&#x27;</span>&gt;的键值对：OK系统中所有的键如下：[password, username]删除键password:<span class="number">1</span>判断键password是否存在：<span class="keyword">false</span>查看键username所存储的值的类型：string随机返回key空间的一个：username重命名key：OK取出改后的name：kuangshen按索引查询：OK删除当前选择数据库中的所有key：OK返回当前数据库中key的数目：<span class="number">0</span>删除所有数据库中的所有key：OK</span><br></pre></td></tr></table></figure><h3 id="对String操作的命令"><a href="#对String操作的命令" class="headerlink" title="对String操作的命令"></a>对String操作的命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, 6379);        jedis.flushDB();        System.out.println(<span class="string">&quot;===========增加数据===========&quot;</span>);        System.out.println(jedis.set(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>));        System.out.println(jedis.set(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>));        System.out.println(jedis.set(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>));        System.out.println(<span class="string">&quot;删除键key2:&quot;</span>+jedis.del(<span class="string">&quot;key2&quot;</span>));        System.out.println(<span class="string">&quot;获取键key2:&quot;</span>+jedis.get(<span class="string">&quot;key2&quot;</span>));        System.out.println(<span class="string">&quot;修改key1:&quot;</span>+jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1Changed&quot;</span>));        System.out.println(<span class="string">&quot;获取key1的值：&quot;</span>+jedis.get(<span class="string">&quot;key1&quot;</span>));        System.out.println(<span class="string">&quot;在key3后面加入值：&quot;</span>+jedis.append(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;End&quot;</span>));        System.out.println(<span class="string">&quot;key3的值：&quot;</span>+jedis.get(<span class="string">&quot;key3&quot;</span>));        System.out.println(<span class="string">&quot;增加多个键值 对：&quot;</span>+jedis.mset(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>));        System.out.println(<span class="string">&quot;获取多个键值 对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));        System.out.println(<span class="string">&quot;获取多个键值 对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;key04&quot;</span>));        System.out.println(<span class="string">&quot;删除多个键值对：&quot;</span>+jedis.del(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>));        System.out.println(<span class="string">&quot;获取多个键值 对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));        jedis.flushDB();        System.out.println(<span class="string">&quot;===========新增键值对防止覆盖原先值==============&quot;</span>);        System.out.println(jedis.setnx(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));        System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>));        System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2-new&quot;</span>));        System.out.println(jedis.get(<span class="string">&quot;key1&quot;</span>));        System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));        System.out.println(<span class="string">&quot;===========新增键值对并设置有效时间=============&quot;</span>);        System.out.println(jedis.setex(<span class="string">&quot;key3&quot;</span>, 2, <span class="string">&quot;value3&quot;</span>));        System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));        System.out.println(<span class="string">&quot;===========获取原值，更新为新值==========&quot;</span>);        System.out.println(jedis.getSet(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key2GetSet&quot;</span>));        System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));        System.out.println(<span class="string">&quot;获得key2的值的字串：&quot;</span>+jedis.getrange(<span class="string">&quot;key2&quot;</span>, 2,                4));    &#125;&#125;<span class="comment">#运行结果===========增加数据===========OKOKOK删除键key2:1获取键key2:null修改key1:OK获取key1的值：value1Changed在key3后面加入值：9key3的值：value3End增加多个键值 对：OK获取多个键值 对：[value01, value02, value03]获取多个键值 对：[value01, value02, value03, null]删除多个键值对：2获取多个键值 对：[null, null, value03]===========新增键值对防止覆盖原先值==============110value1value2===========新增键值对并设置有效时间=============OKvalue3null===========获取原值，更新为新值==========value2key2GetSet获得key2的值的字串：y2G</span></span><br></pre></td></tr></table></figure><h3 id="对List操作命令"><a href="#对List操作命令" class="headerlink" title="对List操作命令"></a>对List操作命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);        jedis.flushDB();        System.out.println(<span class="string">&quot;===========添加一个list===========&quot;</span>);        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;ArrayList&quot;</span>, <span class="string">&quot;Vector&quot;</span>, <span class="string">&quot;Stack&quot;</span>, <span class="string">&quot;HashMap&quot;</span>, <span class="string">&quot;WeakHashMap&quot;</span>, <span class="string">&quot;LinkedHashMap&quot;</span>);        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;HashSet&quot;</span>);        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;TreeSet&quot;</span>);        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;TreeMap&quot;</span>);        System.out.println(<span class="string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));<span class="comment">//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部        System.out.println(&quot;collections区间0-3的元素：&quot;+jedis.lrange(&quot;collections&quot;,0,3));        System.out.println(&quot;===============================&quot;);// 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈        System.out.println(&quot;删除指定元素个数：&quot;+jedis.lrem(&quot;collections&quot;, 2, &quot;HashMap&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;删除下表0-3区间之外的元 素：&quot;+jedis.ltrim(&quot;collections&quot;, 0, 3));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;collections列表出栈（左端）：&quot;+jedis.lpop(&quot;collections&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;collections添加元素，从列表右端，与lpush相对 应：&quot;+jedis.rpush(&quot;collections&quot;, &quot;EnumMap&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;collections列表出栈（右 端）：&quot;+jedis.rpop(&quot;collections&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;修改collections指定下标1的内容：&quot;+jedis.lset(&quot;collections&quot;, 1, &quot;LinkedArrayList&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;===============================&quot;);        System.out.println(&quot;collections的长度：&quot;+jedis.llen(&quot;collections&quot;));        System.out.println(&quot;获取collections下标为2的元素：&quot;+jedis.lindex(&quot;collections&quot;, 2));        System.out.println(&quot;===============================&quot;);        jedis.lpush(&quot;sortedList&quot;, &quot;3&quot;,&quot;6&quot;,&quot;2&quot;,&quot;0&quot;,&quot;7&quot;,&quot;4&quot;);        System.out.println(&quot;sortedList排序前：&quot;+jedis.lrange(&quot;sortedList&quot;, 0, -1));        System.out.println(jedis.sort(&quot;sortedList&quot;));        System.out.println(&quot;sortedList排序后：&quot;+jedis.lrange(&quot;sortedList&quot;, 0, -1));    &#125;&#125;#运行结果===========添加一个list===========collections的内容：[TreeMap, TreeSet, HashSet, LinkedHashMap, WeakHashMap, HashMap, Stack, Vector, ArrayList]collections区间0-3的元素：[TreeMap, TreeSet, HashSet, LinkedHashMap]===============================删除指定元素个数：1collections的内容：[TreeMap, TreeSet, HashSet, LinkedHashMap, WeakHashMap, Stack, Vector, ArrayList]删除下表0-3区间之外的元 素：OKcollections的内容：[TreeMap, TreeSet, HashSet, LinkedHashMap]collections列表出栈（左端）：TreeMapcollections的内容：[TreeSet, HashSet, LinkedHashMap]collections添加元素，从列表右端，与lpush相对 应：4collections的内容：[TreeSet, HashSet, LinkedHashMap, EnumMap]collections列表出栈（右 端）：EnumMapcollections的内容：[TreeSet, HashSet, LinkedHashMap]修改collections指定下标1的内容：OKcollections的内容：[TreeSet, LinkedArrayList, LinkedHashMap]===============================collections的长度：3获取collections下标为2的元素：LinkedHashMap===============================sortedList排序前：[4, 7, 0, 2, 6, 3][0, 2, 3, 4, 6, 7]sortedList排序后：[4, 7, 0, 2, 6, 3]</span></span><br></pre></td></tr></table></figure><h3 id="对Set的操作命令"><a href="#对Set的操作命令" class="headerlink" title="对Set的操作命令"></a>对Set的操作命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSet</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);        jedis.flushDB();        System.out.println(<span class="string">&quot;============向集合中添加元素（不重复============&quot;</span>);        System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>,<span class="string">&quot;e2&quot;</span>,<span class="string">&quot;e4&quot;</span>,<span class="string">&quot;e3&quot;</span>,<span class="string">&quot;e0&quot;</span>,<span class="string">&quot;e8&quot;</span>,<span class="string">&quot;e7&quot;</span>,<span class="string">&quot;e5&quot;</span>));        System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e6&quot;</span>));        System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e6&quot;</span>));        System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;删除一个元素e0：&quot;</span>+jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e0&quot;</span>));        System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;删除两个元素e7和e6：&quot;</span>+jedis.srem(<span class="string">&quot;eleSet&quot;</span>,                <span class="string">&quot;e7&quot;</span>,<span class="string">&quot;e6&quot;</span>));        System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;随机的移除集合中的一个元素：&quot;</span>+jedis.spop(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;随机的移除集合中的一个元素：&quot;</span>+jedis.spop(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;eleSet中包含元素的个数：&quot;</span>+jedis.scard(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;e3是否在eleSet中：&quot;</span>+jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e3&quot;</span>));        System.out.println(<span class="string">&quot;e1是否在eleSet中：&quot;</span>+jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>));        System.out.println(<span class="string">&quot;e1是否在eleSet中：&quot;</span>+jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e5&quot;</span>));        System.out.println(<span class="string">&quot;=================================&quot;</span>);        System.out.println(jedis.sadd(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;e1&quot;</span>,<span class="string">&quot;e2&quot;</span>,<span class="string">&quot;e4&quot;</span>,<span class="string">&quot;e3&quot;</span>,<span class="string">&quot;e0&quot;</span>,<span class="string">&quot;e8&quot;</span>,<span class="string">&quot;e7&quot;</span>,<span class="string">&quot;e5&quot;</span>));        System.out.println(jedis.sadd(<span class="string">&quot;eleSet2&quot;</span>, <span class="string">&quot;e1&quot;</span>,<span class="string">&quot;e2&quot;</span>,<span class="string">&quot;e4&quot;</span>,<span class="string">&quot;e3&quot;</span>,<span class="string">&quot;e0&quot;</span>,<span class="string">&quot;e8&quot;</span>));        System.out.println(<span class="string">&quot;将eleSet1中删除e1并存入eleSet3 中：&quot;</span>+jedis.smove(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet3&quot;</span>, <span class="string">&quot;e1&quot;</span>));<span class="comment">//移到集合元素        System.out.println(&quot;将eleSet1中删除e2并存入eleSet3 中：&quot;+jedis.smove(&quot;eleSet1&quot;, &quot;eleSet3&quot;, &quot;e2&quot;));        System.out.println(&quot;eleSet1中的元素：&quot;+jedis.smembers(&quot;eleSet1&quot;));        System.out.println(&quot;eleSet3中的元素：&quot;+jedis.smembers(&quot;eleSet3&quot;));        System.out.println(&quot;============集合运算=================&quot;);        System.out.println(&quot;eleSet1中的元素：&quot;+jedis.smembers(&quot;eleSet1&quot;));        System.out.println(&quot;eleSet2中的元素：&quot;+jedis.smembers(&quot;eleSet2&quot;));        System.out.println(&quot;eleSet1和eleSet2的交集:&quot;+jedis.sinter(&quot;eleSet1&quot;,&quot;eleSet2&quot;));        System.out.println(&quot;eleSet1和eleSet2的并集:&quot;+jedis.sunion(&quot;eleSet1&quot;,&quot;eleSet2&quot;));        System.out.println(&quot;eleSet1和eleSet2的差集:&quot;+jedis.sdiff(&quot;eleSet1&quot;,&quot;eleSet2&quot;));//eleSet1中有，eleSet2中没有        jedis.sinterstore(&quot;eleSet4&quot;,&quot;eleSet1&quot;,&quot;eleSet2&quot;);//求交集并将交集保存到dstkey的集合        System.out.println(&quot;eleSet4中的元素：&quot;+jedis.smembers(&quot;eleSet4&quot;));    &#125;&#125;#运行结果============向集合中添加元素（不重复============810eleSet的所有元素为：[e1, e8, e0, e5, e7, e2, e3, e6, e4]删除一个元素e0：1eleSet的所有元素为：[e8, e5, e7, e2, e3, e6, e4, e1]删除两个元素e7和e6：2eleSet的所有元素为：[e2, e3, e4, e1, e8, e5]随机的移除集合中的一个元素：e4随机的移除集合中的一个元素：e8eleSet的所有元素为：[e3, e2, e1, e5]eleSet中包含元素的个数：4e3是否在eleSet中：truee1是否在eleSet中：truee1是否在eleSet中：true=================================86将eleSet1中删除e1并存入eleSet3 中：1将eleSet1中删除e2并存入eleSet3 中：1eleSet1中的元素：[e4, e8, e0, e5, e7, e3]eleSet3中的元素：[e1, e2]============集合运算=================eleSet1中的元素：[e4, e8, e0, e5, e7, e3]eleSet2中的元素：[e1, e3, e2, e4, e8, e0]eleSet1和eleSet2的交 集:[e3, e4, e8, e0]eleSet1和eleSet2的并 集:[e8, e0, e5, e7, e2, e3, e4, e1]eleSet1和eleSet2的差 集:[e7, e5]eleSet4中的元素：[e0, e8, e4, e3]</span></span><br></pre></td></tr></table></figure><h3 id="对Hash的操作命令"><a href="#对Hash的操作命令" class="headerlink" title="对Hash的操作命令"></a>对Hash的操作命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHash</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);        jedis.flushDB();        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);        map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);        map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);        map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);        <span class="comment">//添加名称为hash（key）的hash元素        jedis.hmset(&quot;hash&quot;,map);        //向名称为hash的hash中添加key为key5，value为value5元素        jedis.hset(&quot;hash&quot;, &quot;key5&quot;, &quot;value5&quot;);        System.out.println(&quot;散列hash的所有键值对为：&quot;+jedis.hgetAll(&quot;hash&quot;));//return Map&lt;String,String&gt;        System.out.println(&quot;散列hash的所有键为：&quot;+jedis.hkeys(&quot;hash&quot;));//returnSet&lt;String&gt;        System.out.println(&quot;散列hash的所有值为：&quot;+jedis.hvals(&quot;hash&quot;));//returnList&lt;String&gt;        System.out.println(&quot;将key6保存的值加上一个整数，如果key6不存在则添加 key6：&quot;+jedis.hincrBy(&quot;hash&quot;, &quot;key6&quot;, 6));        System.out.println(&quot;散列hash的所有键值对为：&quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;将key6保存的值加上一个整数，如果key6不存在则添加 key6：&quot;+jedis.hincrBy(&quot;hash&quot;, &quot;key6&quot;, 3));        System.out.println(&quot;散列hash的所有键值对为：&quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;删除一个或者多个键值对：&quot;+jedis.hdel(&quot;hash&quot;, &quot;key2&quot;));        System.out.println(&quot;散列hash的所有键值对为：&quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;散列hash中键值对的个数：&quot;+jedis.hlen(&quot;hash&quot;));        System.out.println(&quot;判断hash中是否存在 key2：&quot;+jedis.hexists(&quot;hash&quot;,&quot;key2&quot;));        System.out.println(&quot;判断hash中是否存在 key3：&quot;+jedis.hexists(&quot;hash&quot;,&quot;key3&quot;));        System.out.println(&quot;获取hash中的值：&quot;+jedis.hmget(&quot;hash&quot;,&quot;key3&quot;));        System.out.println(&quot;获取hash中的值：&quot;+jedis.hmget(&quot;hash&quot;,&quot;key3&quot;,&quot;key4&quot;));    &#125;&#125;#运行结果散列hash的所有键值对为：&#123;key1=value1, key2=value2, key5=value5, key3=value3, key4=value4&#125;散列hash的所有键为：[key1, key2, key5, key3, key4]散列hash的所有值为：[value4, value1, value2, value3, value5]将key6保存的值加上一个整数，如果key6不存在则添加 key6：6散列hash的所有键值对为：&#123;key1=value1, key2=value2, key5=value5, key6=6, key3=value3, key4=value4&#125;将key6保存的值加上一个整数，如果key6不存在则添加 key6：9散列hash的所有键值对为：&#123;key1=value1, key2=value2, key5=value5, key6=9, key3=value3, key4=value4&#125;删除一个或者多个键值对：1散列hash的所有键值对为：&#123;key1=value1, key5=value5, key6=9, key3=value3, key4=value4&#125;散列hash中键值对的个数：5判断hash中是否存在 key2：false判断hash中是否存在 key3：true获取hash中的值：[value3]获取hash中的值：[value3, value4]    </span></span><br></pre></td></tr></table></figure><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><blockquote><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//创建客户端连接服务端，redis服务端需要被开启        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        JSONObject jsonObject = new JSONObject();        jsonObject.put(&quot;hello&quot;, &quot;world&quot;);        jsonObject.put(&quot;name&quot;, &quot;java&quot;);        //开启事务        Transaction multi = jedis.multi();        String result = jsonObject.toJSONString();        /*jedis.watch(result)&#123;            //乐观锁        &#125;*/        try&#123;        //向redis存入一条数据            multi.set(&quot;json&quot;, result);        //再存入一条数据            multi.set(&quot;json2&quot;, result);        //这里引发了异常，用0作为被除数            int i = 100/0;        //如果没有引发异常，执行进入队列的命令            multi.exec();        &#125;catch(Exception e)&#123;            e.printStackTrace();        //如果出现异常，回滚            multi.discard();        &#125;finally&#123;            System.out.println(jedis.get(&quot;json&quot;));            System.out.println(jedis.get(&quot;json2&quot;));        //最终关闭客户端            jedis.close();        &#125;    &#125;</span></span><br></pre></td></tr></table></figure><h1 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><blockquote><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3></blockquote><p>在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。那么使用SpringBoot整合Redis需要那些步骤呢？</p><p>1、 <strong>JedisPoolConfig</strong> (这个是配置连接池)<br>2、 <strong>RedisConnectionFactory</strong> 这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在    SpringData Redis方案中提供了以下四种工厂模型：</p><ul><li>JredisConnectionFactory</li><li>JedisConnectionFactory</li><li>LettuceConnectionFactory</li><li>SrpConnectionFactory  </li></ul><p><strong>说明</strong>：在springBoot2.x之后，原来使用的jedis被替换为了lettuce</p><ul><li>jedis:采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全，使用jedis Pool连接池！更像BIO模式</li><li>lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况!可以减少线程数据，更像NIO模式</li></ul><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>    <span class="meta">@ConditionalOnMissingBean(        name = &#123;&quot;redisTemplate&quot;&#125;//我们自定义redisTemplate来替换默认的    )</span>    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span>    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;       <span class="comment">//默认的RedisTemplate没有过多的设置，redis对象都是需要序列化！        //两个泛型都是Object, Object的类型，我们需要强制转换&lt;String, Object&gt;        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        return template;    &#125;    @Bean    @ConditionalOnMissingBean//由于String是redis中最长使用的类型，所以说单独提出来了一个Bean    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        StringRedisTemplate template = new StringRedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        return template;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>3、 RedisTemplate 基本操作  </p><img src="Redis.assets/image-20210627221345387.png" alt="image-20210627221345387" style="zoom:67%;" /><blockquote><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><h3 id="yaml配置"><a href="#yaml配置" class="headerlink" title="yaml配置"></a>yaml配置</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.host=<span class="number">127.0</span><span class="number">.0</span>.1spring.redis.port=6379spring.redis.jedis.pool.max-active=8spring.redis.jedis.pool.max-wait=-1msspring.redis.jedis.pool.max-idle=500spring.redis.jedis.pool.min-idle=0spring.redis.lettuce.shutdown-timeout=0ms</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#JedisConnectionFactory不生效<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionFactory</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">RedisConnectionFactory</span> </span>&#123;   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory.getLog(JedisConnectionFactory.class);   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExceptionTranslationStrategy EXCEPTION_TRANSLATION = <span class="keyword">new</span> PassThroughExceptionTranslationStrategy(         JedisConverters.exceptionConverter());   <span class="keyword">private</span> <span class="keyword">final</span> JedisClientConfiguration clientConfiguration;   <span class="keyword">private</span> <span class="meta">@Nullable</span> JedisShardInfo shardInfo;   <span class="keyword">private</span> JedisClientConfig clientConfig = DefaultJedisClientConfig.builder().build();   <span class="keyword">private</span> <span class="keyword">boolean</span> providedShardInfo = <span class="keyword">false</span>;   <span class="keyword">private</span> <span class="meta">@Nullable</span> Pool&lt;Jedis&gt; pool;   <span class="keyword">private</span> <span class="keyword">boolean</span> convertPipelineAndTxResults = <span class="keyword">true</span>;   <span class="keyword">private</span> RedisStandaloneConfiguration standaloneConfig = <span class="keyword">new</span> RedisStandaloneConfiguration(<span class="string">&quot;localhost&quot;</span>,         Protocol.DEFAULT_PORT);   <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisConfiguration configuration;   <span class="keyword">private</span> <span class="meta">@Nullable</span> JedisCluster cluster;   <span class="keyword">private</span> <span class="meta">@Nullable</span> ClusterTopologyProvider topologyProvider;    #LettuceConnectionFactory生效<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceConnectionFactory</span><span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">RedisConnectionFactory</span>, <span class="title">ReactiveRedisConnectionFactory</span> </span>&#123;<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExceptionTranslationStrategy EXCEPTION_TRANSLATION = <span class="keyword">new</span> PassThroughExceptionTranslationStrategy(LettuceConverters.exceptionConverter());<span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());<span class="keyword">private</span> <span class="keyword">final</span> LettuceClientConfiguration clientConfiguration;<span class="keyword">private</span> <span class="meta">@Nullable</span> AbstractRedisClient client;<span class="keyword">private</span> <span class="meta">@Nullable</span> LettuceConnectionProvider connectionProvider;<span class="keyword">private</span> <span class="meta">@Nullable</span> LettuceConnectionProvider reactiveConnectionProvider;<span class="keyword">private</span> <span class="keyword">boolean</span> validateConnection = <span class="keyword">false</span>;<span class="keyword">private</span> <span class="keyword">boolean</span> shareNativeConnection = <span class="keyword">true</span>;<span class="keyword">private</span> <span class="keyword">boolean</span> eagerInitialization = <span class="keyword">false</span>;<span class="keyword">private</span> <span class="meta">@Nullable</span> SharedConnection&lt;<span class="keyword">byte</span>[]&gt; connection;<span class="keyword">private</span> <span class="meta">@Nullable</span> SharedConnection&lt;ByteBuffer&gt; reactiveConnection;<span class="keyword">private</span> <span class="meta">@Nullable</span> LettucePool pool;<span class="comment">/** Synchronization monitor for the shared Connection */</span><span class="keyword">private</span> <span class="keyword">final</span> Object connectionMonitor = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTestclass</span> Redis02SpringbootApplicationTests &#123;<span class="meta">@Autowired</span><span class="keyword">private</span> RedisTemplate redisTemplate;<span class="meta">@Test</span><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;<span class="comment">//redisTemplate操作不同的数据类型，api和指令一样//opsForValue操作字符串 类似String//opsForSet()//opsForHash()//除了基本操作，常用的方法都可以通过redisTemplate来操作//获取redis的连接对象/*RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();connection.flushDb();*/redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;hello&quot;);System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;));&#125;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h2><p>1、新建一个SpringBoot项目</p><p>2、导入redis的启动器  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>3、配置redis，可以查看 RedisProperties 分析  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis服务器地址spring.redis.host=127.0.0.1# Redis服务器连接端口spring.redis.port=6379</span></span><br></pre></td></tr></table></figure><p>4、分析 RedisAutoConfiguration 自动配置类  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(    proxyBeanMethods = false)</span><span class="meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><span class="meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">RedisAutoConfiguration</span><span class="params">()</span> </span>&#123;    &#125;    <span class="meta">@Bean</span>    <span class="meta">@ConditionalOnMissingBean(        name = &#123;&quot;redisTemplate&quot;&#125;    )</span>    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span>    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        <span class="keyword">return</span> template;    &#125;    <span class="meta">@Bean</span>    <span class="meta">@ConditionalOnMissingBean</span>    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span>    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        <span class="keyword">return</span> template;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>​        通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。但是，这个RedisTemplate的泛型是&lt;Object,Object&gt;，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为&lt;String,Object&gt;形式的RedisTemplate。并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置RedisTemplate。  </p><p>5、既然自动配置不好用，就重新配置一个RedisTemplate  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;<span class="comment">//真实的开发一般都使用json来传递对象User user = new User(&quot;hello&quot;, 3);//jackson帮我们实现序列化,直接使用对象会报序列化错误，对象必须序列化String json = new ObjectMapper().writeValueAsString(user);redisTemplate.opsForValue().set(user,json);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义RedisTemplate@Configurationpublic class RedisConfig &#123;    @Bean    @SuppressWarnings(&quot;all&quot;)    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        //自己开发方便&lt;String, Object&gt;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();        //连接工厂        template.setConnectionFactory(factory);        //序列化配置        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        //String的序列化配置        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        // key采用String的序列化方式        template.setKeySerializer(stringRedisSerializer);        // hash的key也采用String的序列化方式template.setHashKeySerializer(stringRedisSerializer);        // value序列化方式采用jackson        template.setValueSerializer(jackson2JsonRedisSerializer);        // hash的value序列化方式采用jackson        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;<span class="comment">//真实的开发一般都使用json来传递对象User user = new User(&quot;hello&quot;, 3);//jackson帮我们实现序列化,直接使用对象会报序列化错误，对象必须序列化//String json = new ObjectMapper().writeValueAsString(user);redisTemplate.opsForValue().set(&quot;user&quot;,user);//redisTemplate实现序列化System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;));&#125;127.0.0.1:6379&gt; keys *1) &quot;user&quot;</span></span><br></pre></td></tr></table></figure><p>6、写一个Redis工具类（直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。）  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.redis.utils;<span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> org.springframework.util.CollectionUtils;<span class="keyword">import</span> javax.annotation.Resource;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.Map;<span class="keyword">import</span> java.util.Set;<span class="keyword">import</span> java.util.concurrent.TimeUnit;<span class="comment">/** * <span class="doctag">@Author</span> liuhy * <span class="doctag">@Description</span>: redis工具类 * <span class="doctag">@Date</span> 2021-06-28 下午 03:07 */</span><span class="meta">@Componentpublic</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;    <span class="comment">/**     * Resource默认是按照名称来装配注入的     * Autowired默认是按照类型装配注入的，如果想按照名称来转配注入，则需要结合<span class="doctag">@Qualifier</span>一起使用     */</span><span class="comment">//    @Autowired//    @Qualifier(&quot;redisTemplate&quot;)    @Resource    private RedisTemplate&lt;String, Object&gt; redisTemplate;    // =============================common============================    /**     * 指定缓存失效时间     * @param key  键     * @param time 时间(秒)     * @return     */    public boolean expire(String key, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.expire(key, time, TimeUnit.SECONDS);            &#125;            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 根据key 获取过期时间     * @param key 键 不能为null     * @return 时间(秒) 返回0代表为永久有效     */    public long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    /**     * 判断key是否存在     * @param key 键     * @return true 存在 false不存在     */    public boolean hasKey(String key) &#123;        try &#123;            return redisTemplate.hasKey(key);        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 删除缓存     * @param key 可以传一个值 或多个     */    @SuppressWarnings(&quot;unchecked&quot;)    public void del(String... key) &#123;        if (key != null &amp;&amp; key.length &gt; 0) &#123;            if (key.length == 1) &#123;                redisTemplate.delete(key[0]);            &#125; else &#123;                redisTemplate.delete(String.valueOf(CollectionUtils.arrayToList(key)));            &#125;        &#125;    &#125;    // ============================String=============================    /**     * 普通缓存获取     * @param key 键     * @return 值     */    public Object get(String key) &#123;        return key == null ? null : redisTemplate.opsForValue().get(key);    &#125;    /**     * 普通缓存放入     * @param key   键     * @param value 值     * @return true成功 false失败     */    public boolean set(String key, Object value) &#123;        try &#123;            redisTemplate.opsForValue().set(key, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 普通缓存放入并设置时间     * @param key   键     * @param value 值     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期     * @return true成功 false 失败     */    public boolean set(String key, Object value, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125; else &#123;                set(key, value);            &#125;            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 递增     * @param key   键     * @param delta 要增加几(大于0)     * @return     */    public long incr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递增因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    /**     * 递减     * @param key   键     * @param delta 要减少几(小于0)     * @return     */    public long decr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递减因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    // ================================Map=================================    /**     * HashGet     * @param key  键 不能为null     * @param item 项 不能为null     * @return 值     */    public Object hget(String key, String item) &#123;        return redisTemplate.opsForHash().get(key, item);    &#125;    /**     * 获取hashKey对应的所有键值     * @param key 键     * @return 对应的多个键值     */    public Map&lt;Object, Object&gt; hmget(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    /**     * HashSet     * @param key 键     * @param map 对应多个键值     * @return true 成功 false 失败     */    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * HashSet 并设置时间     * @param key  键     * @param map  对应多个键值     * @param time 时间(秒)     * @return true成功 false失败     */    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     * @param key   键     * @param item  项     * @param value 值     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     * @param key   键     * @param item  项     * @param value 值     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value, long time) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 删除hash表中的值     * @param key  键 不能为null     * @param item 项 可以使多个 不能为null     */    public void hdel(String key, Object... item) &#123;        redisTemplate.opsForHash().delete(key, item);    &#125;    /**     * 判断hash表中是否有该项的值     * @param key  键 不能为null     * @param item 项 不能为null     * @return true 存在 false不存在     */    public boolean hHasKey(String key, String item) &#123;        return redisTemplate.opsForHash().hasKey(key, item);    &#125;    /**     * hash递增 如果不存在,就会创建一个 并把新增后的值返回     * @param key  键     * @param item 项     * @param by   要增加几(大于0)     * @return     */    public double hincr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, by);    &#125;    /**     * hash递减     * @param key  键     * @param item 项     * @param by   要减少记(小于0)     * @return     */    public double hdecr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, -by);    &#125;    // ============================set=============================    /**     * 根据key获取Set中的所有值     * @param key 键     * @return     */    public Set&lt;Object&gt; sGet(String key) &#123;        try &#123;            return redisTemplate.opsForSet().members(key);        &#125; catch (Exception e) &#123;            return null;        &#125;    &#125;    /**     * 根据value从一个set中查询,是否存在     * @param key   键     * @param value 值     * @return true 存在 false不存在     */    public boolean sHasKey(String key, Object value) &#123;        try &#123;            return redisTemplate.opsForSet().isMember(key, value);        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 将数据放入set缓存     * @param key    键     * @param values 值 可以是多个     * @return 成功个数     */    public long sSet(String key, Object... values) &#123;        try &#123;            return redisTemplate.opsForSet().add(key, values);        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    /**     * 将set数据放入缓存     * @param key    键     * @param time   时间(秒)     * @param values 值 可以是多个     * @return 成功个数     */    public long sSetAndTime(String key, long time, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().add(key, values);            if (time &gt; 0)                expire(key, time);            return count;        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    /**     * 获取set缓存的长度     * @param key 键     * @return 358     */    public long sGetSetSize(String key) &#123;        try &#123;            return redisTemplate.opsForSet().size(key);        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    /**     * 移除值为value的     * @param key    键     * @param values 值 可以是多个     * @return 移除的个数     */    public long setRemove(String key, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().remove(key, values);            return count;        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    // ===============================list=================================    /**     * 获取list缓存的内容     * @param key   键     * @param start 开始     * @param end   结束 0 到 -1代表所有值     * @return     */    public List&lt;Object&gt; lGet(String key, long start, long end) &#123;        try &#123;            return redisTemplate.opsForList().range(key, start, end);        &#125; catch (Exception e) &#123;            return null;        &#125;    &#125;    /**     * 获取list缓存的长度     * @param key 键     * @return     */    public long lGetListSize(String key) &#123;        try &#123;            return redisTemplate.opsForList().size(key);        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    /**     * 通过索引 获取list中的值     * @param key   键     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，     *              依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推     * @return     */    public Object lGetIndex(String key, long index) &#123;        try &#123;            return redisTemplate.opsForList().index(key, index);        &#125; catch (Exception e) &#123;            return null;        &#125;    &#125;    /**     * 将list放入缓存     * @param key   键     * @param value 值     * @return     */    public boolean lSet(String key, Object value) &#123;        try &#123;            redisTemplate.opsForList().rightPush(key, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */    public boolean lSet(String key, Object value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPush(key, value);            if (time &gt; 0)                expire(key, time);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 将list放入缓存     * @param key   键     * @param value 值     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 将list放入缓存     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            if (time &gt; 0)                expire(key, time);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 根据索引修改list中的某条数据     * @param key   键     * @param index 索引     * @param value 值     * @return     */    public boolean lUpdateIndex(String key, long index, Object value) &#123;        try &#123;            redisTemplate.opsForList().set(key, index, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 移除N个值为value     * @param key   键     * @param count 移除多少个     * @param value 值     * @return 移除的个数     */    public long lRemove(String key, long count, Object value) &#123;        try &#123;            Long remove = redisTemplate.opsForList().remove(key, count, value);            return remove;        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>7.测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span><span class="keyword">private</span> RedisUtil redisUtil;<span class="meta">@Test</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;redisUtil.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hello,world&quot;</span>);System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="Units-单位"><a href="#Units-单位" class="headerlink" title="Units 单位"></a>Units 单位</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis configuration file example.## Note that in order to read the configuration file, Redis must be# started with the file path as first argument:## ./redis-server /path/to/redis.conf# Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br></pre></td></tr></table></figure><p>​    1、配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>​    2、对大小写不敏感  </p><h3 id="INCLUDES-包含"><a href="#INCLUDES-包含" class="headerlink" title="INCLUDES 包含"></a>INCLUDES 包含</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## INCLUDES #################################### Include one or more other config files here.  This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings.  Include files can include# other files, so use this wisely.## Note that option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you&#x27;d better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf</span></span><br></pre></td></tr></table></figure><p>和Spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！  </p><h3 id="NETWORK-网络配置"><a href="#NETWORK-网络配置" class="headerlink" title="NETWORK 网络配置"></a>NETWORK 网络配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment"># 绑定的ipprotected-mode yes # 保护模式port 6379 # 默认端口1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="GENERAL-通用"><a href="#GENERAL-通用" class="headerlink" title="GENERAL 通用"></a>GENERAL 通用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes <span class="comment"># 默认情况下，Redis不作为守护进程运行。需要开启的话，改为 yessupervised no # 可通过upstart和systemd管理Redis守护进程pidfile /var/run/redis_6379.pid # 以后台进程方式运行redis，则需要指定pid 文件loglevel notice # 日志级别。可选项有：# debug（记录大量日志信息，适用于开发、测试阶段）；# verbose（较多日志信息）；# notice（适量日志信息，使用于生产环境）；# warning（仅有部分重要、关键信息才会被记录）。logfile &quot;&quot; # 日志文件的位置，当指定为空字符串时，为标准输出databases 16 # 设置数据库的数目。默认的数据库是DB 0always-show-logo yes # 是否总是显示logo</span></span><br></pre></td></tr></table></figure><h3 id="SNAPSHOPTING-快照"><a href="#SNAPSHOPTING-快照" class="headerlink" title="SNAPSHOPTING 快照"></a>SNAPSHOPTING 快照</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）save 900 1# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）save 300 10# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）save 60 10000stop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作rdbcompression yes # 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间rdbchecksum yes # 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗dbfilename dump.rdb # dbfilenamerdb文件名称dir ./ # dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span></span><br></pre></td></tr></table></figure><h3 id="REPLICATION-复制"><a href="#REPLICATION-复制" class="headerlink" title="REPLICATION 复制"></a>REPLICATION 复制</h3><h3 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h3><p>访问密码的查看，设置和取消  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动redis# 连接客户端# 获得和设置密码config get requirepassconfig set requirepass &quot;123456&quot;#测试ping，发现需要验证127.0.0.1:6379&gt; pingNOAUTH Authentication required.# 验证127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; pingPONG</span></span><br></pre></td></tr></table></figure><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000 <span class="comment"># 设置能连上redis的最大客户端连接数量maxmemory &lt;bytes&gt; # redis配置的最大内存容量maxmemory-policy noeviction # maxmemory-policy 内存达到上限的处理策略#volatile-lru：利用LRU算法移除设置过过期时间的key。#volatile-random：随机移除设置过过期时间的key。#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）#allkeys-lru：利用LRU算法移除任何key。#allkeys-random：随机移除任何key。#noeviction：不移除任何key，只是返回一个写错误。</span></span><br></pre></td></tr></table></figure><h3 id="append-only模式-AOF配置"><a href="#append-only模式-AOF配置" class="headerlink" title="append only模式  [AOF配置]"></a>append only模式  [AOF配置]</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment">#默认不开启，是否以append only模式作为持久化方式，默认使用是rdb方式持久化，这种方式在许多应用中已经足够用了appendfilename &quot;appendonly.aof&quot; # appendfilename AOF 文件名称appendfsync everysec # appendfsync aof持久化策略的配置# no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。# always表示每次写入都执行fsync，以保证数据同步到磁盘。# everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br></pre></td></tr></table></figure><h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1、Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程  </span><br><span class="line">daemonize no </span><br><span class="line">2、当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定  </span><br><span class="line">pidfile /var/run/redis.pid    </span><br><span class="line">3、指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字  </span><br><span class="line">port 6379  </span><br><span class="line">4、绑定的主机地址  </span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1  </span><br><span class="line">5、当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class="line">timeout 300</span><br><span class="line">6、指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class="line">loglevel verbose</span><br><span class="line">7、日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class="line">logfile stdout</span><br><span class="line">8、设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</span><br><span class="line">databases 16</span><br><span class="line">9、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line">    save</span><br><span class="line">    Redis默认配置文件中提供了三个条件：</span><br><span class="line">    save 900 1</span><br><span class="line">    save 300 10</span><br><span class="line">    save 60 10000</span><br><span class="line">分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class="line">10、指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class="line">rdbcompression yes</span><br><span class="line">11、指定本地数据库文件名，默认值为dump.rdb</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">12、指定本地数据库存放目录</span><br><span class="line">dir ./</span><br><span class="line">13、设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class="line">slaveof</span><br><span class="line">14、当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class="line">masterauth</span><br><span class="line">15、设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭</span><br><span class="line">requirepass foobared</span><br><span class="line">16、设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class="line">maxclients 128</span><br><span class="line">17、指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class="line">maxmemory</span><br><span class="line">18、指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class="line">appendonly no</span><br><span class="line">19、指定更新日志文件名，默认为appendonly.aof</span><br><span class="line">appendfilename appendonly.aof</span><br><span class="line">20、指定更新日志条件，共有3个可选值：</span><br><span class="line">    no：表示等操作系统进行数据缓存同步到磁盘（快）</span><br><span class="line">    always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</span><br><span class="line">    everysec：表示每秒同步一次（折衷，默认值）</span><br><span class="line">    appendfsync everysec</span><br><span class="line">21、指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章会仔细分析Redis的VM机制）</span><br><span class="line">vm-enabled no</span><br><span class="line">22、虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class="line">vm-swap-file /tmp/redis.swap</span><br><span class="line">23、将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class="line">vm-max-memory 0</span><br><span class="line">24、Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class="line">vm-page-size 32</span><br><span class="line">25、设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class="line">vm-pages 134217728</span><br><span class="line">26、设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span><br><span class="line">vm-max-threads 4</span><br><span class="line">27、设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class="line">glueoutputbuf yes</span><br><span class="line">28、指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class="line">hash-max-zipmap-entries 64</span><br><span class="line">hash-max-zipmap-value 512</span><br><span class="line">29、指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class="line">activerehashing yes</span><br><span class="line">30、指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class="line">include /path/to/local.conf</span><br></pre></td></tr></table></figure><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>​        Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！  </p><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3></blockquote><p>​        在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><p>​        Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p><p>​        RDB的缺点是最后一次持久化后的数据可能丢失。  </p><img src="Redis.assets/image-20210628141721740.png" alt="image-20210628141721740" style="zoom: 67%;" /><blockquote><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3></blockquote><p>​        Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。  </p><p>​        <strong>Rdb 保存的是 dump.rdb 文件</strong>  </p><img src="Redis.assets/image-20210628122207250.png" alt="image-20210628122207250" style="zoom:67%;" /><blockquote><h3 id="配置位置及SNAPSHOTTING解析"><a href="#配置位置及SNAPSHOTTING解析" class="headerlink" title="配置位置及SNAPSHOTTING解析"></a>配置位置及SNAPSHOTTING解析</h3></blockquote><img src="Redis.assets/image-20210628122426501.png" alt="image-20210628122426501" style="zoom:67%;" /><p>这里的触发条件机制，我们可以修改测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 5 # 120秒内修改10次则触发RDB</span><br></pre></td></tr></table></figure><p>RDB 是整合内存的压缩过的Snapshot，RDB 的数据结构，可以配置复合的快照触发条件。</p><p>如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效 !  </p><blockquote><h3 id="其余命令解析"><a href="#其余命令解析" class="headerlink" title="其余命令解析"></a>其余命令解析</h3></blockquote><p><strong>Stop-writes-on-bgsave-error：</strong>如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制，默认为yes。<br><strong>rbdcompression：</strong>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩，如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。<br><strong>rdbchecksum：</strong>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为yes。  </p><blockquote><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3></blockquote><p>1、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb<br>2、命令save或者是bgsave，save 时只管保存，其他不管，全部阻塞bgsave，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。<br>3、执行flushall命令，也会产生 dump.rdb 文件，但里面是空的，无意义 !<br>4、退出的时候也会产生 dump.rdb 文件！  </p><p>​    备份就会自动生成一个dump.rdb文件</p><blockquote><h3 id="恢复rdb文件"><a href="#恢复rdb文件" class="headerlink" title="恢复rdb文件"></a>恢复rdb文件</h3></blockquote><p>1、将备份文件（dump.rdb）移动到redis安装目录并启动服务即可<br>2、CONFIG GET dir 获取目录  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">dir</span><br><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure><blockquote><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3></blockquote><p>==<strong>优点：</strong>==<br>        1、适合大规模的数据恢复<br>        2、对数据完整性和一致性要求不高  </p><p><strong>==缺点：==</strong><br>        1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改<br>        2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。  </p><blockquote><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3></blockquote><img src="Redis.assets/image-20210628142342673.png" alt="image-20210628142342673" style="zoom:67%;" /><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><blockquote><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3></blockquote><p>​        将我们的所有命令都记录下来，以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件，但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作<br>​        Aof保存的是 appendonly.aof 文件。</p><img src="Redis.assets/image-20210628170401516.png" alt="image-20210628170401516" style="zoom:67%;" /><blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment"># 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种方式在许多应用中已经足够用了</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># appendfilename AOF 文件名称</span></span><br><span class="line">appendfsync everysec <span class="comment"># appendfsync aof持久化策略的配置</span></span><br><span class="line"><span class="comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span></span><br><span class="line"><span class="comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span></span><br><span class="line"><span class="comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br><span class="line">No-appendfsync-on-rewrite <span class="comment">#重写时是否可以运用Appendfsync，用默认no即可，保证数据安</span></span><br><span class="line">全性</span><br><span class="line">Auto-aof-rewrite-min-size <span class="comment"># 设置重写的基准值</span></span><br><span class="line">Auto-aof-rewrite-percentage <span class="comment">#设置重写的基准值</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="AOF-启动-修复-恢复"><a href="#AOF-启动-修复-恢复" class="headerlink" title="AOF 启动/修复/恢复"></a>AOF 启动/修复/恢复</h3></blockquote><p><strong>正常恢复：</strong></p><ul><li>启动：设置Yes，修改默认的appendonly no，改为yes<br>将有数据的aof文件复制一份保存到对应目录（config get dir）</li><li>恢复：重启redis然后重新加载</li></ul><p><strong>异常恢复</strong>：</p><ul><li>启动：设置Yes</li><li>故意破坏 appendonly.aof 文件！</li><li>修复： ==redis-check-aof –fix appendonly.aof== 进行修复</li><li>恢复：重启 redis 然后重新加载  </li></ul><blockquote><h3 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h3></blockquote><p><strong>是什么：</strong><br>        AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis 就会启动AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof ！<br><strong>重写原理：</strong></p><p>​        AOF 文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，这点和快照有点类似！<br><strong>触发机制：</strong><br>​        Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的已被且文件大于64M的触发。</p><blockquote><h3 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h3></blockquote><p><strong>==优点：==</strong><br>        1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好<br>        2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失<br>        3、不同步： appendfsync no 从不同步<br><strong>==缺点：==</strong><br>        1、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。<br>        2、Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和rdb相同。  </p><blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3></blockquote><img src="Redis.assets/image-20210628144610788.png" alt="image-20210628144610788" style="zoom:67%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储<br>2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。<br>3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化<br>4、同时开启两种持久化方式</p><ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li></ul><p>5、性能建议</p><ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。</li><li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li><li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。  </li></ul><h1 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种==消息通信模式==：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。  </p><img src="Redis.assets/image-20210628190846144.png" alt="image-20210628190846144" style="zoom:67%;" /><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：  </p><img src="Redis.assets/image-20210628190934926.png" alt="image-20210628190934926" style="zoom:67%;" /><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：  </p><img src="Redis.assets/image-20210628191040701.png" alt="image-20210628191040701" style="zoom:67%;" /><blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3></blockquote><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。  </p><img src="Redis.assets/image-20210628191135462.png" alt="image-20210628191135462" style="zoom: 80%;" /><blockquote><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3></blockquote><p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class="string">&quot;Hello,Redis&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 订阅者的客户端会显示如下消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3) <span class="string">&quot;Hello,Redis&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3) <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></blockquote><p>​        Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。       SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。<br>​        使用场景：</p><ul><li>Pub/Sub构建实时消息系统</li><li>Redis的Pub/Sub系统可以构建实时的消息系统</li><li>比如很多用Pub/Sub构建的实时聊天系统的例子。  </li></ul><h1 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。**==Master以写为主，Slave 以读为主。==<strong>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。<br>​        主从复制的作用主要包括：<br>​                1、</strong>数据冗余：**主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。  </p><p>​                2、<strong>故障恢复：</strong>当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p><p>​                3、<strong>负载均衡：</strong>在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连                        接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负                        载，可以大大提高Redis服务器的并发量。</p><p>​                4、<strong>高可用基石：</strong>除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。  </p><p>​        一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：<br>​            1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；<br>​            2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般    来说，单台Redis最大使用内存不应该超过20G。电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。<br>​        对于这种场景，我们可以使如下这种架构  :</p><img src="Redis.assets/image-20210628192413232.png" alt="image-20210628192413232" style="zoom: 50%;" /><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><blockquote><h3 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h3></blockquote><p>配从库不配主库，从库配置：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos bin]<span class="comment"># redis-server myredis/redis.conf </span></span><br><span class="line">[root@VM-0-4-centos bin]<span class="comment"># redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; info replication<span class="comment"># 查看信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment">#角色</span></span><br><span class="line">connected_slaves:0<span class="comment">#没有主机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1731bad0ad9964f2e9bafcc11517928cc38b55fb</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line">slaveof 主库ip 主库端口 <span class="comment"># 配置主从</span></span><br></pre></td></tr></table></figure><p>每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件！  </p><blockquote><h3 id="修改配置文件！"><a href="#修改配置文件！" class="headerlink" title="修改配置文件！"></a>修改配置文件！</h3></blockquote><p>准备工作：我们配置主从复制，至少需要三个，一主二从！配置三个客户端！  </p><p>1、拷贝多个redis.conf 文件  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># cp redis.conf redis1.conf</span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># cp redis.conf redis2.conf</span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># cp redis.conf redis3.conf</span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># ls</span></span><br><span class="line">redis1.conf  redis2.conf  redis3.conf  redis.conf</span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># vim redis1.conf </span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># vim redis2.conf </span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># vim redis3.conf </span></span><br></pre></td></tr></table></figure><p>2、指定端口 6379，依次类推</p><p>3、开启daemonize yes</p><p>4、Pid文件名字 pidfile /var/run/redis_6379.pid , 依次类推</p><p>5、Log文件名字 logfile “6379.log” , 依次类推</p><p>6、Dump.rdb 名字 dbfilename dump6379.rdb , 依次类推  </p><p>上面都配置完毕后，3个服务通过3个不同的配置文件开启，我们的准备环境就OK 了！  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos bin]# redis-server myredis/redis1.conf </span><br><span class="line">[root@VM-0-4-centos bin]# redis-server myredis/redis2.conf </span><br><span class="line">[root@VM-0-4-centos bin]# redis-server myredis/redis3.conf </span><br><span class="line">[root@VM-0-4-centos bin]# ll</span><br><span class="line">total 21964</span><br><span class="line">-rw-r--r-- 1 root root      958 Jun 28 20:34 6379.log</span><br><span class="line">-rw-r--r-- 1 root root      958 Jun 28 20:35 6380.log</span><br><span class="line">-rw-r--r-- 1 root root      958 Jun 28 20:35 6381.log</span><br><span class="line">[root@VM-0-4-centos bin]# ps -ef|grep redis</span><br><span class="line">root      6635     1  0 20:34 ?        00:00:00 redis-server 127.0.0.1:6379</span><br><span class="line">root      6813     1  0 20:35 ?        00:00:00 redis-server 127.0.0.1:6380</span><br><span class="line">root      6925     1  0 20:35 ?        00:00:00 redis-server 127.0.0.1:6381</span><br><span class="line">root      7142 23419  0 20:36 pts/1    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure><h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><blockquote><h3 id="1、一主二从"><a href="#1、一主二从" class="headerlink" title="1、一主二从"></a>1、一主二从</h3></blockquote><p>1、环境初始化  </p><p>默认三个都是Master 主节点  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos bin]# redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">root@VM-0-4-centos bin]# redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">root@VM-0-4-centos bin]# redis-cli -p 6381</span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br></pre></td></tr></table></figure><p>2、配置为一个Master 两个Slave  ,一主（79）二从（80,81）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line"></span><br><span class="line"><span class="comment">#从机6380</span></span><br><span class="line">127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line"></span><br><span class="line"><span class="comment">#从机6381</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=126,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=126,lag=0</span><br></pre></td></tr></table></figure><p>这只是暂时的，不是永久的，永久的需要在配置文件中配置。</p><blockquote><h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3></blockquote><p>3、在主机设置值，在从机都可以取到！从机不能写值  </p><p>测试一：主机挂了，查看从机信息，主机恢复，再次查看信息<br>测试二：从机挂了，查看主机信息，从机恢复，查看从机信息  </p><p>如果是使用命令行，来配置主从，如果重启会变成主机！只要变为从机，立马就会从主机中获取值！</p><blockquote><h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3></blockquote><p>​    Slave 启动成功连接到 master 后会发送一个sync同步，Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><ul><li><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p><p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行  </p></li></ul><blockquote><h3 id="2、层层链路"><a href="#2、层层链路" class="headerlink" title="2、层层链路"></a>2、层层链路</h3></blockquote><p>上一个Slave 可以是下一个slave 和 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 slave 作为了链条中下一个的master，可以有效减轻 master 的写压力！ </p><p><img src="Redis.assets/image-20210628211022643.png" alt="image-20210628211022643"> </p><img src="Redis.assets/image-20210628211048900.png" alt="image-20210628211048900" style="zoom:67%;" /><blockquote><h3 id="谋朝篡位"><a href="#谋朝篡位" class="headerlink" title="谋朝篡位"></a>谋朝篡位</h3></blockquote><p>一主二从的情况下，如果主机断了，从机可以使用命令 SLAVEOF NO ONE 将自己改为主机！这个时候其余的从机链接到这个节点。对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。  </p><p>哨兵模式  </p><h2 id="哨兵模式-自动选老大"><a href="#哨兵模式-自动选老大" class="headerlink" title="哨兵模式  [自动选老大]"></a>哨兵模式  [自动选老大]</h2><blockquote><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3></blockquote><p>​        主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。<br>​        哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。<strong>其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong>  </p><p><img src="Redis.assets/image-20210628213441135.png" alt="image-20210628213441135"></p><p><strong>这里的哨兵有两个作用：</strong></p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服<br>务器，修改配置文件，让它们切换主机。</li></ul><p>​        然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了<strong>多哨兵模式</strong>。 </p><p><img src="Redis.assets/image-20210628213537501.png" alt="image-20210628213537501"></p><p>​        假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次<strong>投票</strong>，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为==<strong>客观下线</strong>==。  </p><blockquote><h3 id="配置测试"><a href="#配置测试" class="headerlink" title="配置测试"></a>配置测试</h3></blockquote><p>1、调整结构，6379带着80、81<br>2、自定义的 /myredis 目录下新建 sentinel.conf 文件，名字千万不要错<br>3、配置哨兵，填写内容</p><ul><li>sentinel monitor 被监控主机名字 127.0.0.1 6379 1</li><li>上面最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>4、启动哨兵</p><ul><li>Redis-sentinel /myredis/sentinel.conf</li><li>上述目录依照各自的实际情况配置，可能目录不同</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos bin]# redis-sentinel myredis/sentinel.conf</span><br><span class="line">4178:X 28 Jun 2021 22:26:00.724 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">4178:X 28 Jun 2021 22:26:00.724 # Redis version=6.2.1, bits=64, commit=00000000, modified=0, pid=4178, just started</span><br><span class="line">4178:X 28 Jun 2021 22:26:00.724 # Configuration loaded</span><br><span class="line">4178:X 28 Jun 2021 22:26:00.725 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &#x27;&#x27;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 6.2.1 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._                                   </span><br><span class="line"> (    &#x27;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 26379</span><br><span class="line"> |    `-._   `._    /     _.-&#x27;    |     PID: 4178</span><br><span class="line">  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">      `-._    `-.__.-&#x27;    _.-&#x27;                                       </span><br><span class="line">          `-._        _.-&#x27;                                           </span><br><span class="line">              `-.__.-&#x27;                                           </span><br></pre></td></tr></table></figure><p>5、正常主从演示<br>6、原有的Master 挂了<br>7、投票新选<br>8、重新主从继续开工，info replication 查查看<br>9、问题：如果之前的master 重启回来，会不会双master 冲突？ 之前的回来只能做小弟了  </p><blockquote><h3 id="哨兵模式的优缺点"><a href="#哨兵模式的优缺点" class="headerlink" title="哨兵模式的优缺点"></a>哨兵模式的优缺点</h3></blockquote><ol><li><strong>优点</strong><ol><li>哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。</li><li>主从可以切换，故障可以转移，系统可用性更好。</li><li>哨兵模式是主从模式的升级，系统更健壮，可用性更高。</li></ol></li><li><strong>缺点</strong><ol><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li><li>实现哨兵模式的配置也不简单，甚至可以说有些繁琐  </li></ol></li></ol><blockquote><h3 id="哨兵配置说明"><a href="#哨兵配置说明" class="headerlink" title="哨兵配置说明"></a>哨兵配置说明</h3></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure><h1 id="缓存穿透和雪崩"><a href="#缓存穿透和雪崩" class="headerlink" title="缓存穿透和雪崩"></a>缓存穿透和雪崩</h1><p>​        Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。<br>​        另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3></blockquote><p>​        缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。 【查不到】 </p><ul><li>应用服务器压力变大</li><li>redis命中率低，查不到</li><li>一直查询数据库</li></ul><img src="Redis.assets/image-20210629082127204.png" alt="image-20210629082127204" style="zoom: 50%;" /><p><img src="Redis.assets/image-20210629085239091.png" alt="image-20210629085239091"></p><blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3></blockquote><p><strong>布隆过滤器</strong>  </p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；  </p><p><img src="Redis.assets/image-20210628223943146.png" alt="image-20210628223943146"></p><p><strong>缓存空对象</strong>  </p><p>​        当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；  </p><p><img src="Redis.assets/image-20210628224016105.png" alt="image-20210628224016105"></p><p>但是这种方法会存在两个问题：<br>    1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；<br>    2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。  </p><p><strong>设置可访问的名单（白名单）：</strong></p><p>​        使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><p><strong>进行实时监控：</strong></p><p>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3></blockquote><p>​            这里需要注意和缓存击穿的区别，缓存击穿，是指<strong>一个key非常热点</strong>，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。<strong>当某个key在过期的瞬间，有大量的请求并发访问</strong>，这类数据一般是<strong>热点数据，由于缓存过期，会同时访问数据库来查询最新数据</strong>，并且回写缓存，会导使数据库瞬间压力过大。 【微博服务器宕机】【量太大，缓存过期】 </p><img src="Redis.assets/image-20210629090241082.png" alt="image-20210629090241082" style="zoom:33%;" /><img src="Redis.assets/image-20210629090027844.png" alt="image-20210629090027844"  /><blockquote><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3></blockquote><p><strong>设置热点数据永不过期</strong><br>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长。<br><strong>加互斥锁</strong><br>分布式锁【setnx】：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。  </p><img src="Redis.assets/image-20210629084011295.png" alt="image-20210629084011295" style="zoom:50%;" /><p><img src="Redis.assets/image-20210629090810299.png" alt="image-20210629090810299"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3></blockquote><p>​        缓存雪崩，是指在某一个时间段，缓存集中过期失效。<br>​        产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><img src="Redis.assets/image-20210629090942875.png" alt="image-20210629090942875" style="zoom: 67%;" />  <p><img src="Redis.assets/image-20210628224518800.png" alt="image-20210628224518800"></p><p>​        其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。  </p><p>​        双十一：停掉一些服务，保证主要的服务可用。</p><p>​        缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p><blockquote><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3></blockquote><p><strong>redis高可用</strong>【<strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）】<br>        这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。<br><strong>限流降级</strong>【 <strong>使用锁或队列：</strong>】<br>        这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。<br><strong>数据预热</strong>：<br>        数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。  </p><p><strong>将缓存失效时间分散开：</strong></p><p>​            比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>​        随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种<strong>跨JVM的互斥机制来控制共享资源的访问</strong>，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><ol><li><p><strong>基于数据库实现分布式锁</strong></p></li><li><p><strong>基于缓存（Redis等）</strong></p></li><li><p><strong>基于Zookeeper</strong></p></li></ol><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li><p><strong>性能：redis最高</strong></p></li><li><p><strong>可靠性：zookeeper最高</strong></p></li></ol><p>这里，我们就基于redis实现分布式锁。</p><h3 id="使用redis实现分布式锁"><a href="#使用redis实现分布式锁" class="headerlink" title="使用redis实现分布式锁"></a><strong>使用redis实现分布式锁</strong></h3><p>​        NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。XX ：只在键已经存在时，才对键进行设置操作。</p><p><img src="Redis.assets/image-20210629092044287.png" alt="image-20210629092044287"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx users 10   <span class="comment">#setnx加锁</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 20</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; del users<span class="comment">#删除锁</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 30</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; expire users 10<span class="comment">#设置锁的过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl users</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl users</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; setnx users 40</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#防止加锁的时候出现异常 实现原子操作</span></span><br><span class="line"><span class="built_in">set</span> users 10 nx ex 12</span><br></pre></td></tr></table></figure><ol><li><p>多个客户端同时获取锁（setnx）</p></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1获取锁，setnx lock 111  3秒以后过期</span></span><br><span class="line">Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line"><span class="keyword">if</span>(lock)&#123;</span><br><span class="line">Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="comment">//2.1判断num为空return</span></span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.2有值就转成成int</span></span><br><span class="line"><span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//2.3把redis的num加1</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line"><span class="comment">//2.4释放锁，del</span></span><br><span class="line">redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">testLock();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题一：优化UUID防止误删"><a href="#问题一：优化UUID防止误删" class="headerlink" title="问题一：优化UUID防止误删"></a>问题一：优化UUID防止误删</h3><img src="Redis.assets/image-20210629100331986.png" alt="image-20210629100331986" style="zoom:67%;" /><p><strong>解决：</strong></p><img src="Redis.assets/image-20210629100525010.png" alt="image-20210629100525010" style="zoom:50%;" /><img src="Redis.assets/image-20210629100549964.png" alt="image-20210629100549964" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//1获取锁，setnx lock 111  3秒以后过期</span></span><br><span class="line">Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;uuid&quot;</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//2.4释放锁，del</span></span><br><span class="line"><span class="comment">//判断比较uuid是否一样</span></span><br><span class="line">String lockUuid = (String) redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(lockUuid.equals(uuid))&#123;</span><br><span class="line">redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题二：优化之LUA脚本保证删除的原子性"><a href="#问题二：优化之LUA脚本保证删除的原子性" class="headerlink" title="问题二：优化之LUA脚本保证删除的原子性"></a>问题二：<strong>优化之LUA脚本保证删除的原子性</strong></h3><img src="Redis.assets/image-20210629101740773.png" alt="image-20210629101740773" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLockLua&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLockLua</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span></span><br><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span></span><br><span class="line">String skuId = <span class="string">&quot;25&quot;</span>; <span class="comment">// 访问skuId 为25号的商品 100008348542</span></span><br><span class="line">String locKey = <span class="string">&quot;lock:&quot;</span> + skuId; <span class="comment">// 锁住的是每个商品的数据</span></span><br><span class="line"><span class="comment">// 3 获取锁</span></span><br><span class="line">Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 第一种： lock 与过期时间中间不写任何的代码。</span></span><br><span class="line"><span class="comment">// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间</span></span><br><span class="line"><span class="comment">// 如果true</span></span><br><span class="line"><span class="keyword">if</span> (lock) &#123;</span><br><span class="line"><span class="comment">// 执行的业务逻辑开始</span></span><br><span class="line"><span class="comment">// 获取缓存中的num 数据</span></span><br><span class="line">Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="comment">// 如果是空直接返回</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span></span><br><span class="line"><span class="keyword">int</span> num = Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 使num 每次+1 放入缓存</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, String.valueOf(++num));</span><br><span class="line"><span class="comment">/*使用lua脚本来锁，保证删除锁的原子性*/</span></span><br><span class="line"><span class="comment">// 定义lua 脚本</span></span><br><span class="line">String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="comment">// 使用redis执行lua执行</span></span><br><span class="line">DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">redisScript.setScriptText(script);</span><br><span class="line"><span class="comment">// 设置一下返回值类型 为Long</span></span><br><span class="line"><span class="comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span></span><br><span class="line"><span class="comment">// 那么返回字符串与0 会有发生错误。</span></span><br><span class="line">redisScript.setResultType(Long.class);</span><br><span class="line"><span class="comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span></span><br><span class="line">redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 其他线程等待</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 睡眠</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 睡醒了之后，调用方法。</span></span><br><span class="line">testLockLua();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="Redis.assets/image-20210629102543152.png" alt="image-20210629102543152" style="zoom:150%;" /><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><ul><li> 互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NoSQL概述&quot;&gt;&lt;a href=&quot;#NoSQL概述&quot; class=&quot;headerlink&quot; title=&quot;NoSQL概述&quot;&gt;&lt;/a&gt;NoSQL概述&lt;/h1&gt;&lt;h2 id=&quot;发展历史&quot;&gt;&lt;a href=&quot;#发展历史&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/07/01/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/07/01/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-07-01T10:42:11.740Z</published>
    <updated>2021-06-25T10:37:50.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="Java内存区域与Java内存模型"><a href="#Java内存区域与Java内存模型" class="headerlink" title="Java内存区域与Java内存模型"></a>Java内存区域与Java内存模型</h2><h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><img src="Java内存模型.assets/image-20210625102921067.png" alt="image-20210625102921067" style="zoom: 80%;" /><p>​        Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中<strong>红色</strong>部分代表的是所有线程共享的数据区域，而<strong>灰色</strong>部分代表的是每个线程的私有数据区域。</p><ul><li><p><strong>程序计数器(Program Counter Register)：</strong></p><p>​        由于CPU执行指令是可中断的，会有线程切换，程序计数器会记录当前线程执行的字节码指令地址(行号)，以便线程切换后能恢复到正确的执行位置。</p></li><li><p><strong>本地方法栈(Native Method Stacks)：</strong></p><p>​        与虚拟机栈非常相似，区别在于本地方法栈为虚拟机的Native方法服务【管理本地方法】；Hotspot将JVM栈和本地方法栈合二为一。</p></li><li><p><strong>虚拟机栈(Java Virtual Machine Stacks)：</strong></p><p>​        属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程。</p></li><li><p><strong>JVM堆（Java Heap）：</strong></p><p>​        Java 堆也是属于线程共享的内存区域，它在虚拟机启动时创建，是Java 虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java 堆是垃圾收集器管理的主要区域。</p></li><li><p><strong>方法区（Method Area）：</strong></p><p>​        方法区属于线程共享的内存区域，又称Non-Heap（非堆），主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。</p><h3 id="Java内存模型-1"><a href="#Java内存模型-1" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>​        JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或者规范，定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p></li></ul><img src="Java内存模型.assets/image-20210625145331439.png" alt="image-20210625145331439" style="zoom: 67%;" /><h4 id="主内存与工作内存八种操作指令："><a href="#主内存与工作内存八种操作指令：" class="headerlink" title="主内存与工作内存八种操作指令："></a>主内存与工作内存八种操作指令：</h4><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态；</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中；</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作；</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用；</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</li></ul><p>​        如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ul><li><p>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现；</p></li><li><p>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存；</p></li><li><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中；</p></li><li><p>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或 assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作；</p></li><li><p>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执 行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁；</p></li><li><p>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值；</p></li><li><p>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量；</p></li><li><p>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）；</p></li><li><p><strong>主内存</strong></p></li></ul><p>​        主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。</p><ul><li><strong>工作内存</strong></li></ul><p>​        主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p><h2 id="硬件内存架构与Java内存模型"><a href="#硬件内存架构与Java内存模型" class="headerlink" title="硬件内存架构与Java内存模型"></a>硬件内存架构与Java内存模型</h2><h3 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h3><img src="Java内存模型.assets/image-20210625151138200.png" alt="image-20210625151138200" style="zoom: 80%;" /><p>​        当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存(当然如果CPU缓存中存在需要的数据就会直接从缓存获取)，进而在读取CPU缓存到寄存器，当CPU需要写数据到主存时，同样会先刷新寄存器中的数据到CPU缓存，然后再把数据刷新到主内存中。</p><h3 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h3><img src="Java内存模型.assets/image-20210625151414347.png" alt="image-20210625151414347" style="zoom:67%;" /><p>​        当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存(当然如果CPU缓存中存在需要的数据就会直接从缓存获取)，进而在读取CPU缓存到寄存器，当CPU需要写数据到主存时，同样会先刷新寄存器中的数据到CPU缓存，然后再把数据刷新到主内存中。多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。</p><h2 id="JMM存在的必要性"><a href="#JMM存在的必要性" class="headerlink" title="JMM存在的必要性"></a>JMM存在的必要性</h2><p>​        JMM定义了Java虚拟机(JVM)在计算机内存(RAM)中的工作方式，每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。</p><img src="Java内存模型.assets/image-20210625151656565.png" alt="image-20210625151656565" style="zoom:80%;" /><p>​        主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作，A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案是，不确定，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x=2，但到底是哪种情况先发生呢？这是不确定的，这也就是所谓的线程安全问题。<br>​        为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见，这组规则也称为Java内存模型（即JMM），JMM是围绕着程序执行的原子性、有序性、可见性展开的。</p><ul><li><p>JMM关于同步的规定：</p><pre><code>1、线程解锁前，必须把共享变量的值刷新回主内存2、线程加锁前，必须读取主内存的最新值到自己的工作内存3、加锁解锁是同一把锁</code></pre></li><li><p>1.原子性-保证指令不会受到线程上下文切换的影响。</p></li><li><p>2.可见性-保证指令不会受cpu缓存的影响。</p></li><li><p>3.有序性-保证指令不会受cpu指令并行优化的影响。</p></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>​        原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。比如对于一个静态变量int x，两条线程同时对他赋值，线程A赋值为1，而线程B赋值为2，不管线程如何运行，最终x的值要么是1，要么是2，线程A和线程B间的操作是没有干扰的，这就是原子性操作，不可被中断的特点。<br>         有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型，byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>​        可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。但在多线程环境中可就不一定了，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外<strong>指令重排以及编译器优化</strong>也可能导致可见性问题，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>​        对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。</p><h3 id="JMM提供的解决方案"><a href="#JMM提供的解决方案" class="headerlink" title="JMM提供的解决方案"></a>JMM提供的解决方案</h3><p>​        除了JVM自身提供的对基本数据类型读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)保证程序执行的原子性。而工作内存与主内存同步延迟现象导致的可见性问题，可以使用synchronized关键字或者volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。</p><p>​        对于指令重排导致的可见性问题和有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化，关于volatile稍后会进一步分析。除了靠sychronized和volatile关键字来保证原子性、可见性以及有序性外，JMM内部还定义一套happens-before 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性。</p><h4 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h4><p>​        倘若在程序开发中，仅靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，在Java内存模型中，还提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：</p><ul><li><p>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</p></li><li><p>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</p></li><li><p>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</p></li><li><p>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见。</p></li><li><p>传递性 A先于B ，B先于C 那么A必然先于C。</p></li><li><p>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p></li><li><p>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p></li><li><p>对象终结规则 对象的构造函数执行，结束先于finalize()方法。</p></li></ul><h2 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h2><h3 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h3><ul><li><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）<br>对 volatile 变量的写指令<strong>后</strong>会加入写屏障<br>对 volatile 变量的读指令<strong>前</strong>会加入读屏障  </p></li><li><p>如何保证可见性  </p><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中  </p><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据  </p><img src="Java内存模型.assets/image-20210625163308349.png" alt="image-20210625163308349" style="zoom: 67%;" /></li><li><p>如何保证有序性  </p><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 。</p><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 。</p><img src="Java内存模型.assets/image-20210625163549037.png" alt="image-20210625163549037" style="zoom:67%;" /><p>​        还是那句话，不能解决指令交错：写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去。而有序性的保证也只是保证了本线程内相关代码不被重排序 。</p><img src="Java内存模型.assets/image-20210625163826216.png" alt="image-20210625163826216" style="zoom:67%;" /></li></ul><p>volatile是Java虚拟机提供的轻量级的同步机制volatile关键字有如下两个作用：</p><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><ul><li>它保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见。它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test32</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 易变</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!run) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">            run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test32</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 易变</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!run) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">            run = <span class="keyword">false</span>; <span class="comment">// 在主内存中读取，停止t</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><ul><li><p>禁止指令重排序优化。内存屏障，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。</p><p><img src="Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/image-20210625162628647.png" alt="image-20210625162628647"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VDemo02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> getstatic #<span class="number">2</span> &lt;com/coding/jmm/VDemo02.num&gt;#获得这个值</span><br><span class="line"><span class="number">3</span> iconst_1   </span><br><span class="line"><span class="number">4</span> iadd#+操作</span><br><span class="line"><span class="number">5</span> putstatic #<span class="number">2</span> &lt;com/coding/jmm/VDemo02.num&gt;#写回这个值</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">volatile 修饰的变量，可以禁用指令重排</span><br><span class="line">public class ConcurrencyTest &#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    volatile boolean ready = false;</span><br><span class="line">    @Actor</span><br><span class="line">    public void actor1(I_Result r) &#123;</span><br><span class="line">        if(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r.r1 = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Actor</span><br><span class="line">    public void actor2(I_Result r) &#123;</span><br><span class="line">        num = 2;</span><br><span class="line">        ready = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><ul><li>不能保证原子性，仅用在一个写线程，多个读线程的情况  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">比较线程安全时举的例子：两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解决指令交错</span><br><span class="line"><span class="comment">// 假设i的初始值为0</span></span><br><span class="line">getstatic i <span class="comment">// 线程2-获取静态变量i的值 线程内i=0</span></span><br><span class="line">getstatic i <span class="comment">// 线程1-获取静态变量i的值 线程内i=0</span></span><br><span class="line">iconst_1 <span class="comment">// 线程1-准备常量1</span></span><br><span class="line">iadd <span class="comment">// 线程1-自增 线程内i=1</span></span><br><span class="line">putstatic i <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span></span><br><span class="line">iconst_1 <span class="comment">// 线程2-准备常量1</span></span><br><span class="line">isub <span class="comment">// 线程2-自减 线程内i=-1</span></span><br><span class="line">putstatic i <span class="comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private static volatile Singleton INSTANCE = null;#volatile阻止指令重排序，INSTANCE = new Singleton();</span><br><span class="line">    public static Singleton getInstance() &#123;  #在构造器执行完后，再进行赋值操作，不会出现为空的情况</span><br><span class="line">        if (INSTANCE != null) &#123;</span><br><span class="line">            return INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        if(INSTANCE==null)&#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                // 也许有其它线程已经创建实例，所以再判断一次</span><br><span class="line">                if (INSTANCE == null) &#123;</span><br><span class="line">                    INSTANCE = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Hungry &#123;</span><br><span class="line">    // 单例模式核心思想，构造器私！</span><br><span class="line">    private Hungry()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private final static Hungry HUNGRY = new Hungry();</span><br><span class="line"></span><br><span class="line">    public static Hungry getInstance()&#123;</span><br><span class="line">        return HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="Java内存模型.assets/image-20210625171631785.png" alt="image-20210625171631785" style="zoom: 80%;" /><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class lazyDemo &#123;</span><br><span class="line">    private lazyDemo()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //双重检测锁+原子性操作【防止132指令重排】</span><br><span class="line">    private volatile static lazyDemo lazy;</span><br><span class="line">    //双重检测锁模式，懒汉单例式，DCL懒汉式</span><br><span class="line">    private static lazyDemo getInstance()&#123;</span><br><span class="line">        if (lazy==null)&#123;</span><br><span class="line">            synchronized (lazyDemo.class)&#123;</span><br><span class="line">                if (lazy==null)&#123;</span><br><span class="line">                    lazy= new lazyDemo();//不是一个原子操作</span><br><span class="line">                    /*</span><br><span class="line">                    1.分配内存空间</span><br><span class="line">                    2.执行构造方法，初始化对象</span><br><span class="line">                    3.把这个对象指向这个空间</span><br><span class="line">                    123</span><br><span class="line">                    132 A</span><br><span class="line">                        B 此时lazy还没完成构造</span><br><span class="line">                     */</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazy;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                lazy.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="Java内存模型.assets/image-20210625171730339.png" alt="image-20210625171730339" style="zoom: 80%;" /><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final class Singleton&#123;</span><br><span class="line">private Singleton()&#123;&#125;</span><br><span class="line">//问题一：属于懒汉式还是饿汉式    懒汉式</span><br><span class="line">private static class LazyHolder&#123;</span><br><span class="line">static final Singleton INSTANCE=new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">//问题二：在创建时是否有并发问题   JVM保证线程安全</span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">return LazyHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式破坏"><a href="#懒汉式破坏" class="headerlink" title="懒汉式破坏"></a>懒汉式破坏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public class lazyDemo &#123;</span><br><span class="line">    //④红绿灯</span><br><span class="line">    private static  boolean flag=false;</span><br><span class="line">    private lazyDemo()&#123;</span><br><span class="line">        //④判断标志位</span><br><span class="line">        //②加锁保护</span><br><span class="line">        synchronized (lazyDemo.class)&#123;</span><br><span class="line">            if(flag==false) &#123;</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //System.out.println(Thread.currentThread().getName()+&quot;ok&quot;);</span><br><span class="line">    //&#125;</span><br><span class="line">    //双重检测锁+原子性操作【防止132指令重排】</span><br><span class="line">    private volatile static lazyDemo lazy;</span><br><span class="line">    //双重检测锁模式，懒汉单例式，DCL懒汉式</span><br><span class="line">    private static lazyDemo getInstance()&#123;</span><br><span class="line">        if (lazy==null)&#123;</span><br><span class="line">            synchronized (lazyDemo.class)&#123;</span><br><span class="line">                if (lazy==null)&#123;</span><br><span class="line">                    lazy= new lazyDemo();//不是一个原子操作</span><br><span class="line">                    /*</span><br><span class="line">                    1.分配内存空间</span><br><span class="line">                    2.执行构造方法，初始化对象</span><br><span class="line">                    3.把这个对象指向这个空间</span><br><span class="line">                    123</span><br><span class="line">                    132 A</span><br><span class="line">                        B 此时lazy还没有完成构造</span><br><span class="line">                     */</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazy;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        /*for (int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                lazy.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line">        //反射破坏</span><br><span class="line">        //lazyDemo instance1 = lazyDemo.getInstance();</span><br><span class="line">        //⑤反射获取字段</span><br><span class="line">        Field flag = lazyDemo.class.getDeclaredField(&quot;flag&quot;);</span><br><span class="line">        flag.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        Constructor&lt;lazyDemo&gt; declaredConstructor = lazyDemo.class.getDeclaredConstructor(null);</span><br><span class="line">        /*</span><br><span class="line">        AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。</span><br><span class="line">        对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用 Field、Method 或 Constructor 对象来设置或获得字段、调用方法，或者创建和初始化类的新实例的时候，</span><br><span class="line">        会执行访问检查。</span><br><span class="line">        在反射对象中设置 accessible 标志允许具有足够特权的复杂应用程序（比如 Java Object Serialization 或其他持久性机制）以某种通常禁止使用的方式来操作对象。</span><br><span class="line">        setAccessible</span><br><span class="line">        public void setAccessible(boolean flag)</span><br><span class="line">                   throws SecurityException</span><br><span class="line">        将此对象的 accessible 标志设置为指示的布尔值。值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。</span><br><span class="line">        值为 false 则指示反射的对象应该实施 Java 语言访问检查。</span><br><span class="line">        实际上setAccessible是启用和禁用访问安全检查的开关</span><br><span class="line">         */</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        lazyDemo instance2 = declaredConstructor.newInstance();</span><br><span class="line">        //⑤</span><br><span class="line">        flag.set(instance2,false);</span><br><span class="line">        //③两个对象都用反射去创建，破坏单例</span><br><span class="line">        lazyDemo instance3 = declaredConstructor.newInstance();</span><br><span class="line">        //①反射可以破坏单例</span><br><span class="line">        //System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">        System.out.println(instance3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumSingle &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public EnumSingle getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        EnumSingle enumSingle2 = EnumSingle.INSTANCE;</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        // 期望的异常 throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);</span><br><span class="line">        // Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br><span class="line">        // java.lang.NoSuchMethodException: com.coding.single.EnumSingle.&lt;init&gt;()</span><br><span class="line">        declaredConstructor.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CAS乐观锁"><a href="#CAS乐观锁" class="headerlink" title="CAS乐观锁"></a>CAS乐观锁</h1><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS：Compare and Swap，即比较交换；<br>jdk1.5增加了并发包java.util.concurrent.*，其下面的类使用CAS算法实现了区别于synchronized同步锁的一种乐观锁。jdk1.5之前java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是悲观锁。</p><h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><img src="Java内存模型.assets/image-20210625175153050.png" alt="image-20210625175153050" style="zoom: 80%;" /><ul><li><p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。  </p></li><li><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。  </p></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。<br><strong>注意</strong></p><p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果 。</p><h2 id="CAS算法理解"><a href="#CAS算法理解" class="headerlink" title="CAS算法理解"></a>CAS算法理解</h2><h3 id="与锁相比"><a href="#与锁相比" class="headerlink" title="与锁相比"></a>与锁相比</h3><p>​        使用比较交换会使程序看起来更加复杂一些。但由于其非阻塞性，它对死锁问题天生免疫，并且，线程间的相互影响也远远比基于锁的方式要小。使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销；因此，它要比基于锁的方式拥有更优越的性能；</p><p>​        CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作；当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败；失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作；基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理；</p><h3 id="无锁的好处"><a href="#无锁的好处" class="headerlink" title="无锁的好处"></a>无锁的好处</h3><p>​         在高并发情况下，它比有锁的程序拥有更好的性能；它天生就是死锁免疫的。</p><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>​        结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p><p>​        CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</p><h3 id="CAS算法的过程"><a href="#CAS算法的过程" class="headerlink" title="CAS算法的过程"></a>CAS算法的过程</h3><p>它包含三个参数CAS(V,E,N)：<strong>V表示更新的变量，E表示预期值，N表示新值</strong>；　　</p><ul><li><p>线程访问时，先会将主内存中的数据同步到线程的工作内存当中。</p></li><li><p>假设线程A和线程B都有对数据进行更改，那么假如线程A先获取到执行权限。</p></li><li><p>线程A先会对比工作内存当中的数据和主内存当中的数据是否一致，如果一致（V==E）则进行更新，不一致则刷新数据，重新循环判断。</p></li><li><p>这时更新完毕后，线程B也要进行数据更新，主内存数据和工作内存数据做对比，如果一致则进行更新，不一致则将主内存数据重新更新到工作内存，然后再次对比两个内存中的数据直到一致为止。</p><p><img src="Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/image-20210625173234718.png" alt="image-20210625173234718"></p></li></ul><h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><ul><li><p>循环耗时</p></li><li><p>一次性只能保证一个共享变量的原子性</p></li><li><p>ABA问题；<br>　问题：如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它任然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段时间曾经被改成B，然后有改回A，那CAS操作就会误任务它从来没有被修改过。</p></li></ul><img src="Java内存模型.assets/image-20210625173812895.png" alt="image-20210625173812895" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class CASDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(5);</span><br><span class="line">        // compareAndSet  简称 CAS 比较并交换！</span><br><span class="line">        // compareAndSet(int expect, int update)  我期望原来的值是什么，如果是，就更新</span><br><span class="line">        //  a</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5, 2020)+&quot;=&gt;&quot;+atomicInteger.get());</span><br><span class="line">        // c  偷偷的改动</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021)+&quot;=&gt;&quot;+atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2021, 5)+&quot;=&gt;&quot;+atomicInteger.get());</span><br><span class="line">        //  b c偷偷修改过要告诉我</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5, 1024)+&quot;=&gt;&quot;+atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正对这种情况，java并发包提供了一个带有标记的原子应用类 AtomicStampedRefernce，它可以通过变量值的版本来保证CAS的正确性；AtomicStampedReference原子类是一个<strong>带有时间戳的对象引用</strong>，在每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境，测试demo如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class CASDemo2 &#123;</span><br><span class="line">    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100,1);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            //1 、 获得版本号</span><br><span class="line">            int stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(&quot;T1 stamp 01=&gt;&quot;+stamp);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(100,101,</span><br><span class="line">                    atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);</span><br><span class="line">            System.out.println(&quot;T1 stamp 02=&gt;&quot;+atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(101,100,</span><br><span class="line">                    atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);</span><br><span class="line">            System.out.println(&quot;T1 stamp 03=&gt;&quot;+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,&quot;T1&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            // GIT  看到数据被动过了！</span><br><span class="line">            //1 、 获得版本号</span><br><span class="line">            int stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(&quot;T1 stamp 01=&gt;&quot;+stamp);</span><br><span class="line">            // 保证上面的线程先执行完毕！</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean b = atomicStampedReference.compareAndSet(100, 2019,</span><br><span class="line">                    stamp, stamp + 1);</span><br><span class="line">            System.out.println(&quot;T2 是否修改成功：&quot;+b);</span><br><span class="line">            System.out.println(&quot;T2 最新的stamp：&quot;+stamp);</span><br><span class="line">            System.out.println(&quot;T2 当前的最新值：&quot;+atomicStampedReference.getReference());</span><br><span class="line">        &#125;,&quot;T2&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong>：通过一个键值对Pair存储数据和时间戳，在更新时对数据和时间戳进行比较，只有两者都符合预期才会调用Unsafe的compareAndSwapObject方法执行数值和时间戳替换，也就避免了ABA的问题</p><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><h3 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h3><ul><li><p>AtomicBoolean：原子更新布尔类型</p></li><li><p>AtomicInteger：原子更新整型</p></li><li><p>AtomicLong：原子更新长整型</p></li></ul><p>​        这3个类的实现原理和使用方式几乎是一样的，这里我们以AtomicInteger为例进行分析，AtomicInteger主要是针对int类型的数据执行原子操作，它提供了原子自增方法、原子自减方法以及原子赋值方法等，鉴于AtomicInteger的源码不多，我们直接看源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 6214790243416807050L;</span><br><span class="line"></span><br><span class="line">    // 获取指针类Unsafe</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    //下述变量value在AtomicInteger实例对象内的内存偏移量</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           //通过unsafe类的objectFieldOffset()方法，获取value变量在对象内存中的偏移</span><br><span class="line">           //通过该偏移量valueOffset，unsafe类的内部方法可以获取到变量value对其进行取值或赋值操作</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   //当前AtomicInteger封装的int变量value</span><br><span class="line">    private volatile int value;</span><br><span class="line"></span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    public AtomicInteger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   //获取当前最新值，</span><br><span class="line">    public final int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置当前值，具备volatile效果，方法用final修饰是为了更进一步的保证线程安全。</span><br><span class="line">    public final void set(int newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    //最终会设置成newValue，使用该方法后可能导致其他线程在之后的一小段时间内可以获取到旧值，有点类似于延迟加载</span><br><span class="line">    public final void lazySet(int newValue) &#123;</span><br><span class="line">        unsafe.putOrderedInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">   //设置新值并获取旧值，底层调用的是CAS操作即unsafe.compareAndSwapInt()方法</span><br><span class="line">    public final int getAndSet(int newValue) &#123;</span><br><span class="line">        return unsafe.getAndSetInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">   //如果当前值为expect，则设置为update(当前值指的是value变量)</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值加1返回旧值，底层CAS操作</span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值减1，返回旧值，底层CAS操作</span><br><span class="line">    public final int getAndDecrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1);</span><br><span class="line">    &#125;</span><br><span class="line">   //当前值增加delta，返回旧值，底层CAS操作</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值加1，返回新值，底层CAS操作</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //当前值减1，返回新值，底层CAS操作</span><br><span class="line">    public final int decrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;</span><br><span class="line">    &#125;</span><br><span class="line">   //当前值增加delta，返回新值，底层CAS操作</span><br><span class="line">    public final int addAndGet(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line">   //省略一些不常用的方法....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h3><ul><li><p>AtomicReference</p></li><li><p>AtomicMarkableReference</p></li><li><p>AtomicStampedReference  </p><p>原子更新引用类型可以同时更新引用类型，这里主要分析一下AtomicReference原子类，即原子更新引用类型</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //内部变量value，Unsafe类通过valueOffset内存偏移量即可获取该变量</span><br><span class="line">    private volatile V value;</span><br><span class="line"></span><br><span class="line">//CAS方法，间接调用unsafe.compareAndSwapObject(),它是一个</span><br><span class="line">//实现了CAS操作的native方法</span><br><span class="line">public final boolean compareAndSet(V expect, V update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapObject(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置并获取旧值</span><br><span class="line">public final V getAndSet(V newValue) &#123;</span><br><span class="line">        return (V)unsafe.getAndSetObject(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    //省略其他代码......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Unsafe类中的getAndSetObject方法，实际调用还是CAS操作</span><br><span class="line">public final Object getAndSetObject(Object o, long offset, Object newValue) &#123;</span><br><span class="line">      Object v;</span><br><span class="line">      do &#123;</span><br><span class="line">          v = getObjectVolatile(o, offset);</span><br><span class="line">      &#125; while (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">      return v;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h3><ul><li><p>AtomicIntegerArray：原子更新整数数组里的元素</p></li><li><p>AtomicLongArray：原子更新长整数数组里的元素</p></li><li><p>AtomicReferenceArray：原子更新引用类型数组里的元素</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerArray implements java.io.Serializable &#123;</span><br><span class="line">    //获取unsafe类的实例对象</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    //获取数组的第一个元素内存起始地址</span><br><span class="line">    private static final int base = unsafe.arrayBaseOffset(int[].class);</span><br><span class="line"></span><br><span class="line">    private static final int shift;</span><br><span class="line">    //内部数组</span><br><span class="line">    private final int[] array;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //获取数组中一个元素占据的内存空间</span><br><span class="line">        int scale = unsafe.arrayIndexScale(int[].class);</span><br><span class="line">        //判断是否为2的次幂，一般为2的次幂否则抛异常</span><br><span class="line">        if ((scale &amp; (scale - 1)) != 0)</span><br><span class="line">            throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">        //</span><br><span class="line">        shift = 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long checkedByteOffset(int i) &#123;</span><br><span class="line">        if (i &lt; 0 || i &gt;= array.length)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;index &quot; + i);</span><br><span class="line"></span><br><span class="line">        return byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line">    //计算数组中每个元素的的内存地址</span><br><span class="line">    private static long byteOffset(int i) &#123;</span><br><span class="line">        return ((long) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line">    //省略其他代码......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子更新属性"><a href="#原子更新属性" class="headerlink" title="原子更新属性"></a>原子更新属性</h3><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li></ul><p>请注意原子更新器的使用存在比较苛刻的条件如下：</p><ul><li>操作的字段不能是static类型。</li></ul><ul><li>操作的字段不能是final类型的，因为final根本没法修改。</li></ul><ul><li>字段必须是volatile修饰的，也就是数据本身是读一致的。</li></ul><ul><li>属性必须对当前的Updater所在的区域是可见的，如果不是当前类内部进行原子更新器操作不能使用private，protected子类操作父类时修饰符必须是protect权限及以上，如果在同一个package下则必须是default权限及以上，也就是说无论何时都应该保证操作类与被操作类间的可见性。</li></ul><h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><p>在 JDK 8 中又新增了 LongAdder 这个类，这是一个针对 Long 类型的操作工具类。LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 累加单元数组, 懒惰初始化</span><br><span class="line">transient volatile Cell[] cells;</span><br><span class="line">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="line">transient volatile long base;</span><br><span class="line">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span><br><span class="line">transient volatile int cellsBusy;</span><br></pre></td></tr></table></figure><h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><p>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。</p><img src="Java内存模型.assets/image-20210625182937651.png" alt="image-20210625182937651" style="zoom:67%;" /><img src="Java内存模型.assets/image-20210625183127978.png" alt="image-20210625183127978" style="zoom:67%;" /><img src="Java内存模型.assets/image-20210625183138735.png" alt="image-20210625183138735" style="zoom:67%;" /><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这种方式确实也是可以提升效率的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SpinLock &#123;</span><br><span class="line">  private AtomicReference&lt;Thread&gt; sign =new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public void lock()&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    while(!sign .compareAndSet(null, current))&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void unlock ()&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    sign .compareAndSet(current, null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       使用CAS原子操作作为底层实现，lock()方法将要更新的值设置为当前线程，并将预期值设置为null。unlock()函数将要更新的值设置为null，并预期值设置为当前线程。然后我们通过lock()和unlock来控制自旋锁的开启与关闭，注意这是一种非公平锁。事实上AtomicInteger(或者AtomicLong)原子类内部的CAS操作也是通过不断的自循环(while循环)实现，不过这种循环的结束条件是线程成功更新对于的值，但也是自旋锁的一种。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;Java内存区域与Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存区域与Jav</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/07/01/java%E9%9B%86%E5%90%88md/"/>
    <id>http://example.com/2021/07/01/java%E9%9B%86%E5%90%88md/</id>
    <published>2021-07-01T10:42:11.738Z</published>
    <updated>2021-07-01T02:49:09.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><img src="java集合md.assets/image-20210630191902744.png" alt="image-20210630191902744" style="zoom: 80%;" /><p>​        实线边框的是实现类，比如ArrayList，LinkedList，HashMap等，折线边框的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，而点线边框的是接口，比如Collection，Iterator，List等。</p><h2 id="Iterable接口"><a href="#Iterable接口" class="headerlink" title="Iterable接口"></a>Iterable接口</h2><p>​        Iterable接口 (java.lang.Iterable) 是Java集合的顶级接口之一，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an iterator over elements of type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an Iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        可见，Iterable接口中包含iterator()方法，用来返回一个Iterator类型的对象，或者说返回一个实现了Iterator接口的对象。实现了Iterable接口的类可以拥有增强的for循环，即只要实现了Iterable接口的类，就可以使用Iterator迭代器了。</p><h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the iteration has more elements.</span></span><br><span class="line"><span class="comment">     * (In other words, returns &#123;<span class="doctag">@code</span> true&#125; if &#123;<span class="doctag">@link</span> #next&#125; would</span></span><br><span class="line"><span class="comment">     * return an element rather than throwing an exception.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the iteration has more elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        Iterator对象被称为迭代器，主要用于遍历Collection集合中的元素，必须依附于Collection对象，采用快速失败机制（fail-fast），避免由于共享资源而引发的潜在问题。</p><p>​        方法一：用 CopyOnWriteArrayList，ConcurrentHashMap 替换 ArrayList， HashMap，它们的功能和名字一样，在写入时会创建一个 copy，然后在这个 copy 版本上进行修改操作，这样就不会影响原来的迭代。不过坏处就是浪费内存。</p><p>​        方法二：使用 Collections.synchronizedList 加 同步锁，不过这样有点粗暴。</p><p><strong>Iterator和Iterable的区别：</strong><br>1). Iterator是迭代器接口，而Iterable是为了只要实现该接口就可以使用foreach进行迭代。</p><p>2). Iterable中封装了Iterator接口，只要实现了Iterable接口的类，就可以使用Iterator迭代器了。</p><p>3). 集合Collection、List、Set都是Iterable的实现类，所以他们及其他们的子类都可以使用foreach进行迭代。</p><p>4). Iterator中核心的方法next()、hasnext()、remove()都是依赖当前位置，如果这些集合直接实现Iterator，则必须包括当前迭代位置的指针。当集合在方法间进行传递的时候，由于当前位置不可知，所以next()之后的值，也不可知。而实现Iterable则不然，每次调用都返回一个<a href="https://www.baidu.com/s?wd=%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">从头开始</a>的迭代器，各个迭代器之间互不影响。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li><p>集合，或者叫容器，是一个包含多个元素的对象；</p></li><li><p>集合可以对数据进行存储，检索，操作；</p></li><li><p>它们可以把许多个体组织成一个整体：</p><ul><li>比如一副扑克牌（许多牌组成的集合）;</li><li>比如一个电话本（许多姓名和号码的映射）。</li></ul></li><li><p>接口：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</p></li><li><p>实现类：集合接口的具体实现，是重用性很高的数据结构。</p></li><li><p>算法：用来根据需要对实体类中的对象进行计算，比如查找，排序。</p><p>​    同一种算法可以对不同的集合实现类进行计算，这是利用了“多态”。</p><p>​    重用性很高。</p></li></ul><p><img src="java%E9%9B%86%E5%90%88md.assets/image-20210630203955436.png" alt="image-20210630203955436"></p><p>==<strong>Java 的集合主要按两种接口分类：Collection, Map</strong>==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//add(Object e):将元素添加到集合coll中</span></span><br><span class="line">        coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        coll.add(<span class="number">123</span>);<span class="comment">//自动装箱</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="comment">//size()：获取添加元素的个数</span></span><br><span class="line">        System.out.println(coll.size());</span><br><span class="line">        <span class="comment">//addAll():将coll1集合中的元素添加到当前集合中</span></span><br><span class="line">        Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll1.add(<span class="number">456</span>);</span><br><span class="line">        coll1.add(<span class="string">&quot;vv&quot;</span>);</span><br><span class="line">        coll.addAll(coll1);</span><br><span class="line">        System.out.println(coll.size());</span><br><span class="line">        System.out.println(coll.toString());</span><br><span class="line">        <span class="comment">//clear():清空集合元素</span></span><br><span class="line">        coll.clear();</span><br><span class="line">        <span class="comment">//isEmpty():判断当前集合是否为空,是否有元素</span></span><br><span class="line">        System.out.println(coll.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;xiaomi&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//Person P=new Person(&quot;JEER&quot;,20);</span></span><br><span class="line">        <span class="comment">//coll.add(P);</span></span><br><span class="line">        <span class="comment">//1. contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line">        <span class="comment">//我们在判断时会调用obj对象所在类的equals()。</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;j&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        <span class="keyword">boolean</span> contains = coll.contains(<span class="number">123</span>);</span><br><span class="line">        System.out.println(contains);</span><br><span class="line">        System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;xiaomi&quot;</span>)));<span class="comment">//equals()</span></span><br><span class="line">        <span class="comment">//System.out.println(coll.contains(P));true</span></span><br><span class="line">        System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">&quot;j&quot;</span>, <span class="number">20</span>)));<span class="comment">//比的是equals()方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。</span></span><br><span class="line">        Collection coll2 = Arrays.asList(<span class="number">123</span>, <span class="number">4567</span>);</span><br><span class="line">        System.out.println(coll.containsAll(coll2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.remove(Object obj)从当前集合中移除obj元素</span></span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">        coll.remove(<span class="number">123</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">        coll.remove(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        System.out.println(coll);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.removeAll(Collection coll1)：从当前集合中移除coll11中的所有元素</span></span><br><span class="line">        Collection coll1 = Arrays.asList(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        coll.removeAll(coll1);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//5.retainAll(Collection coll1):交集:获取当前集合和coll1集合的交集；并返回给当前集合</span></span><br><span class="line">        <span class="comment">//Collection coll1= Arrays.asList(123,456,789);</span></span><br><span class="line">        <span class="comment">//coll.retainAll(coll1);</span></span><br><span class="line">        <span class="comment">//System.out.println(coll);</span></span><br><span class="line">        <span class="comment">//6.equals(Object obj):记住ArrayList是有序的</span></span><br><span class="line">        <span class="comment">//equals(Object obj):要想返回true,需要当前集合和形参集合的元素都相同。</span></span><br><span class="line">        Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll1.add(<span class="number">123</span>);</span><br><span class="line">        coll1.add(<span class="number">456</span>);</span><br><span class="line">        coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        coll1.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll1.add(<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(coll.equals(coll1));</span><br><span class="line">        <span class="comment">//7.hashcode()返回当前对象的hash值</span></span><br><span class="line">        System.out.println(coll1.hashCode());</span><br><span class="line">        <span class="comment">//8.toArray()集合---&gt;数组</span></span><br><span class="line">        Object[] obj = coll.toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.length; i++) &#123;</span><br><span class="line">            System.out.println(obj[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拓展：数组变为集合:调用Arrays的静态方法asList()</span></span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;);</span><br><span class="line">        System.out.println(strings);</span><br><span class="line">        <span class="comment">//注意</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ints = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        System.out.println(ints);<span class="comment">//[[I@78e03bb5]</span></span><br><span class="line">        List arr1 = Arrays.asList(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(arr1);<span class="comment">// 123 456</span></span><br><span class="line">        List ints1 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        System.out.println(ints1);<span class="comment">// 123 456</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//iterator():返回Iterator接口的实例，用于遍历集合的元素，放在iterator.java中测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p>​        List 是一个元素有序的、可以重复、可以为 null 的集合,常使用的几种 List 实现类是 ArrayList，LinkedList 和 Vector。在各种 List 中，最好的做法是以 ArrayList 作为默认选择。 当插入、删除频繁时，使用 LinkedList。List 的数据结构就是一个序列，存储内容时直接在内存中开辟一块连续的空间，然后将空间地址与索引对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span>:在index位置插入ele元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection eles)</span>:从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>:获取指定index位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span>:返回obj在集合中首次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object obj)</span>:返回obj在当前集合中末次出现的位置</span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>:移除指定index位置的元素，并返回此元素</span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span>:设置指定index位置的元素为ele</span></span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span>:返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line"><span class="function">总结：常用方法</span></span><br><span class="line"><span class="function">    增：<span class="title">add</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    删：<span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> / <span class="title">remove</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    改：<span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span></span><br><span class="line"><span class="function">    查：<span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    插：<span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span></span><br><span class="line"><span class="function">    长度：<span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    遍历：① Iterator迭代器方式</span></span><br><span class="line"><span class="function">     ② 增强<span class="keyword">for</span>循环</span></span><br><span class="line"><span class="function">     ③ 普通的循环</span></span><br><span class="line"><span class="function">     */</span></span><br><span class="line"><span class="function"><span class="comment">//下面是一个简单的 List 中的元素交换方法：</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    E tmp = a.get(i);</span><br><span class="line">    a.set(i, a.get(j));</span><br><span class="line">    a.set(j, tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>List 与 Array 区别:</strong></p><img src="java集合md.assets/image-20210630211454231.png" alt="image-20210630211454231" style="zoom: 80%;" /><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><img src="https://images2017.cnblogs.com/blog/999804/201710/999804-20171018145151287-1709338098.png" alt="img"></p><p>ArrayList 是 Java 集合框架中 List接口 的一个实现类。作为List接口的主要实现类；==<strong>线程不安全的，效率高</strong>==；底层使用==<strong>Object[] elementData存储</strong>==。可以说 ArrayList 是我们使用最多的 List 集合，它有以下特点：</p><ul><li><p>容量不固定，想放多少放多少（当然有最大阈值，但一般达不到）</p></li><li><p>有序的（元素输出顺序与输入顺序一致）</p></li><li><p>元素可以为 null</p></li><li><p>效率高</p><ol><li>size(), isEmpty(), get(), set() iterator(), ListIterator() 方法的时间复杂度都是 O(1)</li><li>  add() 添加操作的时间复杂度平均为 O(n)</li><li>  其他所有操作的时间复杂度几乎都是 O(n)</li><li>  占用空间更小</li><li>  对比 LinkedList，不用占用额外空间维护链表结构<blockquote><h4 id="1-底层数据结构，数组："><a href="#1-底层数据结构，数组：" class="headerlink" title="1.底层数据结构，数组："></a>1.底层数据结构，数组：</h4></blockquote></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData</span><br><span class="line">*   <span class="number">2.</span> ArrayList的源码分析：</span><br><span class="line"> *   <span class="number">2.1</span> jdk <span class="number">7</span>情况下</span><br><span class="line"> *      ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line"> *      list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line"> *      ...</span><br><span class="line"> *      list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line"> *      默认情况下，扩容为原来的容量的<span class="number">1.5</span>倍，同时需要将原有数组中的数据复制到新的数组中。</span><br><span class="line"> *      结论：建议开发中使用带参的构造器：ArrayList list = <span class="keyword">new</span> ArrayList(<span class="keyword">int</span> capacity)</span><br><span class="line"> *   <span class="number">2.2</span> jdk <span class="number">8</span>中ArrayList的变化：</span><br><span class="line"> *      ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;.并没有创建长度为10的数组</span></span><br><span class="line"> *      list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0],后续的添加和扩容操作与jdk 7 无异。</span></span><br><span class="line"> *   <span class="number">2.3</span> 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟      了数组的创建，节省内存。</span><br></pre></td></tr></table></figure><blockquote><h4 id="类中的属性"><a href="#类中的属性" class="headerlink" title="类中的属性"></a>类中的属性</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="comment">// 缺省容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 空对象数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 缺省空对象数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 元素数组</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;<span class="comment">//transient 说明这个数组无法序列化。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。</span></span><br><span class="line"><span class="comment">一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式。</span></span><br><span class="line"><span class="comment">在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。</span></span><br><span class="line"><span class="comment">elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 实际元素大小，默认为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 最大数组容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）无参构造方法</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty list with an initial capacity of ten.　　这里就说明了默认会给10的大小，所以说一开始arrayList的容量是10.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">　　　　<span class="comment">//ArrayList中储存数据的其实就是一个数组，这个数组就是elementData，在123行定义的 private transient Object[] elementData;</span></span><br><span class="line">　　 <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;　　</span><br><span class="line">        <span class="keyword">super</span>();        <span class="comment">//调用父类中的无参构造方法，父类中的是个空的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//EMPTY_ELEMENTDATA：是个空的Object[]， 将elementData初始化，elementData也是个Object[]类型。空的Object[]会给默认大小10，等会解释什么时候赋值的。</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2</span>）有参构造函数一根据指定容量，创建个对象数组</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">//父类中空的构造方法</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)    <span class="comment">//判断如果自定义大小的容量小于0，则报下面这个非法数据异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity]; <span class="comment">//将自定义的容量大小当成初始化elementData的大小</span></span><br><span class="line">    &#125;   </span><br><span class="line"><span class="number">3</span>)有参构造方法三(不常用)直接创建和指定集合一样内容的 ArrayList</span><br><span class="line"><span class="comment">//这个构造方法不常用，举个例子就能明白什么意思</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Strudent exends Person</span></span><br><span class="line"><span class="comment">         ArrayList&lt;Person&gt;、 Person这里就是泛型</span></span><br><span class="line"><span class="comment">        我还有一个Collection&lt;Student&gt;、由于这个Student继承了Person，那么根据这个构造方法，我就可以把这个Collection&lt;Student&gt;转换为ArrayList&lt;Sudent&gt;这就是这个构造方法的作用 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();    <span class="comment">//转换为数组</span></span><br><span class="line">        size = elementData.length;   <span class="comment">//数组中的数据个数</span></span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class) <span class="comment">//每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类型，那么久需要使用ArrayList中的方法去改造一下。</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：arrayList的构造方法就做一件事情，就是初始化一下储存数据的容器，其实本质上就是一个数组，在其中就叫elementData。ArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。 </p><blockquote><h3 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a>add()方法</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E)</span>；默认直接在末尾添加元素</span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">     * Appends the specified element to the end of this list.添加一个特定的元素到list的末尾。</span></span></span><br><span class="line"><span class="comment"><span class="function">     *</span></span></span><br><span class="line"><span class="comment"><span class="function">     * @param e element to be appended to this list</span></span></span><br><span class="line"><span class="comment"><span class="function">     * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span></span></span><br><span class="line"><span class="comment"><span class="function">     */</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//确定内部容量是否够了，size是数组中数据的个数，因为要添加一个元素，所以size+1，先判断size+1的这个个数数组能否放得下，就在这个方法中去判断是否数组.length是否够用了。</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//在数据中正确的位置上放上元素e，并且size++</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ensureCapacityInternal(xxx);　确定内部容量的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123; <span class="comment">//看，判断初始化的elementData是不是空的数组，也就是没有长度</span></span><br><span class="line">    <span class="comment">//因为如果是空的话，minCapacity=size+1；其实就是等于1，空的数组没有长度就存放不了，所以就将minCapacity变成10，也就是默认大小，但是这里，还没有真正的初始化这个elementData的大小。</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//确认实际的容量，上面只是将minCapacity=10，这个方法就是真正的判断elementData是否够用</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ensureExplicitCapacity(xxx)；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line"><span class="comment">//minCapacity如果大于了实际elementData的长度，那么就说明elementData数组的长度不够用，不够用那么就要增加elementData的length。这里有的同学就会模糊minCapacity到底是什么呢，这里给你们分析一下</span></span><br><span class="line"><span class="comment">/*第一种情况：由于elementData初始化时是空的数组，那么第一次add的时候，minCapacity=size+1；也就minCapacity=1，在上一个方法(确定内部容量ensureCapacityInternal)就会判断出是空的数组，就会给将minCapacity=10，到这一步为止，还没有改变elementData的大小。</span></span><br><span class="line"><span class="comment">　第二种情况：elementData不是空的数组了，那么在add的时候，minCapacity=size+1；也就是minCapacity代表着elementData中增加之后的实际数据个数，拿着它判断elementData的length是否够用，如果length不够用，那么肯定要扩大容量，不然增加的这个元素就会溢出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//arrayList能自动扩展大小的关键方法就在这里了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//grow(xxx); arrayList核心的方法，扩容，把现有数据拷贝到新的数组里面去。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;  <span class="comment">//将扩充前的elementData大小给oldCapacity</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//newCapacity就是1.5倍的oldCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)<span class="comment">//这句话就是适应于elementData就空数组的时候，length=0，那么oldCapacity=0，newCapacity=0，所以这个判断成立，在这里就是真正的初始化elementData的大小了，就是为10.前面的工作都是准备工作。</span></span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)<span class="comment">//如果newCapacity超过了最大的容量限制，就调用hugeCapacity，也就是将能给的最大值给newCapacity</span></span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">//新的容量大小已经确定好了，就copy数组，改变容量大小咯。</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//hugeCapacity();  </span></span><br><span class="line"><span class="comment">//这个就是上面用到的方法，很简单，就是用来赋最大值。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line"><span class="comment">//如果minCapacity都大于MAX_ARRAY_SIZE，那么就Integer.MAX_VALUE返回，反之将MAX_ARRAY_SIZE返回。因为maxCapacity是三倍的minCapacity，可能扩充的太大了，就用minCapacity来判断了。</span></span><br><span class="line"><span class="comment">//Integer.MAX_VALUE:2147483647   MAX_ARRAY_SIZE：2147483639  也就是说最大也就能给到第一个数值。还是超过了这个限制，就要溢出了。相当于arraylist给了两层防护。</span></span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add主要的执行逻辑如下：<br>1）确保数组已使用长度（size）加1之后足够存下下一个数据。<br>2）确保添加的元素有地方存储，当第一次添加元素的时候this.size+1 的值是1，所以第一次添加的时候会将当前elementData数组的长度变为10，也就是默认大小，但是在这里，还没有真正的初始化这个elementData的大小。</p><p>3）将修改次数（modCount）自增1，判断是否需要扩充数组长度,判断条件就是用当前所需的数组最小长度与数组的长度对比，如果大于0，则增长数组长度。</p><p>4）如果当前的数组已使用空间（size）加1之后 大于数组长度，则增大数组容量，扩大为原来的1.5倍。</p><p>5）确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。<br>6）返回添加成功布尔值。</p><p><strong>举例说明一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">6</span>);</span><br><span class="line">　　lists.add(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>初始化lists大小为0，调用的ArrayList()型构造函数，那么在调用lists.add(8)方法时，会经过怎样的步骤呢？</p><img src="https://images2017.cnblogs.com/blog/999804/201710/999804-20171018161219756-1707907201.png" alt="img" style="zoom:67%;" /><p>​        add方法之前开始elementData = {}；调用add方法时会继续调用，直至grow，最后elementData的大小变为10，之后再返回到add函数，把8放在elementData[0]中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>)<span class="comment">//在指定位置添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的容量进行调整</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//整体后移一位，效率不太好啊</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例说明二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">6</span>);</span><br><span class="line">　　lists.add(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>说明：调用的ArrayList(int)型构造函数，那么elementData被初始化为大小为6的Object数组，在调用add(8)方法时，具体的步骤如下:</p><img src="https://images2017.cnblogs.com/blog/999804/201710/999804-20171018161329396-659259302.png" alt="img" style="zoom: 80%;" /><p>说明：我们可以知道，在调用add方法之前，elementData的大小已经为6，之后再进行传递，不会进行扩容处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>)<span class="comment">//添加一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把该集合转为对象数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">//增加容量</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">//挨个向后迁移</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">//新数组有元素，就返回 true</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)<span class="comment">//在指定位置，添加一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="comment">//原来的数组挨个向后迁移</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//把新的集合数组 添加到指定位置</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3></blockquote><p>1）remove(int)：通过删除指定位置上的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);<span class="comment">//检查index的合理性</span></span><br><span class="line"></span><br><span class="line">        modCount++;<span class="comment">//这个作用很多，比如用来检测快速失败的一种标志。</span></span><br><span class="line">        E oldValue = elementData(index);<span class="comment">//通过索引直接找到该元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//计算要移动的位数。</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//这个方法也已经解释过了，就是用来移动元素的。</span></span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line"><span class="comment">//将--size上的位置赋值为null，让gc(垃圾回收机制)更快的回收它。</span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"><span class="comment">//返回删除的元素。</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2）remove(Object)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);<span class="comment">//检查index的合理性</span></span><br><span class="line"></span><br><span class="line">        modCount++;<span class="comment">//这个作用很多，比如用来检测快速失败的一种标志。</span></span><br><span class="line">        E oldValue = elementData(index);<span class="comment">//通过索引直接找到该元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//计算要移动的位数。</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//这个方法也已经解释过了，就是用来移动元素的。</span></span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line"><span class="comment">//将--size上的位置赋值为null，让gc(垃圾回收机制)更快的回收它。</span></span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"><span class="comment">//返回删除的元素。</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3）clear()：将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉，所以叫cleart)：这个方法可以看出来，arrayList是可以存放null值得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4）removeAll(collection c)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);<span class="comment">//批量删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）batchRemove(xx,xx)：用于两个方法，一个removeAll()：它只清楚指定集合中的元素，retainAll()用来测试两个集合是否有交集。　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法，用于两处地方，如果complement为false，则用于removeAll如果为true，则给retainAll()用，retainAll（）是用来检测两个集合是否有交集的。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData; <span class="comment">//将原集合，记名为A</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;   <span class="comment">//r用来控制循环，w是记录有多少个交集</span></span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line"><span class="comment">//参数中的集合C一次检测集合A中的元素是否有，</span></span><br><span class="line">                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line"><span class="comment">//有的话，就给集合A</span></span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">            <span class="comment">// even if c.contains() throws.</span></span><br><span class="line"><span class="comment">//如果contains方法使用过程报异常</span></span><br><span class="line">            <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line"><span class="comment">//将剩下的元素都赋值给集合A，</span></span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line"><span class="comment">//这里有两个用途，在removeAll()时，w一直为0，就直接跟clear一样，全是为null。</span></span><br><span class="line"><span class="comment">//retainAll()：没有一个交集返回true，有交集但不全交也返回true，而两个集合相等的时候，返回false，所以不能根据返回值来确认两个集合是否有交集，而是通过原集合的大小是否发生改变来判断，如果原集合中还有元素，则代表有交集，而元集合没有元素了，说明两个集合没有交集。</span></span><br><span class="line">                <span class="comment">// clear to let GC do its work</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                size = w;</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>remove函数用户移除指定下标的元素，此时会把指定下标到数组末尾的元素向前移动一个单位，并且会把数组最后一个元素设置为null。</p><blockquote><h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明：设定指定下标索引的元素值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检验索引是否合法</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">// 旧值</span></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        <span class="comment">// 赋新值</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf()方法"></a>indexOf()方法</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从首开始查找数组里面是否存在指定元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123; <span class="comment">// 查找的元素为空</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) <span class="comment">// 遍历数组，找到第一个为空的元素，返回下标</span></span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 查找的元素不为空</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) <span class="comment">// 遍历数组，找到第一个和指定元素相等的元素，返回下标</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 没有找到，返回空</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：从头开始查找与指定元素相等的元素，注意，是可以查找null元素的，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找。</p><blockquote><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检验索引是否合法</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于0），值得注意的是，在get函数中存在element函数，element函数用于返回具体的元素，具体函数如下：</p><p>==<strong>关于ArrayList的源码，给出几点比较重要的总结：</strong>==</p><ol><li>注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。</li><li>注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。</li><li>ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。</li></ol><p>首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;  </span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;  </span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)  </span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]  </span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  </span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,  </span><br><span class="line">                     Math.min(original.length, newLength));  </span><br><span class="line">    <span class="keyword">return</span> copy;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。</p><p>下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。 </p><ol start="4"><li>注意ArrayList的两个转化为静态数组的toArray方法。</li></ol><p>第一个，Object[] toArray()方法。该方法有可能会抛出java.lang.ClassCastException异常，如果直接用向下转型的方法，将整个ArrayList集合转变为指定类型的Array数组，便会抛出该异常，而如果转化为Array数组时不向下转型，而是将每个元素向下转型，则不会抛出该异常，显然对数组中的元素一个个进行向下转型，效率不高，且不太方便。</p><p>第二个， T[] toArray(T[] a)方法。该方法可以直接将ArrayList转换得到的Array进行整体向下转型（转型其实是在该方法的源码中实现的），且从该方法的源码中可以看出，参数a的大小不足时，内部会调用Arrays.copyOf方法，该方法内部创建一个新的数组返回，因此对该方法的常用形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer[] vectorToArray2(ArrayList&lt;Integer&gt; v) &#123;    </span><br><span class="line">    Integer[] newText = (Integer[])v.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);    </span><br><span class="line">    <span class="keyword">return</span> newText;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。</p><p>6.在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。</p><h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h1&gt;&lt;img src=&quot;java集合md.assets/image-20210630191902744.png&quot; alt=&quot;image-2021063</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2021/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-07-01T10:42:11.737Z</published>
    <updated>2021-07-01T10:41:35.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h1><p>​        为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。</p><p>　　除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：</p><img src="计算机网络.assets/image-20210629104655430.png" alt="image-20210629104655430" style="zoom: 80%;" /><h1 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h1><img src="计算机网络.assets/image-20210629104748900.png" alt="image-20210629104748900"  /><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210629121007165.png" alt="image-20210629121007165"></p><h2 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a><strong>物理层（Physical Layer）</strong></h2><p>​        激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</strong>物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p><h2 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a><strong>数据链路层（Data Link Layer）</strong></h2><p>​        数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，<strong>主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame）</strong>，帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：<strong>物理地址寻址、数据的成帧、流量控制、数据的检错、重发</strong>等。</p><p>​        有关数据链路层的重要知识点：</p><p>　　<strong>1 数据链路层为网络层提供可靠的数据传输；</strong></p><p>　　<strong>2基本数据单位为帧；</strong></p><p>　　<strong>3主要的协议：以太网协议；</strong></p><p>　　<strong>4两个重要设备名称：网桥和交换机</strong>。</p><h2 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a><strong>网络层（Network Layer）</strong></h2><p>​        网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括<strong>寻址和路由选择、连接的建立、保持和终止</strong>等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。</p><p>　　网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——**==IP协议==<strong>。IP协议非常简单，仅仅</strong>==提供不可靠、无连接的传送服务==**。</p><p>​        IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为： </p><p>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；基本数据单位为IP数据报; 包含的主要协议：</p><p>　　<strong>IP协议（Internet Protocol，因特网互联协议）;</strong></p><p>　　<strong>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</strong></p><p>　　<strong>ARP协议（Address Resolution Protocol，地址解析协议）;</strong></p><p>　　<strong>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</strong></p><p>　重要的设备：路由器。**</p><h2 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a><strong>传输层（Transport Layer）</strong></h2><p>​        第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p><p>　　传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。</p><p>　　<strong>网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口</strong>。</p><p>​        <strong>传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</strong></p><p>　　包含的主要协议：</p><p>​                <strong>TCP协议（Transmission Control Protocol，传输控制协议）</strong></p><p>​                <strong>UDP协议（User Datagram Protocol，用户数据报协议）</strong></p><p>　　 重要设备：网关。**</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a><strong>会话层</strong></h2><p>​        会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a><strong>表示层</strong></h2><p>​        表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><strong>应用层</strong></h2><p>为操作系统或网络应用程序提供访问网络服务的接口。</p><p>会话层、表示层和应用层重点：</p><p>　　<strong>1数据传输基本单位为报文；</strong></p><p>　　<strong>2 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</strong></p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>​        <strong>（1）网络地址</strong></p><p>　　        IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p>　　<strong>（2）广播地址</strong></p><p>　　        广播地址通常称为直接广播地址，是为了区分受限广播地址。</p><p>　　        广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p>　　<strong>（3）组播地址</strong></p><p>　　        D类地址就是组播地址。</p><p>　　        A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；</p><p>　　        B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>　　        C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>　　        D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>　　        E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>　　        注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p>　　<strong>（4）255.255.255.255</strong></p><p>　　    该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>　　注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p><p>　　<strong>（5）0.0.0.0</strong></p><p>　　        常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p>　　<strong>（6）回环地址</strong></p><p>　　        127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p><p>　　<strong>（7）A、B、C类私有地址</strong></p><p>　　        私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>　　        A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p><p>　　        B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>　　        C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><h1 id="ARP-RARP协议"><a href="#ARP-RARP协议" class="headerlink" title="ARP/RARP协议"></a>ARP/RARP协议</h1><p>​        <strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</strong>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。<strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p><p>　　ARP工作流程举例：</p><p>　　主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p><p>　　主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>　　当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><p>　　（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</p><p>　　（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p><p>　　（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>　　（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p><p>　　（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><p>　　<strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p><p>　　RARP协议工作流程：</p><p>　　（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</p><p>　　（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</p><p>　　（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</p><p>　　（4）如果不存在，RARP服务器对此不做任何的响应；</p><p>　　（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p><h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><p>　　<strong>RIP协议</strong> ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><p>　　<strong>OSPF协议</strong>：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p><h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><p>​        <strong>TCP/IP协议是Internet最基本的协议，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>　　IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—<strong>TCP或UDP层</strong>；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p><p> 　TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><blockquote><h2 id="TCP报文首部格式"><a href="#TCP报文首部格式" class="headerlink" title="TCP报文首部格式"></a>TCP报文首部格式</h2></blockquote><img src="计算机网络.assets/image-20210629201931657.png" alt="image-20210629201931657" style="zoom: 80%;" /><ul><li>seq序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100字节，那么下一个报文段的序号应为 401。</li><li>确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li>数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li>确认 <strong>ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把ACK 置 1。</li><li>同步 <strong>SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li>终止 <strong>FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li>窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空<br>间是有限的。  </li></ul><h2 id="TCP协议的三次握手"><a href="#TCP协议的三次握手" class="headerlink" title="TCP协议的三次握手"></a>TCP协议的三次握手</h2><img src="计算机网络.assets/image-20210629202704459.png" alt="image-20210629202704459" style="zoom:80%;" /><img src="计算机网络.assets/image-20210629202751437.png" alt="image-20210629202751437" style="zoom:67%;" /><p>​        服务器发出一个被动打开的命令，准备接收客户端的请求，并不断检测是否有客户端进程发起请求。客户端发出主动打开命令，表明要向某个IP地址的某个端口建立传输连接。</p><p>​        一次握手：客户端向服务器发送带有SYN标志的数据包（同步SYN=1，seq=x）</p><p>​        二次握手：服务器向客户端发送带有SYN/ACK的数据包(同步SYN=1，ACK=1,seq=y,ack=x+1)，表示同意建立连接。</p><p>​        三次握手：客户端向服务器发送带有ACK的数据包(ACK=1,seq=x+1,ack=y+1)</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>​        三次握手的目的是建立可靠的通信信道，通信简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><p>​        <img src="计算机网络.assets/image-20210630092902343.png" alt="image-20210630092902343" style="zoom:67%;" /></p><img src="计算机网络.assets/image-20210630093138246.png" alt="image-20210630093138246" style="zoom:67%;" /><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><img src="计算机网络.assets/image-20210630093314229.png" alt="image-20210630093314229" style="zoom: 80%;" /><ul><li>数据传输结束后，客户端向服务器发送一个FIN，用来关闭客户端到服务器的数据传送。</li><li>服务器收到FIN，然后发送一个ACK，确认序号为收到的序号加1，这样，从客户端到服务器的连接就释放了，连接处于半关闭状态。</li><li>服务器向客户端发送一个FIN，用来关闭服务器到客户端的数据传送。</li><li>客户端收到FIN，然后发送一个ACK，确认序号为收到的序号加1，这样，从服务器到客户端的连接就释放了，释放整个连接。</li></ul><h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><p>​        任何一方都可以在数据传输结束后发出释放连接的通知，待对方确认进入半关闭状态。当另一方也没有数据再发送的时候，则发出释放连接的通知，对方确认后就完全关闭了TCP连接。</p><p>​        <img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210630120947922.png" alt="image-20210630120947922"></p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210630121629314.png" alt="image-20210630121629314"></p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210630121701043.png" alt="image-20210630121701043"></p><h2 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h2><img src="计算机网络.assets/image-20210630150318743.png" alt="image-20210630150318743" style="zoom:67%;" /><h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><img src="计算机网络.assets/image-20210630150424349.png" alt="image-20210630150424349"  /><img src="计算机网络.assets/image-20210629183642120.png" alt="image-20210629183642120" style="zoom:50%;" /><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="在浏览器中输入www-baidu-com后执行的全部过程"><a href="#在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="在浏览器中输入www.baidu.com后执行的全部过程"></a>在浏览器中输入<a href="http://www.baidu.com后执行的全部过程/">www.baidu.com后执行的全部过程</a></h2><p>1.应用层：客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址220.181.27.48,通过这个ip地址找到客户端到服务器的路径.客户端浏览器发起一个http会话到220.161.27.48,然后通过tcp进行封装数据包,输入到网络层./">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p><p><img src="https://img-blog.csdn.net/20160312165927564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>2、传输层:在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p><p>3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是**==通过查找路由表确定如何到达服务器==**，期间可能经过多个路由器，这些都是由路由器来完成的工作，通过查找路由表决定通过那个路径到达服务器,其中用到路由选择协议。</p><p><img src="https://img-blog.csdn.net/20160312170002252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以<strong>使用ARP的请求应答交换的IP数据包</strong>，然后发送IP数据包到达服务器的地址。</p><p><strong>ARP(地址解析协议)</strong></p><p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。</p><p><img src="https://img-blog.csdn.net/20160312170034757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210630154316728.png" alt="image-20210630154316728"></p><img src="计算机网络.assets/image-20210630154305267.png" alt="image-20210630154305267" style="zoom: 80%;" /><h2 id="Cookie和session"><a href="#Cookie和session" class="headerlink" title="Cookie和session"></a>Cookie和session</h2><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210630171504068.png" alt="image-20210630171504068"></p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210630171520862.png" alt="image-20210630171520862"></p><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210630171609497.png" alt="image-20210630171609497"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络层次划分&quot;&gt;&lt;a href=&quot;#网络层次划分&quot; class=&quot;headerlink&quot; title=&quot;网络层次划分&quot;&gt;&lt;/a&gt;网络层次划分&lt;/h1&gt;&lt;p&gt;​        为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>#创建新的文章</title>
    <link href="http://example.com/2021/06/24/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2021/06/24/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2021-06-24T01:28:01.000Z</published>
    <updated>2021-06-24T03:51:28.592Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好，Hexo!</span><br></pre></td></tr></table></figure><h3 id="dgdgd"><a href="#dgdgd" class="headerlink" title="dgdgd"></a>dgdgd</h3><h2 id="hh"><a href="#hh" class="headerlink" title="hh"></a>hh</h2><h3 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h3><h4 id="vhd"><a href="#vhd" class="headerlink" title="vhd"></a>vhd</h4><p>j gjn</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/06/24/hello-world/"/>
    <id>http://example.com/2021/06/24/hello-world/</id>
    <published>2021-06-24T01:24:16.236Z</published>
    <updated>2021-06-24T01:24:16.236Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
