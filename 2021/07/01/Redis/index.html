<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Hexo | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NoSQL概述发展历史 单机MySQL 在90年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！在那个时候，更多的都是静态网页，动态交互类型的网站不多。上述架构下，我们来看看数据存储的瓶颈是什么？  数据量的总大小，一个机器放不下时 数据的索引（B+ Tree）一个机器的内存放不下时 访问量（读写混合）一个实例不能承受如果满足了上述 1 or 3个，进化….DAL：数据库访问层">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/07/01/Redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="NoSQL概述发展历史 单机MySQL 在90年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！在那个时候，更多的都是静态网页，动态交互类型的网站不多。上述架构下，我们来看看数据存储的瓶颈是什么？  数据量的总大小，一个机器放不下时 数据的索引（B+ Tree）一个机器的内存放不下时 访问量（读写混合）一个实例不能承受如果满足了上述 1 or 3个，进化….DAL：数据库访问层">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-07-01T10:42:11.741Z">
<meta property="article:modified_time" content="2021-06-29T02:26:58.190Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/07/01/Redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hexo',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-29 10:26:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw iconfont icon-fenxiang"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-shuji"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/FilmAndTV/"><i class="fa-fw iconfont icon-yingshi1"></i><span> 影视</span></a></li><li><a class="site-page child" href="/daohang/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw iconfont icon-fenxiang"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-shuji"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/FilmAndTV/"><i class="fa-fw iconfont icon-yingshi1"></i><span> 影视</span></a></li><li><a class="site-page child" href="/daohang/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">No title</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-01T10:42:11.741Z" title="Created 2021-07-01 18:42:11">2021-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-06-29T02:26:58.190Z" title="Updated 2021-06-29 10:26:58">2021-06-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="NoSQL概述"><a href="#NoSQL概述" class="headerlink" title="NoSQL概述"></a>NoSQL概述</h1><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><blockquote>
<h2 id="单机MySQL"><a href="#单机MySQL" class="headerlink" title="单机MySQL"></a>单机MySQL</h2></blockquote>
<p>在90年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！在那个时候，更多的都是静态网页，动态交互类型的网站不多。上述架构下，我们来看看数据存储的瓶颈是什么？</p>
<ol>
<li>数据量的总大小，一个机器放不下时</li>
<li>数据的索引（B+ Tree）一个机器的内存放不下时</li>
<li>访问量（读写混合）一个实例不能承受<br>如果满足了上述 1 or 3个，进化….<br>DAL：数据库访问层  </li>
</ol>
<p><img src="Redis.assets/image-20210625214024956.png" alt="image-20210625214024956"></p>
<blockquote>
<h2 id="Memcached（缓存）-MySQL-垂直拆分"><a href="#Memcached（缓存）-MySQL-垂直拆分" class="headerlink" title="Memcached（缓存）+ MySQL + 垂直拆分"></a>Memcached（缓存）+ MySQL + 垂直拆分</h2></blockquote>
<p>​       后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注在功能上，同时也在追求性能。程序猿们开始大量使用缓存技术来缓解数据库的压力，优化数据库的结构和索引，开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了比较高的IO压力，在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</p>
<p><img src="Redis.assets/image-20210625214412936.png" alt="image-20210625214412936"></p>
<blockquote>
<h2 id="MySQL主从读写分离"><a href="#MySQL主从读写分离" class="headerlink" title="MySQL主从读写分离"></a>MySQL主从读写分离</h2></blockquote>
<p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力，读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用<strong>主从复制</strong>技术来达到读写分离，以提高读写性能和读库的可扩展性，MySQL的master-slave模式成为这个时候的网站标配了。  </p>
<p><img src="Redis.assets/image-20210625214505323.png" alt="image-20210625214505323"></p>
<blockquote>
<h2 id="分表分库-水平拆分-Mysql-集群"><a href="#分表分库-水平拆分-Mysql-集群" class="headerlink" title="分表分库 + 水平拆分 + Mysql 集群"></a>分表分库 + 水平拆分 + Mysql 集群</h2></blockquote>
<p>​        在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题，这个时候，分表分库成了一个热门技术，是面试的热门问题，也是业界讨论的热门技术问题。也就是在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的需求，只是在高可靠性上提供了非常大的保证。  </p>
<p><img src="Redis.assets/image-20210625215043219.png" alt="image-20210625215043219"></p>
<blockquote>
<h2 id="MySQL-的扩展性瓶颈"><a href="#MySQL-的扩展性瓶颈" class="headerlink" title="MySQL 的扩展性瓶颈"></a>MySQL 的扩展性瓶颈</h2></blockquote>
<p>​        MySQL数据库也经常存储一些大文本的字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库，比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变的非常的小，关系数据库很强大，但是它并不能很好的应付所有的应用场景，MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题  。</p>
<img src="Redis.assets/image-20210625215153581.png" alt="image-20210625215153581" style="zoom:67%;" />

<blockquote>
<h2 id="为什么用NoSQL？"><a href="#为什么用NoSQL？" class="headerlink" title="为什么用NoSQL？"></a>为什么用NoSQL？</h2></blockquote>
<p>​        今天我们可以通过第三方平台（如：Google，FaceBook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加、我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，而NoSQL数据库的发展却能很好的处理这些大的数据。</p>
<h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><p>NoSQL = Not Only SQL，意思：不仅仅是SQL；<br>泛指非关系型的数据库，随着互联网Web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的社交网络服务类型的Web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展，NoSQL数据库的产生就是为了解决大规模数据集合多种数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。  </p>
<h3 id="NoSQL的特点"><a href="#NoSQL的特点" class="headerlink" title="NoSQL的特点"></a>NoSQL的特点</h3><p><strong>1、易扩展</strong><br>NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。<br>数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。<br><strong>2、大数据量高性能</strong>  </p>
<p>NoSQL数据库都具有非常高的读写性能，尤其是在大数据量下，同样表现优秀。这得益于它的非关系性，数据库的结构简单。<br>一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大力度的Cache，在针对Web2.0的交互频繁应用，Cache性能不高，而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。<br>官方记录：Redis 一秒可以写8万次，读11万次  </p>
<p><strong>3、多样灵活的数据模型</strong>  </p>
<p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是噩梦  。</p>
<p><strong>4、传统的RDBMS VS NoSQL</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传统的关系型数据库 RDBMS- 高度组织化结构化数据- 结构化查询语言（SQL）- 数据和关系都存储在单独的表中- 数据操纵语言，数据定义语言- 严格的一致性- 基础事务NoSQL- 代表着不仅仅是SQL- 没有声明性查询语言- 没有预定义的模式- 键值对存储，列存储，文档存储，图形数据库- 最终一致性，而非ACID属性- 非结构化和不可预知的数据- CAP定理- 高性能，高可用性 和 可伸缩性</span><br></pre></td></tr></table></figure>

<h2 id="经典应用分析"><a href="#经典应用分析" class="headerlink" title="经典应用分析"></a>经典应用分析</h2><p>1、商品的基本信息  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称、价格、出厂日期、生产厂商等关系型数据库：mysql、oracle目前淘宝在去O化（也即，拿掉Oracle）注意，淘宝内部用的MySQL是里面的大牛自己改造过的。为什么去IOE：2008年,王坚博士加入阿里巴巴，成为首席架构师。把云计算植入阿里IT基因。2013年5月17日，阿里集团最后一台IBM小机在支付宝下线。这是自2009年“去IOE”战略透露以来，“去IOE”非常重要的一个节点。“去 IOE”指的是摆脱掉IT部署中原有的IBM小型机、Oracle数据库以及EMC存储的过度依赖。告别最后一台小机，意味着整个阿里集团尽管还有一些Oracle数据库和EMC存储，但是IBM小型机已全部被替换。2013年7月10日，淘宝重中之重的广告系统使用的Oracle数据库下线，也是整个淘宝最后一个 Oracle数据库。这两件事合在一起是阿里巴巴技术发展过程中的一个重要里程碑</span><br></pre></td></tr></table></figure>

<p>2、商品描述、详情、评价信息（多文字类）  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多文字信息描述类，IO读写性能变差存在文档数据库MongDB中</span><br></pre></td></tr></table></figure>

<p>3、商品的图片  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">商品图片展现类分布式文件系统中- 淘宝自己的 TFS- Google的 GFS- Hadoop的 HDFS</span><br></pre></td></tr></table></figure>

<p>4、商品的关键字  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索引擎，淘宝内用ISearch：多隆一高兴一个人开发的</span><br></pre></td></tr></table></figure>

<p>5、商品的波段性的热点高频信息  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存数据库Tair、Redis、Memcache等</span><br></pre></td></tr></table></figure>

<p>6、商品的交易，价格计算，积分累计  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部系统，外部第三方支付接口支付宝外部系统，外部第三方支付接口支付宝</span><br></pre></td></tr></table></figure>

<h1 id="NoSQL四大分类"><a href="#NoSQL四大分类" class="headerlink" title="NoSQL四大分类"></a>NoSQL四大分类</h1><ul>
<li><p>KV键值：</p>
<p>​    新浪：BerkeleyDB+redis<br>​    美团：redis+tair<br>​    阿里、百度：memcache+redis</p>
</li>
<li><p>文档型数据库(bson格式比较多)：<br>CouchDB<br>MongoDB<br>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
</li>
<li><p>列存储数据库：<br>Cassandra, HBase<br>分布式文件系统</p>
</li>
<li><p>图关系数据库<br>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统、社交网络，推荐系统等。专注于构建关系图谱<br>Neo4J, InfoGrid  </p>
</li>
</ul>
<blockquote>
<h2 id="四者对比"><a href="#四者对比" class="headerlink" title="四者对比"></a>四者对比</h2></blockquote>
<p><img src="Redis.assets/image-20210625220533411.png" alt="image-20210625220533411"></p>
<blockquote>
<h2 id="CAP（三进二）"><a href="#CAP（三进二）" class="headerlink" title="CAP（三进二）"></a>CAP（三进二）</h2></blockquote>
<ul>
<li>C : Consistency（强一致性）</li>
<li>A : Availability（可用性）</li>
<li>P : Partition tolerance（分区容错性）  </li>
</ul>
<p><strong>CAP理论的核心是</strong>：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP原则和满足 AP 原则三大类：</p>
<ul>
<li>  CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>  CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</li>
<li>  AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。  </li>
</ul>
<blockquote>
<h2 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h2></blockquote>
<p>BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性  。</p>
<p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。<br>BASE其实是下面三个术语的缩写：</p>
<ul>
<li>基本可用(Basically Available)： 基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</li>
<li>软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。MySQL Replication 的异步复制也是一种体现。</li>
<li>最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这<br>些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法！<br><strong>解释：</strong><br>   1、分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc通信和调用，对外<br>提供服务和组内协作。<br>2、集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供<br>服务和访问。  </li>
</ul>
<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2></blockquote>
<p>Redis：REmote DIctionary Server（远程字典服务器）<br>        是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（Key/Value）分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为数据结构服务器<br>Redis与其他key-value缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的 key-value 类型的数据，同时还提供list、set、zset、hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。  </li>
</ul>
<blockquote>
<h2 id="Redis能干嘛"><a href="#Redis能干嘛" class="headerlink" title="Redis能干嘛"></a>Redis能干嘛</h2></blockquote>
<ul>
<li>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li>
<li>取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面</li>
<li>发布、订阅消息系统</li>
<li>地图信息分析</li>
<li>定时器、计数器  </li>
</ul>
<blockquote>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2></blockquote>
<ul>
<li><p>数据类型、基本操作和配置</p>
</li>
<li><p>持久化和复制，RDB、AOF</p>
</li>
<li><p>事务的控制  </p>
</li>
</ul>
<h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/dmajkic/redis/downloads">https://github.com/dmajkic/redis/downloads</a>  </p>
<p><img src="Redis.assets/image-20210625221602570.png" alt="image-20210625221602570"></p>
<p>双击 redis-server.exe 启动即可  </p>
<img src="Redis.assets/image-20210625221616614.png" alt="image-20210625221616614" style="zoom: 80%;" />

<h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><p>下载地址 <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-5.0.7.tar.gz">http://download.redis.io/releases/redis-5.0.7.tar.gz</a>  </p>
<img src="Redis.assets/image-20210625221656416.png" alt="image-20210625221656416" style="zoom: 67%;" />



<blockquote>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2></blockquote>
<ul>
<li><p>1、下载获得 redis-6.2.4.tar.gz 后将它放到我们Linux的目录下 /opt</p>
</li>
<li><p>2、/opt 目录下，解压命令 ： tar -zxvf redis-6.2.4.tar.gz</p>
</li>
<li><p>3、解压完成后出现文件夹：redis-6.2.4</p>
</li>
<li><p>4、进入目录： cd redis-6.2.4</p>
</li>
<li><p>5、在 redis-6.2.4 目录下执行 make 命令  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">运行make命令时故意出现的错误解析：</span><br><span class="line">1. 安装gcc (gcc是linux下的一个编译程序，是c程序的编译工具)</span><br><span class="line">能上网: yum install gcc-c++</span><br><span class="line">版本测试: gcc-v</span><br><span class="line">2. make</span><br><span class="line">3. Jemalloc/jemalloc.h: 没有那个文件或目录</span><br><span class="line">运行 make distclean 之后再make</span><br><span class="line">4. make install</span><br><span class="line">5. <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</span><br><span class="line">6. mkdir myredis</span><br><span class="line">7. cp /home/software/redis-6.2.4/redis.conf myredis</span><br><span class="line">8. vim redis.conf</span><br><span class="line">	修改为 daemonize:yes</span><br><span class="line">9. 创建快捷方式 cp -r /home/software/redis-6.2.4/src/redis-cli /usr/bin</span><br><span class="line">10. 启动测试</span><br><span class="line"><span class="comment"># 【shell】启动redis服务</span></span><br><span class="line">[root@192 bin]<span class="comment"># cd /usr/local/bin</span></span><br><span class="line">[root@192 bin]<span class="comment"># redis-server /opt/redis-6.2.4/redis.conf</span></span><br><span class="line"><span class="comment"># redis客户端连接===&gt; 观察地址的变化，如果连接ok,是直接连上的，redis默认端口号 6379</span></span><br><span class="line">[root@192 bin]<span class="comment"># redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 helloworld</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="comment"># 【shell】ps显示系统当前进程信息</span></span><br><span class="line">[root@192 myredis]<span class="comment"># ps -ef|grep redis</span></span><br><span class="line">root 16005 1 0 04:45 ? 00:00:00 redis-server</span><br><span class="line">127.0.0.1:6379</span><br><span class="line">root 16031 15692 0 04:47 pts/0 00:00:00 redis-cli -p 6379</span><br><span class="line">root 16107 16076 0 04:51 pts/2 00:00:00 grep --color=auto redis</span><br><span class="line"><span class="comment"># 【redis】关闭连接</span></span><br><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 【shell】ps显示系统当前进程信息</span></span><br><span class="line">[root@192 myredis]<span class="comment"># ps -ef|grep redis</span></span><br><span class="line">root 16140 16076 0 04:53 pts/2 00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ash: ls: command not found，无法使用Linux命令</span><br><span class="line">是因为环境变量PATH被修改了</span><br><span class="line">只需在命令行执行</span><br><span class="line">export PATH=/bin:/usr/bin:$PATH</span><br><span class="line">即可</span><br></pre></td></tr></table></figure>

<h2 id="redis压力测试工具—–Redis-benchmark"><a href="#redis压力测试工具—–Redis-benchmark" class="headerlink" title="redis压力测试工具—–Redis-benchmark"></a>redis压力测试工具—–Redis-benchmark</h2><img src="Redis.assets/image-20210625222652928.png" alt="image-20210625222652928" style="zoom: 80%;" />

<p>默认16个数据库，类似数组下标从零开始，初始默认使用零号库  </p>
<p>Select命令切换数据库  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[7]&gt;</span><br><span class="line"><span class="comment"># 不同的库可以存不同的数据</span></span><br></pre></td></tr></table></figure>

<p>Dbsize查看当前数据库的key的数量  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 7</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[7]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[7]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看具体的key</span></span><br><span class="line">1) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">2) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;myset:__rand_int__&quot;</span></span><br><span class="line">5) <span class="string">&quot;key:__rand_int__&quot;</span></span><br></pre></td></tr></table></figure>

<p>Flushdb：清空当前库<br>Flushall：清空全部的库  </p>
<h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><p>1）以前一直有个误区，以为：高性能服务器 一定是多线程来实现的<br>原因很简单因为误区二导致的：多线程 一定比单线程效率高，其实不然！<br>在说这个事前希望大家都能对 CPU 、 内存 、 硬盘的速度都有了解了！<br>2）redis 核心就是 如果我的数据全都在内存里，我单线程的去操作就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案。因为一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us，假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，那么就有1500ns *1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不算你每次读一点数据的时间 。</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><p>​        Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流的地理空间索引。Redis具有内置的复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区提供了高可用性。  </p>
<h2 id="String-（字符串类型）"><a href="#String-（字符串类型）" class="headerlink" title="String （字符串类型）"></a>String （字符串类型）</h2><p>​        String是redis最基本的类型，你可以理解成Memcached一模一样的类型，一个key对应一个value。String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。String类型是redis最基本的数据类型，一个redis中字符串value最多可以是512M。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# set、get、del、append、strlen# ===================================================127.0.0.1:6379&gt; set key1 value1 # 设置值OK127.0.0.1:6379&gt; get key1 # 获得key&quot;value1&quot;127.0.0.1:6379&gt; del key1 # 删除key(integer) 1127.0.0.1:6379&gt; keys * # 查看全部的key(empty list or set)127.0.0.1:6379&gt; exists key1 # 确保 key1 不存在(integer) 0127.0.0.1:6379&gt; append key1 &quot;hello&quot; # 对不存在的 key 进行 APPEND ，等同于 SETkey1 &quot;hello&quot;(integer) 5 # 字符长度127.0.0.1:6379&gt; APPEND key1 &quot;-2333&quot; # 对已存在的字符串进行 APPEND(integer) 10 # 长度从 5 个字符增加到 10 个字符127.0.0.1:6379&gt; get key1&quot;hello-2333&quot;127.0.0.1:6379&gt; STRLEN key1 # # 获取字符串的长度(integer) 10# ===================================================# incr、decr 一定要是数字才能进行加减，+1 和 -1。# incrby、decrby 命令将 key 中储存的数字加上指定的增量值。# ===================================================127.0.0.1:6379&gt; set views 0 # 设置浏览量为0OK127.0.0.1:6379&gt; incr views # 浏览 + 1(integer) 1127.0.0.1:6379&gt; incr views # 浏览 + 1(integer) 2127.0.0.1:6379&gt; decr views # 浏览 - 1(integer) 1127.0.0.1:6379&gt; incrby views 10 # +10(integer) 11127.0.0.1:6379&gt; decrby views 10 # -10(integer) 1# ===================================================# range [范围]# getrange 获取指定区间范围内的值，类似between...and的关系，从零到负一表示全部# ===================================================127.0.0.1:6379&gt; set key2 abcd123456 # 设置key2的值OK127.0.0.1:6379&gt; getrange key2 0 -1 # 获得全部的值&quot;abcd123456&quot;127.0.0.1:6379&gt; getrange key2 0 2 # 截取部分字符串&quot;abc&quot;# ===================================================# setrange 设置指定区间范围内的值，格式是setrange key值 具体值# ===================================================127.0.0.1:6379&gt; get key2&quot;abcd123456&quot;127.0.0.1:6379&gt; SETRANGE key2 1 xx # 替换值(integer) 10127.0.0.1:6379&gt; get key2&quot;axxd123456&quot;# ===================================================# setex（set with expire）键秒值# setnx（set if not exist）# ===================================================127.0.0.1:6379&gt; setex key3 60 expire # 设置过期时间OK127.0.0.1:6379&gt; ttl key3 # 查看剩余的时间(integer) 55127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果不存在就设置，成功返回1(integer) 1127.0.0.1:6379&gt; setnx mykey &quot;mongodb&quot; # 如果存在就设置，失败返回0(integer) 0127.0.0.1:6379&gt; get mykey&quot;redis&quot;# ===================================================# mset Mset 命令用于同时设置一个或多个 key-value 对。# mget Mget 命令返回所有(一个或多个)给定 key 的值。# 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。# msetnx 当所有 key 都成功设置，返回 1 。# 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。原子操作 #===================================================127.0.0.1:6379&gt; mset k10 v10 k11 v11 k12 v12OK127.0.0.1:6379&gt; keys *1) &quot;k12&quot;2) &quot;k11&quot;3) &quot;k10&quot;127.0.0.1:6379&gt; mget k10 k11 k12 k131) &quot;v10&quot;2) &quot;v11&quot;3) &quot;v12&quot;4) (nil)127.0.0.1:6379&gt; msetnx k10 v10 k15 v15 # 原子性操作！(integer) 0127.0.0.1:6379&gt; get key15(nil)# 传统对象缓存set user:1 value(json数据)# 可以用来缓存对象mset user:1:name zhangsan user:1:age 2mget user:1:name user:1:age# ===================================================# getset（先get再set）# ===================================================127.0.0.1:6379&gt; getset db mongodb # 没有旧值，返回 nil(nil)127.0.0.1:6379&gt; get db&quot;mongodb&quot;127.0.0.1:6379&gt; getset db redis # 返回旧值 mongodb&quot;mongodb&quot;127.0.0.1:6379&gt; get db&quot;redis&quot;</span></span><br></pre></td></tr></table></figure>

<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。常规key-value缓存应用：<br>常规计数：微博数，粉丝数等。  </p>
<h2 id="Hash（哈希，类似-Java里的Map）"><a href="#Hash（哈希，类似-Java里的Map）" class="headerlink" title="Hash（哈希，类似 Java里的Map）"></a>Hash（哈希，类似 Java里的Map）</h2><p>​        Redis hash 是一个键值对集合。Redis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# hset、hget 命令用于为哈希表中的字段赋值 。# hmset、hmget 同时将多个field-value对设置到哈希表中。会覆盖哈希表中已存在的字段。# hgetall 用于返回哈希表中，所有的字段和值。# hdel 用于删除哈希表 key 中的一个或多个指定字段# ===================================================127.0.0.1:6379&gt; hset myhash field1 &quot;liu&quot;(integer) 1127.0.0.1:6379&gt; hget myhash field1&quot;liu&quot;127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;OK127.0.0.1:6379&gt; HGET myhash field1&quot;Hello&quot;127.0.0.1:6379&gt; HGET myhash field2&quot;World&quot;127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;Hello&quot;3) &quot;field2&quot;4) &quot;World&quot;127.0.0.1:6379&gt; HDEL myhash field1(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;World&quot;# ===================================================# hlen 获取哈希表中字段的数量。# ===================================================127.0.0.1:6379&gt; hlen myhash(integer) 1127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;OK127.0.0.1:6379&gt; hlen myhash(integer) 2# ===================================================# hexists 查看哈希表的指定字段是否存在。# ===================================================127.0.0.1:6379&gt; hexists myhash field1(integer) 1127.0.0.1:6379&gt; hexists myhash field3(integer) 0# ===================================================# hkeys 获取哈希表中的所有域（field）。# hvals 返回哈希表所有域(field)的值。# ===================================================127.0.0.1:6379&gt; HKEYS myhash1) &quot;field2&quot;2) &quot;field1&quot;127.0.0.1:6379&gt; HVALS myhash1) &quot;World&quot;2) &quot;Hello&quot;# ===================================================# hincrby 为哈希表中的字段值加上指定增量值。# ===================================================127.0.0.1:6379&gt; hset myhash field 5(integer) 1127.0.0.1:6379&gt; HINCRBY myhash field 1(integer) 6127.0.0.1:6379&gt; HINCRBY myhash field -1(integer) 5127.0.0.1:6379&gt; HINCRBY myhash field -10(integer) -5# ===================================================# hsetnx 为哈希表中不存在的的字段赋值 。# ===================================================127.0.0.1:6379&gt; HSETNX myhash field1 &quot;hello&quot;(integer) 1 # 设置成功，返回 1 。127.0.0.1:6379&gt; HSETNX myhash field1 &quot;world&quot;(integer) 0 # 如果给定字段已经存在，返回 0 。127.0.0.1:6379&gt; HGET myhash field1&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><pre><code>     Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际是个链表 !  
</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# Lpush：将一个或多个值插入到列表头部。（左）# rpush：将一个或多个值插入到列表尾部。（右）# lrange：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。# 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。# 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。# ===================================================127.0.0.1:6379&gt; LPUSH list &quot;one&quot;(integer) 1127.0.0.1:6379&gt; LPUSH list &quot;two&quot;(integer) 2127.0.0.1:6379&gt; RPUSH list &quot;right&quot;(integer) 3127.0.0.1:6379&gt; Lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;right&quot;127.0.0.1:6379&gt; Lrange list 0 11) &quot;two&quot;2) &quot;one&quot;# ===================================================# lpop 命令用于移除并返回列表的第一个元素。当列表 key 不存在时，返回 nil 。# rpop 移除列表的最后一个元素，返回值为移除的元素。# ===================================================127.0.0.1:6379&gt; Lpop list&quot;two&quot;127.0.0.1:6379&gt; Rpop list&quot;right&quot;127.0.0.1:6379&gt; Lrange list 0 -11) &quot;one&quot;# ===================================================# Lindex，按照索引下标获得元素（-1代表最后一个，0代表是第一个）# ===================================================127.0.0.1:6379&gt; Lindex list 1(nil)127.0.0.1:6379&gt; Lindex list 0&quot;one&quot;127.0.0.1:6379&gt; Lindex list -1&quot;one&quot;# ===================================================# llen 用于返回列表的长度。# ===================================================127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; Lpush list &quot;one&quot;(integer) 1127.0.0.1:6379&gt; Lpush list &quot;two&quot;(integer) 2127.0.0.1:6379&gt; Lpush list &quot;three&quot;(integer) 3127.0.0.1:6379&gt; Llen list # 返回列表的长度(integer) 3# ===================================================# lrem key 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。# ===================================================127.0.0.1:6379&gt; lrem list 1 &quot;two&quot;(integer) 1127.0.0.1:6379&gt; Lrange list 0 -11) &quot;three&quot;2) &quot;one&quot;# ===================================================# Ltrim key 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。# ===================================================127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; RPUSH mylist &quot;hello&quot;(integer) 2127.0.0.1:6379&gt; RPUSH mylist &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; RPUSH mylist &quot;hello3&quot;(integer) 4127.0.0.1:6379&gt; ltrim mylist 1 2OK127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello&quot;2) &quot;hello2&quot;# ===================================================# rpoplpush 移除列表的最后一个元素，并将该元素添加到另一个列表并返回。# ===================================================127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush mylist &quot;foo&quot;(integer) 2127.0.0.1:6379&gt; rpush mylist &quot;bar&quot;(integer) 3127.0.0.1:6379&gt; rpoplpush mylist myotherlist&quot;bar&quot;127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello&quot;2) &quot;foo&quot;127.0.0.1:6379&gt; lrange myotherlist 0 -11) &quot;bar&quot;# ===================================================# lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。# ===================================================127.0.0.1:6379&gt; exists list # 对空列表(key 不存在)进行 LSET(integer) 0127.0.0.1:6379&gt; lset list 0 item # 报错(error) ERR no such key127.0.0.1:6379&gt; lpush list &quot;value1&quot; # 对非空列表进行 LSET(integer) 1127.0.0.1:6379&gt; lrange list 0 01) &quot;value1&quot;127.0.0.1:6379&gt; lset list 0 &quot;new&quot; # 更新值OK127.0.0.1:6379&gt; lrange list 0 01) &quot;new&quot;127.0.0.1:6379&gt; lset list 1 &quot;new&quot; # index 超出范围报错(error) ERR index out of range# ===================================================# linsert key before/after pivot value 用于在列表的元素前或者后插入元素。# 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。# ===================================================redis&gt; RPUSH mylist &quot;Hello&quot;(integer) 1redis&gt; RPUSH mylist &quot;World&quot;(integer) 2redis&gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;(integer) 3redis&gt; LRANGE mylist 0 -11) &quot;Hello&quot;2) &quot;There&quot;3) &quot;World&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="性能总结"><a href="#性能总结" class="headerlink" title="性能总结"></a>性能总结</h3></blockquote>
<ul>
<li><p>它是一个字符串链表，left，right 都可以插入添加</p>
</li>
<li><p>如果键不存在，创建新的链表</p>
</li>
<li><p>如果键已存在，新增内容</p>
</li>
<li><p>如果值全移除，对应的键也就消失了</p>
</li>
<li><p>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</p>
</li>
</ul>
<p>​        list就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。  </p>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>​        Redis的Set是String类型的无序集合，它是通过HashTable实现的 !  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# sadd 将一个或多个成员元素加入到集合中，不能重复# smembers 返回集合中的所有的成员。# sismember 命令判断成员元素是否是集合的成员。# ===================================================127.0.0.1:6379&gt; sadd myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;(integer) 0127.0.0.1:6379&gt; SMEMBERS myset1) &quot;kuangshen&quot;2) &quot;hello&quot;127.0.0.1:6379&gt; SISMEMBER myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; SISMEMBER myset &quot;world&quot;(integer) 0# ===================================================# scard，获取集合里面的元素个数# ===================================================127.0.0.1:6379&gt; scard myset(integer) 2# ===================================================# srem key value 用于移除集合中的一个或多个成员元素# ===================================================127.0.0.1:6379&gt; srem myset &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;hello&quot;# ===================================================# srandmember key 命令用于返回集合中的一个随机元素。# ===================================================127.0.0.1:6379&gt; SMEMBERS myset1) &quot;kuangshen&quot;2) &quot;world&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; SRANDMEMBER myset&quot;hello&quot;127.0.0.1:6379&gt; SRANDMEMBER myset 21) &quot;world&quot;2) &quot;kuangshen&quot;127.0.0.1:6379&gt; SRANDMEMBER myset 21) &quot;kuangshen&quot;2) &quot;hello&quot;# ===================================================# spop key 用于移除集合中的指定 key 的一个或多个随机元素# ===================================================127.0.0.1:6379&gt; SMEMBERS myset1) &quot;kuangshen&quot;2) &quot;world&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; spop myset&quot;world&quot;127.0.0.1:6379&gt; spop myset&quot;kuangshen&quot;127.0.0.1:6379&gt; spop myset&quot;hello&quot;# ===================================================# smove SOURCE DESTINATION MEMBER# 将指定成员 member 元素从 source 集合移动到 destination 集合。# ===================================================127.0.0.1:6379&gt; sadd myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;world&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; sadd myset2 &quot;set2&quot;(integer) 1127.0.0.1:6379&gt; smove myset myset2 &quot;kuangshen&quot;(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;world&quot;2) &quot;hello&quot;127.0.0.1:6379&gt; SMEMBERS myset21) &quot;kuangshen&quot;2) &quot;set2&quot;# ===================================================- 数字集合类- 差集： sdiff- 交集： sinter- 并集： sunion# ===================================================127.0.0.1:6379&gt; sadd key1 &quot;a&quot;(integer) 1127.0.0.1:6379&gt; sadd key1 &quot;b&quot;(integer) 1127.0.0.1:6379&gt; sadd key1 &quot;c&quot;(integer) 1127.0.0.1:6379&gt; sadd key2 &quot;c&quot;(integer) 1127.0.0.1:6379&gt; sadd key2 &quot;d&quot;(integer) 1127.0.0.1:6379&gt; sadd key2 &quot;e&quot;(integer) 1127.0.0.1:6379&gt; SDIFF key1 key2 # 差集1) &quot;a&quot;2) &quot;b&quot;127.0.0.1:6379&gt; SINTER key1 key2 # 交集1) &quot;c&quot;127.0.0.1:6379&gt; SUNION key1 key2 # 并集1) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;4) &quot;e&quot;5) &quot;d&quot;</span></span><br></pre></td></tr></table></figure>

<p>​        在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中  。</p>
<h2 id="Zset（sorted-set：有序集合）"><a href="#Zset（sorted-set：有序集合）" class="headerlink" title="Zset（sorted set：有序集合）"></a>Zset（sorted set：有序集合）</h2><p>​        Redis zset 和 set 一样，也是String类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。<br>Redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（Score）却可以重复。  </p>
<p>​        在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===================================================# zadd 将一个或多个成员元素及其分数值加入到有序集当中。# zrange 返回有序集中，指定区间内的成员# ===================================================127.0.0.1:6379&gt; zadd myset 1 &quot;one&quot;(integer) 1127.0.0.1:6379&gt; zadd myset 2 &quot;two&quot; 3 &quot;three&quot;(integer) 2127.0.0.1:6379&gt; ZRANGE myset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;# ===================================================# zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。# ===================================================127.0.0.1:6379&gt; zadd salary 2500 xiaoming(integer) 1127.0.0.1:6379&gt; zadd salary 5000 xiaohong(integer) 1127.0.0.1:6379&gt; zadd salary 500 ll(integer) 1# Inf无穷大量+∞,同样地,-∞可以表示为-Inf。127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf # 显示整个有序集1) &quot;ll&quot;2) &quot;xiaoming&quot;3) &quot;xiaohong&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 递增排列1) &quot;ll&quot;2) &quot;500&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;5) &quot;xiaohong&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 WITHSCORES # 递减排列1) &quot;xiaohong&quot;2) &quot;5000&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;5) &quot;ll&quot;6) &quot;500&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 WITHSCORES # 显示工资 &lt;=2500的所有成员1) &quot;ll&quot;2) &quot;500&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;# ===================================================# zrem 移除有序集中的一个或多个成员# ===================================================127.0.0.1:6379&gt; ZRANGE salary 0 -11) &quot;ll&quot;2) &quot;xiaoming&quot;3) &quot;xiaohong&quot;127.0.0.1:6379&gt; zrem salary ll(integer) 1127.0.0.1:6379&gt; ZRANGE salary 0 -11) &quot;xiaoming&quot;2) &quot;xiaohong&quot;# ===================================================# zcard 命令用于计算集合中元素的数量。# ===================================================127.0.0.1:6379&gt; zcard salary(integer) 2OK# ===================================================# zcount 计算有序集合中指定分数区间的成员数量。# ===================================================127.0.0.1:6379&gt; zadd myset 1 &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; zadd myset 2 &quot;world&quot; 3 &quot;lisi&quot;(integer) 2127.0.0.1:6379&gt; ZCOUNT myset 1 3(integer) 3127.0.0.1:6379&gt; ZCOUNT myset 1 2(integer) 2# ===================================================# zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。# ===================================================127.0.0.1:6379&gt; zadd salary 2500 xiaoming(integer) 1127.0.0.1:6379&gt; zadd salary 5000 xiaohong(integer) 1127.0.0.1:6379&gt; zadd salary 500 lisi(integer) 1127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES # 显示所有成员及其 score 值1) &quot;lis&quot;2) &quot;500&quot;3) &quot;xiaoming&quot;4) &quot;2500&quot;5) &quot;xiaohong&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; zrank salary lisi # 显示 lisi 的薪水排名，最少(integer) 0127.0.0.1:6379&gt; zrank salary xiaohong # 显示 xiaohong 的薪水排名，第三(integer) 2# ===================================================# zrevrank 返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。# ===================================================127.0.0.1:6379&gt; ZREVRANK salary lisi # lisi第三(integer) 2127.0.0.1:6379&gt; ZREVRANK salary xiaohong # 小红第一(integer) 0</span></span><br></pre></td></tr></table></figure>

<p>​        和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。排行榜应用，取TOP N操作 ！  </p>
<h2 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *查看当前库所有key    (匹配：keys *1)exists key判断某个key是否存在<span class="built_in">type</span> key 查看你的key是什么类型del key       删除指定的key数据unlink key   根据value选择非阻塞删除仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。expire key 10   10秒钟：为给定的key设置过期时间ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期select命令切换数据库dbsize查看当前数据库的key的数量flushdb清空当前库flushall通杀全部库</span><br></pre></td></tr></table></figure>

<h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="GEO地理位置"><a href="#GEO地理位置" class="headerlink" title="GEO地理位置"></a>GEO地理位置</h2><blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3></blockquote>
<p>Redis 的 GEO 特性在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。geo的数据类型为zset。</p>
<p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<p>GEO 的数据结构总共有六个常用命令：geoadd、geopos、geodist、georadius、georadiusbymember、gethash<br>官方文档：<a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3685.html">https://www.redis.net.cn/order/3685.html</a>  </p>
<blockquote>
<h3 id="geoadd-添加地理位置（经度，纬度，名称）"><a href="#geoadd-添加地理位置（经度，纬度，名称）" class="headerlink" title="geoadd  添加地理位置（经度，纬度，名称）"></a>geoadd  添加地理位置（经度，纬度，名称）</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法geoadd key longitude latitude member ...# 将给定的空间元素(纬度、经度、名字)添加到指定的键里面。# 这些数据会以有序集he的形式被储存在键里面，从而使得georadius和georadiusbymember这样的命令可以在之后通过位置查询取得这些元素。# geoadd命令以标准的x,y格式接受参数,所以用户必须先输入经度,然后再输入纬度。# geoadd能够记录的坐标是有限的:非常接近两极的区域无法被索引。# 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间。，当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 北京(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.2130.20 杭州(integer) 3127.0.0.1:6379&gt; geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.0230.58 武汉(integer) 3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="geopos-获得指定地区的坐标值"><a href="#geopos-获得指定地区的坐标值" class="headerlink" title="geopos  获得指定地区的坐标值"></a>geopos  获得指定地区的坐标值</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法geopos key member [member...]#从key里返回所有给定位置元素的位置（经度和纬度）127.0.0.1:6379&gt; geopos china:city 北京1) 1) &quot;116.23000055551528931&quot;   2) &quot;40.2200010338739844&quot;127.0.0.1:6379&gt; geopos china:city 上海 重庆1) 1) &quot;121.48000091314315796&quot;   2) &quot;31.40000025319353938&quot;2) 1) &quot;106.54000014066696167&quot;   2) &quot;29.39999880018641676&quot;127.0.0.1:6379&gt; geopos china:city 新疆1) (nil)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="geodist-获取两个位置之间的直线距离"><a href="#geodist-获取两个位置之间的直线距离" class="headerlink" title="geodist  获取两个位置之间的直线距离"></a>geodist  获取两个位置之间的直线距离</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法geodist key member1 member2 [unit]# 返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在,那么命令返回空值。# 指定单位的参数unit必须是以下单位的其中一个：# m表示单位为米# km表示单位为千米# mi表示单位为英里# ft表示单位为英尺# 如果用户没有显式地指定单位参数,那么geodist默认使用米作为单位。#geodist命令在计算距离时会假设地球为完美的球形,在极限情况下,这一假设最大会造成0.5%的误差。127.0.0.1:6379&gt; geodist china:city 北京 上海&quot;1088785.4302&quot;127.0.0.1:6379&gt; geodist china:city 北京 上海 km&quot;1088.7854&quot;127.0.0.1:6379&gt; geodist china:city 重庆 北京 km&quot;1491.6716&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="georadius-以给定的经纬度为中心，找出某一半径内的元素"><a href="#georadius-以给定的经纬度为中心，找出某一半径内的元素" class="headerlink" title="georadius  以给定的经纬度为中心，找出某一半径内的元素"></a>georadius  以给定的经纬度为中心，找出某一半径内的元素</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法georadius key longitude latitude radius m|km|ft|mi [withcoord][withdist][withhash][asc|desc][count count]# 以给定的经纬度为中心， 找出某一半径内的元素</span></span><br></pre></td></tr></table></figure>

<p>重新连接 redis-cli，增加参数 –raw ，可以强制输出中文，不然会乱码  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lhy bin]<span class="comment"># redis-cli --raw -p 6379# 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市127.0.0.1:6379&gt; georadius china:city 100 30 1000 km重庆西安# withdist 返回位置名称和中心距离127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withdist重庆635.2850西安963.3171# withcoord 返回位置名称和经纬度127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord重庆106.5400001406669616729.39999880018641676西安108.9299985766410827634.23000121926852302# withdist withcoord 返回位置名称 距离 和经纬度 count 限定寻找个数127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count1 重庆635.2850106.5400001406669616729.39999880018641676127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count2 重庆635.2850106.5400001406669616729.39999880018641676西安963.3171108.9299985766410827634.23000121926852302</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="georadiusbymember"><a href="#georadiusbymember" class="headerlink" title="georadiusbymember"></a>georadiusbymember</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法georadiusbymember key member radius m|km|ft|mi [withcoord][withdist][withhash][asc|desc][count count]# 找出位于指定范围内的元素，中心点是由给定的位置元素决定</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 北京 1000 km北京西安127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 上海 400 km杭州上海</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="geohash"><a href="#geohash" class="headerlink" title="geohash"></a>geohash</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法geohash key member [member...]# Redis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确,两个字符串越相似表示距离越近。127.0.0.1:6379&gt; geohash china:city 北京 重庆wx4sucu47r0wm5z22h53v0127.0.0.1:6379&gt; geohash china:city 北京 上海wx4sucu47r0wtw6sk5n300</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="zrem"><a href="#zrem" class="headerlink" title="zrem"></a>zrem</h3></blockquote>
<p>GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 beijin1 127.0.0.1:6379&gt; zrange china:city 0 -1 <span class="comment"># 查看全部的元素重庆西安深圳武汉杭州上海beijin北京127.0.0.1:6379&gt; zrem china:city beijin # 移除元素1127.0.0.1:6379&gt; zrem china:city 北京 # 移除元素1 127.0.0.1:6379&gt; zrange china:city 0 -1重庆西安深圳武汉杭州上海</span></span><br></pre></td></tr></table></figure>

<h2 id="HyperLog"><a href="#HyperLog" class="headerlink" title="HyperLog"></a>HyperLog</h2><blockquote>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3></blockquote>
<p>​        Redis 在 2.8.9 版本添加了 HyperLogLog 结构。<br>​        Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog则是一种算法，它提供了不精确的去重计数方案。<br>​        举个例子：假如我要统计网页的UV（浏览用户数量，一天内同一个用户多次访问只能算一次），传统的解决方案是使用Set来保存用户id，然后统计Set中的元素数量来获取页面UV。但这种方案只能承载少量用户，一旦用户数量大起来就需要消耗大量的空间来存储用户id。我的目的是统计用户数量而不是保存用户，这简直是个吃力不讨好的方案！而使用Redis的HyperLogLog最多需要12k就可以统计大量的用户数，尽管它大概有0.81%的错误率，但对于统计UV这种不需要很精确的数据是可以忽略不计的。  </p>
<blockquote>
<h3 id="什么是基数"><a href="#什么是基数" class="headerlink" title="什么是基数"></a>什么是基数</h3></blockquote>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。基数估计就是在误差可接受的范围内，快速计算基数。   </p>
<blockquote>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3></blockquote>
<p><img src="Redis.assets/image-20210627154114830.png" alt="image-20210627154114830"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD mykey a b c d e f g h i j1 127.0.0.1:6379&gt; PFCOUNT mykey10127.0.0.1:6379&gt; PFADD mykey2 i j z x c v b n m1 127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2OK127.0.0.1:6379&gt; PFCOUNT mykey315</span><br></pre></td></tr></table></figure>

<h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>​        现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图:</p>
<p><img src="Redis.assets/image-20210627154347176.png" alt="image-20210627154347176"></p>
<p>​        合理地使用操作位能够有效地提高内存使用率和开发效率。Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<ol>
<li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li>
<li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li>
</ol>
<p><img src="Redis.assets/image-20210627154431289.png" alt="image-20210627154431289"></p>
<blockquote>
<h3 id="setbit-设置操作"><a href="#setbit-设置操作" class="headerlink" title="setbit 设置操作"></a>setbit 设置操作</h3></blockquote>
<p>SETBIT key offset value : 设置 key 的第 offset 位为value (1或0)  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：# 周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）127.0.0.1:6379&gt; setbit sign 0 10 127.0.0.1:6379&gt; setbit sign 1 00 127.0.0.1:6379&gt; setbit sign 2 00 127.0.0.1:6379&gt; setbit sign 3 10 127.0.0.1:6379&gt; setbit sign 4 10 127.0.0.1:6379&gt; setbit sign 5 00 127.0.0.1:6379&gt; setbit sign 6 00</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="getbit-获取操作"><a href="#getbit-获取操作" class="headerlink" title="getbit 获取操作"></a>getbit 获取操作</h3></blockquote>
<p>GETBIT key offset 获取offset设置的值，未设置过默认返回0  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3 <span class="comment"># 查看周四是否打卡1 127.0.0.1:6379&gt; getbit sign 6 # 查看周七是否打卡0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="bitcount-统计操作"><a href="#bitcount-统计操作" class="headerlink" title="bitcount 统计操作"></a>bitcount 统计操作</h3></blockquote>
<p>bitcount key [start, end] 统计 key 上位为1的个数  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计这周打卡的记录，可以看到只有3天是打卡的状态：127.0.0.1:6379&gt; bitcount sign3</span></span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><ul>
<li><p><strong>Redis事务的概念</strong>：<br>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。<br>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
</li>
<li><p><strong>Redis事务没有隔离级别的概念：</strong><br>批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行！</p>
</li>
<li><p><strong>Redis不保证原子性：</strong><br>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
</li>
<li><p><strong>Redis事务的三个阶段：</strong>  </p>
<ol>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务  </li>
</ol>
</li>
</ul>
<p><strong>Redis事务相关命令：</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 key2 ... <span class="comment">#监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）multi # 标记一个事务块的开始（ queued ）exec # 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）discard # 取消事务，放弃事务块中的所有命令unwatch # 取消watch对所有key的监控</span></span><br></pre></td></tr></table></figure>

<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote>
<h3 id="正常执行事务"><a href="#正常执行事务" class="headerlink" title="正常执行事务"></a>正常执行事务</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI         <span class="comment">#开启事务OK127.0.0.1:6379(TX)&gt; set k1 v1  #命令入队QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; exec 	#执行事务1) OK						#输出结果2) OK3) OK</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1QUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 vvQUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3QUEUED127.0.0.1:6379(TX)&gt; DISCARDOK127.0.0.1:6379&gt; get k2<span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"><a href="#若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行" class="headerlink" title="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"></a>若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> m1 n1QUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> m2 n2QUEUED127.0.0.1:6379(TX)&gt; getset m3(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> command127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> m4 n4QUEUED127.0.0.1:6379(TX)&gt; EXEC		<span class="comment">#执行事务报错(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get m4			#命令未执行(nil)127.0.0.1:6379&gt; </span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。"><a href="#若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。" class="headerlink" title="若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。"></a>若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; INCR k1    	QUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 22QUEUED127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 33QUEUED127.0.0.1:6379(TX)&gt; get k3QUEUED127.0.0.1:6379(TX)&gt; EXEC1) (error) ERR value is not an <span class="built_in">integer</span> or out of range2) OK3) OK4) <span class="string">&quot;33&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="Watch-监控"><a href="#Watch-监控" class="headerlink" title="Watch 监控"></a>Watch 监控</h3></blockquote>
<ul>
<li><strong>悲观锁：</strong><pre><code>悲观锁(Pessimistic Lock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。
</code></pre>
</li>
<li><strong>乐观锁：</strong><pre><code>乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新的时候会判断一下再此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量，乐观锁策略：提交版本必须大于记录当前版本才能执行更新。
</code></pre>
</li>
<li><strong>测试：</strong>  </li>
</ul>
<p>1、初始化信用卡可用余额和欠额  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> balance 100OK127.0.0.1:6379&gt; <span class="built_in">set</span> debt 0OK</span><br></pre></td></tr></table></figure>

<p>2、使用watch检测balance，事务期间balance数据未变动，事务执行成功  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch balanceOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; decrby balance 20QUEUED127.0.0.1:6379&gt; incrby debt 20QUEUED127.0.0.1:6379&gt; exec1) (<span class="built_in">integer</span>) 802) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure>

<p>3、使用watch检测balance，事务期间balance数据变动，事务执行失败  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 窗口一127.0.0.1:6379&gt; watch balanceOK127.0.0.1:6379&gt; MULTI # 执行完毕后，执行窗口二代码测试OK127.0.0.1:6379&gt; decrby balance 20QUEUED127.0.0.1:6379&gt; incrby debt 20QUEUED127.0.0.1:6379&gt; exec # 修改失败！(nil)				 # 修改失败！# 窗口二127.0.0.1:6379&gt; get balance&quot;80&quot;127.0.0.1:6379&gt; set balance 200OK#解决方案：# 窗口一：出现问题后放弃监视，然后重来！127.0.0.1:6379&gt; UNWATCH # 放弃监视OK127.0.0.1:6379&gt; watch balanceOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; decrby balance 20QUEUED127.0.0.1:6379&gt; incrby debt 20QUEUED127.0.0.1:6379&gt; exec # 成功！1) (integer) 1802) (integer) 40</span></span><br></pre></td></tr></table></figure>

<p>说明：<br>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。  </p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能写成漂亮的代码 。</p>
<h2 id="测试联通"><a href="#测试联通" class="headerlink" title="测试联通"></a>测试联通</h2><p>1、新建一个普通的Maven项目</p>
<p>2、导入redis的依赖！  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/redis.clients/jedis --&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;            &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.58&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、编写测试代码  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);        System.out.println(<span class="string">&quot;连接成功&quot;</span>);		<span class="comment">//查看服务是否运行        System.out.println(&quot;服务正在运行: &quot;+jedis.ping());    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>4、启动redis服务</p>
<p>5、启动测试，结果  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地测试连接成功服务正在运行: PONG一. 配置redis.conf    1.设置访问redis的密码：requirepass 要设置密码    2.注释<span class="built_in">bind</span> 127.0.0.1    (重启redis-server服务,进入redis后要先验证密码,用这个命令：auth 密码 ,然后ping一下看有没有配置成功)二 . idea访问时添加auth密码  Jedis jedis = new Jedis(服务器的外网ip,6379);  jedis.auth(redis的密码);  System.out.println(jedis.ping());（输出PONG的话就成功了）</span><br></pre></td></tr></table></figure>

<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPassword</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);<span class="comment">//验证密码，如果没有设置密码这段代码省略// jedis.auth(&quot;password&quot;);        jedis.connect(); //连接        jedis.disconnect(); //断开连接        jedis.flushAll(); //清空所有的key    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="对key操作的命令"><a href="#对key操作的命令" class="headerlink" title="对key操作的命令"></a>对key操作的命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestKey</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);        System.out.println(<span class="string">&quot;清空数据：&quot;</span>+jedis.flushDB());        System.out.println(<span class="string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>));        System.out.println(<span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>));        System.out.println(<span class="string">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>));        System.out.print(<span class="string">&quot;系统中所有的键如下：&quot;</span>);        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);        System.out.println(keys);        System.out.println(<span class="string">&quot;删除键password:&quot;</span>+jedis.del(<span class="string">&quot;password&quot;</span>));        System.out.println(<span class="string">&quot;判断键password是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;password&quot;</span>));        System.out.println(<span class="string">&quot;查看键username所存储的值的类型：&quot;</span>+jedis.type(<span class="string">&quot;username&quot;</span>));        System.out.println(<span class="string">&quot;随机返回key空间的一个：&quot;</span>+jedis.randomKey());        System.out.println(<span class="string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;name&quot;</span>));        System.out.println(<span class="string">&quot;取出改后的name：&quot;</span>+jedis.get(<span class="string">&quot;name&quot;</span>));        System.out.println(<span class="string">&quot;按索引查询：&quot;</span>+jedis.select(<span class="number">0</span>));        System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span>+jedis.flushDB());        System.out.println(<span class="string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize());        System.out.println(<span class="string">&quot;删除所有数据库中的所有key：&quot;</span>+jedis.flushAll());    &#125;&#125;#运行结果清空数据：OK判断某个键是否存在：<span class="keyword">false</span>新增&lt;<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;kuangshen&#x27;</span>&gt;的键值对：OK新增&lt;<span class="string">&#x27;password&#x27;</span>,<span class="string">&#x27;password&#x27;</span>&gt;的键值对：OK系统中所有的键如下：[password, username]删除键password:<span class="number">1</span>判断键password是否存在：<span class="keyword">false</span>查看键username所存储的值的类型：string随机返回key空间的一个：username重命名key：OK取出改后的name：kuangshen按索引查询：OK删除当前选择数据库中的所有key：OK返回当前数据库中key的数目：<span class="number">0</span>删除所有数据库中的所有key：OK</span><br></pre></td></tr></table></figure>

<h3 id="对String操作的命令"><a href="#对String操作的命令" class="headerlink" title="对String操作的命令"></a>对String操作的命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TestString &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, 6379);        jedis.flushDB();        System.out.println(<span class="string">&quot;===========增加数据===========&quot;</span>);        System.out.println(jedis.set(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>));        System.out.println(jedis.set(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>));        System.out.println(jedis.set(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>));        System.out.println(<span class="string">&quot;删除键key2:&quot;</span>+jedis.del(<span class="string">&quot;key2&quot;</span>));        System.out.println(<span class="string">&quot;获取键key2:&quot;</span>+jedis.get(<span class="string">&quot;key2&quot;</span>));        System.out.println(<span class="string">&quot;修改key1:&quot;</span>+jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1Changed&quot;</span>));        System.out.println(<span class="string">&quot;获取key1的值：&quot;</span>+jedis.get(<span class="string">&quot;key1&quot;</span>));        System.out.println(<span class="string">&quot;在key3后面加入值：&quot;</span>+jedis.append(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;End&quot;</span>));        System.out.println(<span class="string">&quot;key3的值：&quot;</span>+jedis.get(<span class="string">&quot;key3&quot;</span>));        System.out.println(<span class="string">&quot;增加多个键值 对：&quot;</span>+jedis.mset(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>));        System.out.println(<span class="string">&quot;获取多个键值 对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));        System.out.println(<span class="string">&quot;获取多个键值 对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;key04&quot;</span>));        System.out.println(<span class="string">&quot;删除多个键值对：&quot;</span>+jedis.del(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>));        System.out.println(<span class="string">&quot;获取多个键值 对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));        jedis.flushDB();        System.out.println(<span class="string">&quot;===========新增键值对防止覆盖原先值==============&quot;</span>);        System.out.println(jedis.setnx(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));        System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>));        System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2-new&quot;</span>));        System.out.println(jedis.get(<span class="string">&quot;key1&quot;</span>));        System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));        System.out.println(<span class="string">&quot;===========新增键值对并设置有效时间=============&quot;</span>);        System.out.println(jedis.setex(<span class="string">&quot;key3&quot;</span>, 2, <span class="string">&quot;value3&quot;</span>));        System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));        System.out.println(<span class="string">&quot;===========获取原值，更新为新值==========&quot;</span>);        System.out.println(jedis.getSet(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key2GetSet&quot;</span>));        System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));        System.out.println(<span class="string">&quot;获得key2的值的字串：&quot;</span>+jedis.getrange(<span class="string">&quot;key2&quot;</span>, 2,                4));    &#125;&#125;<span class="comment">#运行结果===========增加数据===========OKOKOK删除键key2:1获取键key2:null修改key1:OK获取key1的值：value1Changed在key3后面加入值：9key3的值：value3End增加多个键值 对：OK获取多个键值 对：[value01, value02, value03]获取多个键值 对：[value01, value02, value03, null]删除多个键值对：2获取多个键值 对：[null, null, value03]===========新增键值对防止覆盖原先值==============110value1value2===========新增键值对并设置有效时间=============OKvalue3null===========获取原值，更新为新值==========value2key2GetSet获得key2的值的字串：y2G</span></span><br></pre></td></tr></table></figure>

<h3 id="对List操作命令"><a href="#对List操作命令" class="headerlink" title="对List操作命令"></a>对List操作命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);        jedis.flushDB();        System.out.println(<span class="string">&quot;===========添加一个list===========&quot;</span>);        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;ArrayList&quot;</span>, <span class="string">&quot;Vector&quot;</span>, <span class="string">&quot;Stack&quot;</span>, <span class="string">&quot;HashMap&quot;</span>, <span class="string">&quot;WeakHashMap&quot;</span>, <span class="string">&quot;LinkedHashMap&quot;</span>);        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;HashSet&quot;</span>);        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;TreeSet&quot;</span>);        jedis.lpush(<span class="string">&quot;collections&quot;</span>, <span class="string">&quot;TreeMap&quot;</span>);        System.out.println(<span class="string">&quot;collections的内容：&quot;</span>+jedis.lrange(<span class="string">&quot;collections&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));<span class="comment">//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部        System.out.println(&quot;collections区间0-3的元素：&quot;+jedis.lrange(&quot;collections&quot;,0,3));        System.out.println(&quot;===============================&quot;);// 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈        System.out.println(&quot;删除指定元素个数：&quot;+jedis.lrem(&quot;collections&quot;, 2, &quot;HashMap&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;删除下表0-3区间之外的元 素：&quot;+jedis.ltrim(&quot;collections&quot;, 0, 3));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;collections列表出栈（左端）：&quot;+jedis.lpop(&quot;collections&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;collections添加元素，从列表右端，与lpush相对 应：&quot;+jedis.rpush(&quot;collections&quot;, &quot;EnumMap&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;collections列表出栈（右 端）：&quot;+jedis.rpop(&quot;collections&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;修改collections指定下标1的内容：&quot;+jedis.lset(&quot;collections&quot;, 1, &quot;LinkedArrayList&quot;));        System.out.println(&quot;collections的内容：&quot;+jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;===============================&quot;);        System.out.println(&quot;collections的长度：&quot;+jedis.llen(&quot;collections&quot;));        System.out.println(&quot;获取collections下标为2的元素：&quot;+jedis.lindex(&quot;collections&quot;, 2));        System.out.println(&quot;===============================&quot;);        jedis.lpush(&quot;sortedList&quot;, &quot;3&quot;,&quot;6&quot;,&quot;2&quot;,&quot;0&quot;,&quot;7&quot;,&quot;4&quot;);        System.out.println(&quot;sortedList排序前：&quot;+jedis.lrange(&quot;sortedList&quot;, 0, -1));        System.out.println(jedis.sort(&quot;sortedList&quot;));        System.out.println(&quot;sortedList排序后：&quot;+jedis.lrange(&quot;sortedList&quot;, 0, -1));    &#125;&#125;#运行结果===========添加一个list===========collections的内容：[TreeMap, TreeSet, HashSet, LinkedHashMap, WeakHashMap, HashMap, Stack, Vector, ArrayList]collections区间0-3的元素：[TreeMap, TreeSet, HashSet, LinkedHashMap]===============================删除指定元素个数：1collections的内容：[TreeMap, TreeSet, HashSet, LinkedHashMap, WeakHashMap, Stack, Vector, ArrayList]删除下表0-3区间之外的元 素：OKcollections的内容：[TreeMap, TreeSet, HashSet, LinkedHashMap]collections列表出栈（左端）：TreeMapcollections的内容：[TreeSet, HashSet, LinkedHashMap]collections添加元素，从列表右端，与lpush相对 应：4collections的内容：[TreeSet, HashSet, LinkedHashMap, EnumMap]collections列表出栈（右 端）：EnumMapcollections的内容：[TreeSet, HashSet, LinkedHashMap]修改collections指定下标1的内容：OKcollections的内容：[TreeSet, LinkedArrayList, LinkedHashMap]===============================collections的长度：3获取collections下标为2的元素：LinkedHashMap===============================sortedList排序前：[4, 7, 0, 2, 6, 3][0, 2, 3, 4, 6, 7]sortedList排序后：[4, 7, 0, 2, 6, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="对Set的操作命令"><a href="#对Set的操作命令" class="headerlink" title="对Set的操作命令"></a>对Set的操作命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSet</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);        jedis.flushDB();        System.out.println(<span class="string">&quot;============向集合中添加元素（不重复============&quot;</span>);        System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>,<span class="string">&quot;e2&quot;</span>,<span class="string">&quot;e4&quot;</span>,<span class="string">&quot;e3&quot;</span>,<span class="string">&quot;e0&quot;</span>,<span class="string">&quot;e8&quot;</span>,<span class="string">&quot;e7&quot;</span>,<span class="string">&quot;e5&quot;</span>));        System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e6&quot;</span>));        System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e6&quot;</span>));        System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;删除一个元素e0：&quot;</span>+jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e0&quot;</span>));        System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;删除两个元素e7和e6：&quot;</span>+jedis.srem(<span class="string">&quot;eleSet&quot;</span>,                <span class="string">&quot;e7&quot;</span>,<span class="string">&quot;e6&quot;</span>));        System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;随机的移除集合中的一个元素：&quot;</span>+jedis.spop(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;随机的移除集合中的一个元素：&quot;</span>+jedis.spop(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span>+jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;eleSet中包含元素的个数：&quot;</span>+jedis.scard(<span class="string">&quot;eleSet&quot;</span>));        System.out.println(<span class="string">&quot;e3是否在eleSet中：&quot;</span>+jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e3&quot;</span>));        System.out.println(<span class="string">&quot;e1是否在eleSet中：&quot;</span>+jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>));        System.out.println(<span class="string">&quot;e1是否在eleSet中：&quot;</span>+jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e5&quot;</span>));        System.out.println(<span class="string">&quot;=================================&quot;</span>);        System.out.println(jedis.sadd(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;e1&quot;</span>,<span class="string">&quot;e2&quot;</span>,<span class="string">&quot;e4&quot;</span>,<span class="string">&quot;e3&quot;</span>,<span class="string">&quot;e0&quot;</span>,<span class="string">&quot;e8&quot;</span>,<span class="string">&quot;e7&quot;</span>,<span class="string">&quot;e5&quot;</span>));        System.out.println(jedis.sadd(<span class="string">&quot;eleSet2&quot;</span>, <span class="string">&quot;e1&quot;</span>,<span class="string">&quot;e2&quot;</span>,<span class="string">&quot;e4&quot;</span>,<span class="string">&quot;e3&quot;</span>,<span class="string">&quot;e0&quot;</span>,<span class="string">&quot;e8&quot;</span>));        System.out.println(<span class="string">&quot;将eleSet1中删除e1并存入eleSet3 中：&quot;</span>+jedis.smove(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet3&quot;</span>, <span class="string">&quot;e1&quot;</span>));<span class="comment">//移到集合元素        System.out.println(&quot;将eleSet1中删除e2并存入eleSet3 中：&quot;+jedis.smove(&quot;eleSet1&quot;, &quot;eleSet3&quot;, &quot;e2&quot;));        System.out.println(&quot;eleSet1中的元素：&quot;+jedis.smembers(&quot;eleSet1&quot;));        System.out.println(&quot;eleSet3中的元素：&quot;+jedis.smembers(&quot;eleSet3&quot;));        System.out.println(&quot;============集合运算=================&quot;);        System.out.println(&quot;eleSet1中的元素：&quot;+jedis.smembers(&quot;eleSet1&quot;));        System.out.println(&quot;eleSet2中的元素：&quot;+jedis.smembers(&quot;eleSet2&quot;));        System.out.println(&quot;eleSet1和eleSet2的交集:&quot;+jedis.sinter(&quot;eleSet1&quot;,&quot;eleSet2&quot;));        System.out.println(&quot;eleSet1和eleSet2的并集:&quot;+jedis.sunion(&quot;eleSet1&quot;,&quot;eleSet2&quot;));        System.out.println(&quot;eleSet1和eleSet2的差集:&quot;+jedis.sdiff(&quot;eleSet1&quot;,&quot;eleSet2&quot;));//eleSet1中有，eleSet2中没有        jedis.sinterstore(&quot;eleSet4&quot;,&quot;eleSet1&quot;,&quot;eleSet2&quot;);//求交集并将交集保存到dstkey的集合        System.out.println(&quot;eleSet4中的元素：&quot;+jedis.smembers(&quot;eleSet4&quot;));    &#125;&#125;#运行结果============向集合中添加元素（不重复============810eleSet的所有元素为：[e1, e8, e0, e5, e7, e2, e3, e6, e4]删除一个元素e0：1eleSet的所有元素为：[e8, e5, e7, e2, e3, e6, e4, e1]删除两个元素e7和e6：2eleSet的所有元素为：[e2, e3, e4, e1, e8, e5]随机的移除集合中的一个元素：e4随机的移除集合中的一个元素：e8eleSet的所有元素为：[e3, e2, e1, e5]eleSet中包含元素的个数：4e3是否在eleSet中：truee1是否在eleSet中：truee1是否在eleSet中：true=================================86将eleSet1中删除e1并存入eleSet3 中：1将eleSet1中删除e2并存入eleSet3 中：1eleSet1中的元素：[e4, e8, e0, e5, e7, e3]eleSet3中的元素：[e1, e2]============集合运算=================eleSet1中的元素：[e4, e8, e0, e5, e7, e3]eleSet2中的元素：[e1, e3, e2, e4, e8, e0]eleSet1和eleSet2的交 集:[e3, e4, e8, e0]eleSet1和eleSet2的并 集:[e8, e0, e5, e7, e2, e3, e4, e1]eleSet1和eleSet2的差 集:[e7, e5]eleSet4中的元素：[e0, e8, e4, e3]</span></span><br></pre></td></tr></table></figure>

<h3 id="对Hash的操作命令"><a href="#对Hash的操作命令" class="headerlink" title="对Hash的操作命令"></a>对Hash的操作命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHash</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);        jedis.flushDB();        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);        map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);        map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);        map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);        <span class="comment">//添加名称为hash（key）的hash元素        jedis.hmset(&quot;hash&quot;,map);        //向名称为hash的hash中添加key为key5，value为value5元素        jedis.hset(&quot;hash&quot;, &quot;key5&quot;, &quot;value5&quot;);        System.out.println(&quot;散列hash的所有键值对为：&quot;+jedis.hgetAll(&quot;hash&quot;));//return Map&lt;String,String&gt;        System.out.println(&quot;散列hash的所有键为：&quot;+jedis.hkeys(&quot;hash&quot;));//returnSet&lt;String&gt;        System.out.println(&quot;散列hash的所有值为：&quot;+jedis.hvals(&quot;hash&quot;));//returnList&lt;String&gt;        System.out.println(&quot;将key6保存的值加上一个整数，如果key6不存在则添加 key6：&quot;+jedis.hincrBy(&quot;hash&quot;, &quot;key6&quot;, 6));        System.out.println(&quot;散列hash的所有键值对为：&quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;将key6保存的值加上一个整数，如果key6不存在则添加 key6：&quot;+jedis.hincrBy(&quot;hash&quot;, &quot;key6&quot;, 3));        System.out.println(&quot;散列hash的所有键值对为：&quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;删除一个或者多个键值对：&quot;+jedis.hdel(&quot;hash&quot;, &quot;key2&quot;));        System.out.println(&quot;散列hash的所有键值对为：&quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;散列hash中键值对的个数：&quot;+jedis.hlen(&quot;hash&quot;));        System.out.println(&quot;判断hash中是否存在 key2：&quot;+jedis.hexists(&quot;hash&quot;,&quot;key2&quot;));        System.out.println(&quot;判断hash中是否存在 key3：&quot;+jedis.hexists(&quot;hash&quot;,&quot;key3&quot;));        System.out.println(&quot;获取hash中的值：&quot;+jedis.hmget(&quot;hash&quot;,&quot;key3&quot;));        System.out.println(&quot;获取hash中的值：&quot;+jedis.hmget(&quot;hash&quot;,&quot;key3&quot;,&quot;key4&quot;));    &#125;&#125;#运行结果散列hash的所有键值对为：&#123;key1=value1, key2=value2, key5=value5, key3=value3, key4=value4&#125;散列hash的所有键为：[key1, key2, key5, key3, key4]散列hash的所有值为：[value4, value1, value2, value3, value5]将key6保存的值加上一个整数，如果key6不存在则添加 key6：6散列hash的所有键值对为：&#123;key1=value1, key2=value2, key5=value5, key6=6, key3=value3, key4=value4&#125;将key6保存的值加上一个整数，如果key6不存在则添加 key6：9散列hash的所有键值对为：&#123;key1=value1, key2=value2, key5=value5, key6=9, key3=value3, key4=value4&#125;删除一个或者多个键值对：1散列hash的所有键值对为：&#123;key1=value1, key5=value5, key6=9, key3=value3, key4=value4&#125;散列hash中键值对的个数：5判断hash中是否存在 key2：false判断hash中是否存在 key3：true获取hash中的值：[value3]获取hash中的值：[value3, value4]    </span></span><br></pre></td></tr></table></figure>

<h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><blockquote>
<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//创建客户端连接服务端，redis服务端需要被开启        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        JSONObject jsonObject = new JSONObject();        jsonObject.put(&quot;hello&quot;, &quot;world&quot;);        jsonObject.put(&quot;name&quot;, &quot;java&quot;);        //开启事务        Transaction multi = jedis.multi();        String result = jsonObject.toJSONString();        /*jedis.watch(result)&#123;            //乐观锁        &#125;*/        try&#123;        //向redis存入一条数据            multi.set(&quot;json&quot;, result);        //再存入一条数据            multi.set(&quot;json2&quot;, result);        //这里引发了异常，用0作为被除数            int i = 100/0;        //如果没有引发异常，执行进入队列的命令            multi.exec();        &#125;catch(Exception e)&#123;            e.printStackTrace();        //如果出现异常，回滚            multi.discard();        &#125;finally&#123;            System.out.println(jedis.get(&quot;json&quot;));            System.out.println(jedis.get(&quot;json2&quot;));        //最终关闭客户端            jedis.close();        &#125;    &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><blockquote>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。那么使用SpringBoot整合Redis需要那些步骤呢？</p>
<p>1、 <strong>JedisPoolConfig</strong> (这个是配置连接池)<br>2、 <strong>RedisConnectionFactory</strong> 这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在    SpringData Redis方案中提供了以下四种工厂模型：</p>
<ul>
<li>JredisConnectionFactory</li>
<li>JedisConnectionFactory</li>
<li>LettuceConnectionFactory</li>
<li>SrpConnectionFactory  </li>
</ul>
<p><strong>说明</strong>：在springBoot2.x之后，原来使用的jedis被替换为了lettuce</p>
<ul>
<li>jedis:采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全，使用jedis Pool连接池！更像BIO模式</li>
<li>lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况!可以减少线程数据，更像NIO模式</li>
</ul>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>    <span class="meta">@ConditionalOnMissingBean(        name = &#123;&quot;redisTemplate&quot;&#125;//我们自定义redisTemplate来替换默认的    )</span>    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span>    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;       <span class="comment">//默认的RedisTemplate没有过多的设置，redis对象都是需要序列化！        //两个泛型都是Object, Object的类型，我们需要强制转换&lt;String, Object&gt;        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        return template;    &#125;    @Bean    @ConditionalOnMissingBean//由于String是redis中最长使用的类型，所以说单独提出来了一个Bean    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        StringRedisTemplate template = new StringRedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        return template;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>3、 RedisTemplate 基本操作  </p>
<img src="Redis.assets/image-20210627221345387.png" alt="image-20210627221345387" style="zoom:67%;" />

<blockquote>
<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="yaml配置"><a href="#yaml配置" class="headerlink" title="yaml配置"></a>yaml配置</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.host=<span class="number">127.0</span><span class="number">.0</span>.1spring.redis.port=6379spring.redis.jedis.pool.max-active=8spring.redis.jedis.pool.max-wait=-1msspring.redis.jedis.pool.max-idle=500spring.redis.jedis.pool.min-idle=0spring.redis.lettuce.shutdown-timeout=0ms</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#JedisConnectionFactory不生效<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionFactory</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">RedisConnectionFactory</span> </span>&#123;   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory.getLog(JedisConnectionFactory.class);   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExceptionTranslationStrategy EXCEPTION_TRANSLATION = <span class="keyword">new</span> PassThroughExceptionTranslationStrategy(         JedisConverters.exceptionConverter());   <span class="keyword">private</span> <span class="keyword">final</span> JedisClientConfiguration clientConfiguration;   <span class="keyword">private</span> <span class="meta">@Nullable</span> JedisShardInfo shardInfo;   <span class="keyword">private</span> JedisClientConfig clientConfig = DefaultJedisClientConfig.builder().build();   <span class="keyword">private</span> <span class="keyword">boolean</span> providedShardInfo = <span class="keyword">false</span>;   <span class="keyword">private</span> <span class="meta">@Nullable</span> Pool&lt;Jedis&gt; pool;   <span class="keyword">private</span> <span class="keyword">boolean</span> convertPipelineAndTxResults = <span class="keyword">true</span>;   <span class="keyword">private</span> RedisStandaloneConfiguration standaloneConfig = <span class="keyword">new</span> RedisStandaloneConfiguration(<span class="string">&quot;localhost&quot;</span>,         Protocol.DEFAULT_PORT);   <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisConfiguration configuration;   <span class="keyword">private</span> <span class="meta">@Nullable</span> JedisCluster cluster;   <span class="keyword">private</span> <span class="meta">@Nullable</span> ClusterTopologyProvider topologyProvider;    #LettuceConnectionFactory生效<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceConnectionFactory</span>		<span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">RedisConnectionFactory</span>, <span class="title">ReactiveRedisConnectionFactory</span> </span>&#123;	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExceptionTranslationStrategy EXCEPTION_TRANSLATION = <span class="keyword">new</span> PassThroughExceptionTranslationStrategy(			LettuceConverters.exceptionConverter());	<span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());	<span class="keyword">private</span> <span class="keyword">final</span> LettuceClientConfiguration clientConfiguration;	<span class="keyword">private</span> <span class="meta">@Nullable</span> AbstractRedisClient client;	<span class="keyword">private</span> <span class="meta">@Nullable</span> LettuceConnectionProvider connectionProvider;	<span class="keyword">private</span> <span class="meta">@Nullable</span> LettuceConnectionProvider reactiveConnectionProvider;	<span class="keyword">private</span> <span class="keyword">boolean</span> validateConnection = <span class="keyword">false</span>;	<span class="keyword">private</span> <span class="keyword">boolean</span> shareNativeConnection = <span class="keyword">true</span>;	<span class="keyword">private</span> <span class="keyword">boolean</span> eagerInitialization = <span class="keyword">false</span>;	<span class="keyword">private</span> <span class="meta">@Nullable</span> SharedConnection&lt;<span class="keyword">byte</span>[]&gt; connection;	<span class="keyword">private</span> <span class="meta">@Nullable</span> SharedConnection&lt;ByteBuffer&gt; reactiveConnection;	<span class="keyword">private</span> <span class="meta">@Nullable</span> LettucePool pool;	<span class="comment">/** Synchronization monitor for the shared Connection */</span>	<span class="keyword">private</span> <span class="keyword">final</span> Object connectionMonitor = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTestclass</span> Redis02SpringbootApplicationTests &#123;	<span class="meta">@Autowired</span>	<span class="keyword">private</span> RedisTemplate redisTemplate;	<span class="meta">@Test</span>	<span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;		<span class="comment">//redisTemplate	操作不同的数据类型，api和指令一样		//opsForValue	操作字符串 类似String		//opsForSet()		//opsForHash()		//除了基本操作，常用的方法都可以通过redisTemplate来操作		//获取redis的连接对象		/*RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();		connection.flushDb();*/		redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;hello&quot;);		System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;));	&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h2><p>1、新建一个SpringBoot项目</p>
<p>2、导入redis的启动器  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3、配置redis，可以查看 RedisProperties 分析  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis服务器地址spring.redis.host=127.0.0.1# Redis服务器连接端口spring.redis.port=6379</span></span><br></pre></td></tr></table></figure>

<p>4、分析 RedisAutoConfiguration 自动配置类  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(    proxyBeanMethods = false)</span><span class="meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><span class="meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">RedisAutoConfiguration</span><span class="params">()</span> </span>&#123;    &#125;    <span class="meta">@Bean</span>    <span class="meta">@ConditionalOnMissingBean(        name = &#123;&quot;redisTemplate&quot;&#125;    )</span>    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span>    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        <span class="keyword">return</span> template;    &#125;    <span class="meta">@Bean</span>    <span class="meta">@ConditionalOnMissingBean</span>    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span>    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();        template.setConnectionFactory(redisConnectionFactory);        <span class="keyword">return</span> template;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。但是，这个RedisTemplate的泛型是&lt;Object,Object&gt;，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为&lt;String,Object&gt;形式的RedisTemplate。并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置RedisTemplate。  </p>
<p>5、既然自动配置不好用，就重新配置一个RedisTemplate  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;		<span class="comment">//真实的开发一般都使用json来传递对象		User user = new User(&quot;hello&quot;, 3);		//jackson帮我们实现序列化,直接使用对象会报序列化错误，对象必须序列化		String json = new ObjectMapper().writeValueAsString(user);		redisTemplate.opsForValue().set(user,json);	&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义RedisTemplate@Configurationpublic class RedisConfig &#123;    @Bean    @SuppressWarnings(&quot;all&quot;)    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        //自己开发方便&lt;String, Object&gt;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();        //连接工厂        template.setConnectionFactory(factory);        //序列化配置        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        //String的序列化配置        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        // key采用String的序列化方式        template.setKeySerializer(stringRedisSerializer);        // hash的key也采用String的序列化方式template.setHashKeySerializer(stringRedisSerializer);        // value序列化方式采用jackson        template.setValueSerializer(jackson2JsonRedisSerializer);        // hash的value序列化方式采用jackson        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;		<span class="comment">//真实的开发一般都使用json来传递对象		User user = new User(&quot;hello&quot;, 3);		//jackson帮我们实现序列化,直接使用对象会报序列化错误，对象必须序列化		//String json = new ObjectMapper().writeValueAsString(user);		redisTemplate.opsForValue().set(&quot;user&quot;,user);		//redisTemplate实现序列化		System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;));	&#125;127.0.0.1:6379&gt; keys *1) &quot;user&quot;</span></span><br></pre></td></tr></table></figure>

<p>6、写一个Redis工具类（直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。）  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.redis.utils;<span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> org.springframework.util.CollectionUtils;<span class="keyword">import</span> javax.annotation.Resource;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.Map;<span class="keyword">import</span> java.util.Set;<span class="keyword">import</span> java.util.concurrent.TimeUnit;<span class="comment">/** * <span class="doctag">@Author</span> liuhy * <span class="doctag">@Description</span>: redis工具类 * <span class="doctag">@Date</span> 2021-06-28 下午 03:07 */</span><span class="meta">@Componentpublic</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;    <span class="comment">/**     * Resource默认是按照名称来装配注入的     * Autowired默认是按照类型装配注入的，如果想按照名称来转配注入，则需要结合<span class="doctag">@Qualifier</span>一起使用     */</span><span class="comment">//    @Autowired//    @Qualifier(&quot;redisTemplate&quot;)    @Resource    private RedisTemplate&lt;String, Object&gt; redisTemplate;    // =============================common============================    /**     * 指定缓存失效时间     * @param key  键     * @param time 时间(秒)     * @return     */    public boolean expire(String key, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.expire(key, time, TimeUnit.SECONDS);            &#125;            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 根据key 获取过期时间     * @param key 键 不能为null     * @return 时间(秒) 返回0代表为永久有效     */    public long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    /**     * 判断key是否存在     * @param key 键     * @return true 存在 false不存在     */    public boolean hasKey(String key) &#123;        try &#123;            return redisTemplate.hasKey(key);        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 删除缓存     * @param key 可以传一个值 或多个     */    @SuppressWarnings(&quot;unchecked&quot;)    public void del(String... key) &#123;        if (key != null &amp;&amp; key.length &gt; 0) &#123;            if (key.length == 1) &#123;                redisTemplate.delete(key[0]);            &#125; else &#123;                redisTemplate.delete(String.valueOf(CollectionUtils.arrayToList(key)));            &#125;        &#125;    &#125;    // ============================String=============================    /**     * 普通缓存获取     * @param key 键     * @return 值     */    public Object get(String key) &#123;        return key == null ? null : redisTemplate.opsForValue().get(key);    &#125;    /**     * 普通缓存放入     * @param key   键     * @param value 值     * @return true成功 false失败     */    public boolean set(String key, Object value) &#123;        try &#123;            redisTemplate.opsForValue().set(key, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 普通缓存放入并设置时间     * @param key   键     * @param value 值     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期     * @return true成功 false 失败     */    public boolean set(String key, Object value, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125; else &#123;                set(key, value);            &#125;            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 递增     * @param key   键     * @param delta 要增加几(大于0)     * @return     */    public long incr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递增因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    /**     * 递减     * @param key   键     * @param delta 要减少几(小于0)     * @return     */    public long decr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递减因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    // ================================Map=================================    /**     * HashGet     * @param key  键 不能为null     * @param item 项 不能为null     * @return 值     */    public Object hget(String key, String item) &#123;        return redisTemplate.opsForHash().get(key, item);    &#125;    /**     * 获取hashKey对应的所有键值     * @param key 键     * @return 对应的多个键值     */    public Map&lt;Object, Object&gt; hmget(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    /**     * HashSet     * @param key 键     * @param map 对应多个键值     * @return true 成功 false 失败     */    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * HashSet 并设置时间     * @param key  键     * @param map  对应多个键值     * @param time 时间(秒)     * @return true成功 false失败     */    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     * @param key   键     * @param item  项     * @param value 值     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     * @param key   键     * @param item  项     * @param value 值     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value, long time) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 删除hash表中的值     * @param key  键 不能为null     * @param item 项 可以使多个 不能为null     */    public void hdel(String key, Object... item) &#123;        redisTemplate.opsForHash().delete(key, item);    &#125;    /**     * 判断hash表中是否有该项的值     * @param key  键 不能为null     * @param item 项 不能为null     * @return true 存在 false不存在     */    public boolean hHasKey(String key, String item) &#123;        return redisTemplate.opsForHash().hasKey(key, item);    &#125;    /**     * hash递增 如果不存在,就会创建一个 并把新增后的值返回     * @param key  键     * @param item 项     * @param by   要增加几(大于0)     * @return     */    public double hincr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, by);    &#125;    /**     * hash递减     * @param key  键     * @param item 项     * @param by   要减少记(小于0)     * @return     */    public double hdecr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, -by);    &#125;    // ============================set=============================    /**     * 根据key获取Set中的所有值     * @param key 键     * @return     */    public Set&lt;Object&gt; sGet(String key) &#123;        try &#123;            return redisTemplate.opsForSet().members(key);        &#125; catch (Exception e) &#123;            return null;        &#125;    &#125;    /**     * 根据value从一个set中查询,是否存在     * @param key   键     * @param value 值     * @return true 存在 false不存在     */    public boolean sHasKey(String key, Object value) &#123;        try &#123;            return redisTemplate.opsForSet().isMember(key, value);        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 将数据放入set缓存     * @param key    键     * @param values 值 可以是多个     * @return 成功个数     */    public long sSet(String key, Object... values) &#123;        try &#123;            return redisTemplate.opsForSet().add(key, values);        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    /**     * 将set数据放入缓存     * @param key    键     * @param time   时间(秒)     * @param values 值 可以是多个     * @return 成功个数     */    public long sSetAndTime(String key, long time, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().add(key, values);            if (time &gt; 0)                expire(key, time);            return count;        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    /**     * 获取set缓存的长度     * @param key 键     * @return 358     */    public long sGetSetSize(String key) &#123;        try &#123;            return redisTemplate.opsForSet().size(key);        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    /**     * 移除值为value的     * @param key    键     * @param values 值 可以是多个     * @return 移除的个数     */    public long setRemove(String key, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().remove(key, values);            return count;        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    // ===============================list=================================    /**     * 获取list缓存的内容     * @param key   键     * @param start 开始     * @param end   结束 0 到 -1代表所有值     * @return     */    public List&lt;Object&gt; lGet(String key, long start, long end) &#123;        try &#123;            return redisTemplate.opsForList().range(key, start, end);        &#125; catch (Exception e) &#123;            return null;        &#125;    &#125;    /**     * 获取list缓存的长度     * @param key 键     * @return     */    public long lGetListSize(String key) &#123;        try &#123;            return redisTemplate.opsForList().size(key);        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;    /**     * 通过索引 获取list中的值     * @param key   键     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，     *              依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推     * @return     */    public Object lGetIndex(String key, long index) &#123;        try &#123;            return redisTemplate.opsForList().index(key, index);        &#125; catch (Exception e) &#123;            return null;        &#125;    &#125;    /**     * 将list放入缓存     * @param key   键     * @param value 值     * @return     */    public boolean lSet(String key, Object value) &#123;        try &#123;            redisTemplate.opsForList().rightPush(key, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */    public boolean lSet(String key, Object value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPush(key, value);            if (time &gt; 0)                expire(key, time);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 将list放入缓存     * @param key   键     * @param value 值     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 将list放入缓存     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            if (time &gt; 0)                expire(key, time);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 根据索引修改list中的某条数据     * @param key   键     * @param index 索引     * @param value 值     * @return     */    public boolean lUpdateIndex(String key, long index, Object value) &#123;        try &#123;            redisTemplate.opsForList().set(key, index, value);            return true;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;    /**     * 移除N个值为value     * @param key   键     * @param count 移除多少个     * @param value 值     * @return 移除的个数     */    public long lRemove(String key, long count, Object value) &#123;        try &#123;            Long remove = redisTemplate.opsForList().remove(key, count, value);            return remove;        &#125; catch (Exception e) &#123;            return 0;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>7.测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>	<span class="keyword">private</span> RedisUtil redisUtil;	<span class="meta">@Test</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;		redisUtil.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hello,world&quot;</span>);		System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="Units-单位"><a href="#Units-单位" class="headerlink" title="Units 单位"></a>Units 单位</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis configuration file example.## Note that in order to read the configuration file, Redis must be# started with the file path as first argument:## ./redis-server /path/to/redis.conf# Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br></pre></td></tr></table></figure>

<p>​    1、配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>​    2、对大小写不敏感  </p>
<h3 id="INCLUDES-包含"><a href="#INCLUDES-包含" class="headerlink" title="INCLUDES 包含"></a>INCLUDES 包含</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## INCLUDES #################################### Include one or more other config files here.  This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings.  Include files can include# other files, so use this wisely.## Note that option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you&#x27;d better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf</span></span><br></pre></td></tr></table></figure>

<p>和Spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！  </p>
<h3 id="NETWORK-网络配置"><a href="#NETWORK-网络配置" class="headerlink" title="NETWORK 网络配置"></a>NETWORK 网络配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment"># 绑定的ipprotected-mode yes # 保护模式port 6379 # 默认端口1 2 3</span></span><br></pre></td></tr></table></figure>

<h3 id="GENERAL-通用"><a href="#GENERAL-通用" class="headerlink" title="GENERAL 通用"></a>GENERAL 通用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes <span class="comment"># 默认情况下，Redis不作为守护进程运行。需要开启的话，改为 yessupervised no # 可通过upstart和systemd管理Redis守护进程pidfile /var/run/redis_6379.pid # 以后台进程方式运行redis，则需要指定pid 文件loglevel notice # 日志级别。可选项有：# debug（记录大量日志信息，适用于开发、测试阶段）；# verbose（较多日志信息）；# notice（适量日志信息，使用于生产环境）；# warning（仅有部分重要、关键信息才会被记录）。logfile &quot;&quot; # 日志文件的位置，当指定为空字符串时，为标准输出databases 16 # 设置数据库的数目。默认的数据库是DB 0always-show-logo yes # 是否总是显示logo</span></span><br></pre></td></tr></table></figure>

<h3 id="SNAPSHOPTING-快照"><a href="#SNAPSHOPTING-快照" class="headerlink" title="SNAPSHOPTING 快照"></a>SNAPSHOPTING 快照</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）save 900 1# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）save 300 10# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）save 60 10000stop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作rdbcompression yes # 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间rdbchecksum yes # 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗dbfilename dump.rdb # dbfilenamerdb文件名称dir ./ # dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span></span><br></pre></td></tr></table></figure>

<h3 id="REPLICATION-复制"><a href="#REPLICATION-复制" class="headerlink" title="REPLICATION 复制"></a>REPLICATION 复制</h3><h3 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h3><p>访问密码的查看，设置和取消  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动redis# 连接客户端# 获得和设置密码config get requirepassconfig set requirepass &quot;123456&quot;#测试ping，发现需要验证127.0.0.1:6379&gt; pingNOAUTH Authentication required.# 验证127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; pingPONG</span></span><br></pre></td></tr></table></figure>

<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000 <span class="comment"># 设置能连上redis的最大客户端连接数量maxmemory &lt;bytes&gt; # redis配置的最大内存容量maxmemory-policy noeviction # maxmemory-policy 内存达到上限的处理策略#volatile-lru：利用LRU算法移除设置过过期时间的key。#volatile-random：随机移除设置过过期时间的key。#volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）#allkeys-lru：利用LRU算法移除任何key。#allkeys-random：随机移除任何key。#noeviction：不移除任何key，只是返回一个写错误。</span></span><br></pre></td></tr></table></figure>

<h3 id="append-only模式-AOF配置"><a href="#append-only模式-AOF配置" class="headerlink" title="append only模式  [AOF配置]"></a>append only模式  [AOF配置]</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment">#默认不开启，是否以append only模式作为持久化方式，默认使用是rdb方式持久化，这种方式在许多应用中已经足够用了appendfilename &quot;appendonly.aof&quot; # appendfilename AOF 文件名称appendfsync everysec # appendfsync aof持久化策略的配置# no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。# always表示每次写入都执行fsync，以保证数据同步到磁盘。# everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br></pre></td></tr></table></figure>

<h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1、Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程  </span><br><span class="line">	daemonize no </span><br><span class="line">2、当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定  </span><br><span class="line">	pidfile /var/run/redis.pid    </span><br><span class="line">3、指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字  </span><br><span class="line">	port 6379  </span><br><span class="line">4、绑定的主机地址  </span><br><span class="line">	<span class="built_in">bind</span> 127.0.0.1  </span><br><span class="line">5、当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class="line">	timeout 300</span><br><span class="line">6、指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class="line">	loglevel verbose</span><br><span class="line">7、日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class="line">	logfile stdout</span><br><span class="line">8、设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</span><br><span class="line">	databases 16</span><br><span class="line">9、指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line">    save</span><br><span class="line">    Redis默认配置文件中提供了三个条件：</span><br><span class="line">    save 900 1</span><br><span class="line">    save 300 10</span><br><span class="line">    save 60 10000</span><br><span class="line">分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class="line">10、指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class="line">	rdbcompression yes</span><br><span class="line">11、指定本地数据库文件名，默认值为dump.rdb</span><br><span class="line">	dbfilename dump.rdb</span><br><span class="line">12、指定本地数据库存放目录</span><br><span class="line">	dir ./</span><br><span class="line">13、设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class="line">	slaveof</span><br><span class="line">14、当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class="line">	masterauth</span><br><span class="line">15、设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭</span><br><span class="line">	requirepass foobared</span><br><span class="line">16、设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class="line">	maxclients 128</span><br><span class="line">17、指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class="line">	maxmemory</span><br><span class="line">18、指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class="line">	appendonly no</span><br><span class="line">19、指定更新日志文件名，默认为appendonly.aof</span><br><span class="line">	appendfilename appendonly.aof</span><br><span class="line">20、指定更新日志条件，共有3个可选值：</span><br><span class="line">    no：表示等操作系统进行数据缓存同步到磁盘（快）</span><br><span class="line">    always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</span><br><span class="line">    everysec：表示每秒同步一次（折衷，默认值）</span><br><span class="line">    appendfsync everysec</span><br><span class="line">21、指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章会仔细分析Redis的VM机制）</span><br><span class="line">	vm-enabled no</span><br><span class="line">22、虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class="line">	vm-swap-file /tmp/redis.swap</span><br><span class="line">23、将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class="line">	vm-max-memory 0</span><br><span class="line">24、Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class="line">	vm-page-size 32</span><br><span class="line">25、设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class="line">	vm-pages 134217728</span><br><span class="line">26、设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span><br><span class="line">	vm-max-threads 4</span><br><span class="line">27、设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class="line">	glueoutputbuf yes</span><br><span class="line">28、指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class="line">	hash-max-zipmap-entries 64</span><br><span class="line">	hash-max-zipmap-value 512</span><br><span class="line">29、指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class="line">	activerehashing yes</span><br><span class="line">30、指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class="line">	include /path/to/local.conf</span><br></pre></td></tr></table></figure>

<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>​        Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！  </p>
<h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote>
<h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3></blockquote>
<p>​        在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p>​        Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p>
<p>​        RDB的缺点是最后一次持久化后的数据可能丢失。  </p>
<img src="Redis.assets/image-20210628141721740.png" alt="image-20210628141721740" style="zoom: 67%;" />

<blockquote>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3></blockquote>
<p>​        Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。  </p>
<p>​        <strong>Rdb 保存的是 dump.rdb 文件</strong>  </p>
<img src="Redis.assets/image-20210628122207250.png" alt="image-20210628122207250" style="zoom:67%;" />

<blockquote>
<h3 id="配置位置及SNAPSHOTTING解析"><a href="#配置位置及SNAPSHOTTING解析" class="headerlink" title="配置位置及SNAPSHOTTING解析"></a>配置位置及SNAPSHOTTING解析</h3></blockquote>
<img src="Redis.assets/image-20210628122426501.png" alt="image-20210628122426501" style="zoom:67%;" />

<p>这里的触发条件机制，我们可以修改测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 5 # 120秒内修改10次则触发RDB</span><br></pre></td></tr></table></figure>

<p>RDB 是整合内存的压缩过的Snapshot，RDB 的数据结构，可以配置复合的快照触发条件。</p>
<p>如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效 !  </p>
<blockquote>
<h3 id="其余命令解析"><a href="#其余命令解析" class="headerlink" title="其余命令解析"></a>其余命令解析</h3></blockquote>
<p><strong>Stop-writes-on-bgsave-error：</strong>如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制，默认为yes。<br><strong>rbdcompression：</strong>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩，如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。<br><strong>rdbchecksum：</strong>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为yes。  </p>
<blockquote>
<h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3></blockquote>
<p>1、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb<br>2、命令save或者是bgsave，save 时只管保存，其他不管，全部阻塞bgsave，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。<br>3、执行flushall命令，也会产生 dump.rdb 文件，但里面是空的，无意义 !<br>4、退出的时候也会产生 dump.rdb 文件！  </p>
<p>​    备份就会自动生成一个dump.rdb文件</p>
<blockquote>
<h3 id="恢复rdb文件"><a href="#恢复rdb文件" class="headerlink" title="恢复rdb文件"></a>恢复rdb文件</h3></blockquote>
<p>1、将备份文件（dump.rdb）移动到redis安装目录并启动服务即可<br>2、CONFIG GET dir 获取目录  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">dir</span><br><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3></blockquote>
<p>==<strong>优点：</strong>==<br>        1、适合大规模的数据恢复<br>        2、对数据完整性和一致性要求不高  </p>
<p><strong>==缺点：==</strong><br>        1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改<br>        2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。  </p>
<blockquote>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3></blockquote>
<img src="Redis.assets/image-20210628142342673.png" alt="image-20210628142342673" style="zoom:67%;" />

<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><blockquote>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3></blockquote>
<p>​        将我们的所有命令都记录下来，以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件，但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作<br>​        Aof保存的是 appendonly.aof 文件。</p>
<img src="Redis.assets/image-20210628170401516.png" alt="image-20210628170401516" style="zoom:67%;" />

<blockquote>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment"># 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这种方式在许多应用中已经足够用了</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># appendfilename AOF 文件名称</span></span><br><span class="line">appendfsync everysec <span class="comment"># appendfsync aof持久化策略的配置</span></span><br><span class="line"><span class="comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span></span><br><span class="line"><span class="comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span></span><br><span class="line"><span class="comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br><span class="line">No-appendfsync-on-rewrite <span class="comment">#重写时是否可以运用Appendfsync，用默认no即可，保证数据安</span></span><br><span class="line">全性</span><br><span class="line">Auto-aof-rewrite-min-size <span class="comment"># 设置重写的基准值</span></span><br><span class="line">Auto-aof-rewrite-percentage <span class="comment">#设置重写的基准值</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="AOF-启动-修复-恢复"><a href="#AOF-启动-修复-恢复" class="headerlink" title="AOF 启动/修复/恢复"></a>AOF 启动/修复/恢复</h3></blockquote>
<p><strong>正常恢复：</strong></p>
<ul>
<li>启动：设置Yes，修改默认的appendonly no，改为yes<br>将有数据的aof文件复制一份保存到对应目录（config get dir）</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
<p><strong>异常恢复</strong>：</p>
<ul>
<li>启动：设置Yes</li>
<li>故意破坏 appendonly.aof 文件！</li>
<li>修复： ==redis-check-aof –fix appendonly.aof== 进行修复</li>
<li>恢复：重启 redis 然后重新加载  </li>
</ul>
<blockquote>
<h3 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h3></blockquote>
<p><strong>是什么：</strong><br>        AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis 就会启动AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 bgrewriteaof ！<br><strong>重写原理：</strong></p>
<p>​        AOF 文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，这点和快照有点类似！<br><strong>触发机制：</strong><br>​        Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的已被且文件大于64M的触发。</p>
<blockquote>
<h3 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h3></blockquote>
<p><strong>==优点：==</strong><br>        1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好<br>        2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失<br>        3、不同步： appendfsync no 从不同步<br><strong>==缺点：==</strong><br>        1、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。<br>        2、Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和rdb相同。  </p>
<blockquote>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3></blockquote>
<img src="Redis.assets/image-20210628144610788.png" alt="image-20210628144610788" style="zoom:67%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储<br>2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。<br>3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化<br>4、同时开启两种持久化方式</p>
<ul>
<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li>
</ul>
<p>5、性能建议</p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。</li>
<li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。  </li>
</ul>
<h1 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种==消息通信模式==：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。  </p>
<img src="Redis.assets/image-20210628190846144.png" alt="image-20210628190846144" style="zoom:67%;" />

<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：  </p>
<img src="Redis.assets/image-20210628190934926.png" alt="image-20210628190934926" style="zoom:67%;" />

<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：  </p>
<img src="Redis.assets/image-20210628191040701.png" alt="image-20210628191040701" style="zoom:67%;" />

<blockquote>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3></blockquote>
<p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。  </p>
<img src="Redis.assets/image-20210628191135462.png" alt="image-20210628191135462" style="zoom: 80%;" />

<blockquote>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3></blockquote>
<p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class="string">&quot;Hello,Redis&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 订阅者的客户端会显示如下消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3) <span class="string">&quot;Hello,Redis&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line">3) <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></blockquote>
<p>​        Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。       SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。<br>​        使用场景：</p>
<ul>
<li>Pub/Sub构建实时消息系统</li>
<li>Redis的Pub/Sub系统可以构建实时的消息系统</li>
<li>比如很多用Pub/Sub构建的实时聊天系统的例子。  </li>
</ul>
<h1 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。**==Master以写为主，Slave 以读为主。==<strong>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。<br>​        主从复制的作用主要包括：<br>​                1、</strong>数据冗余：**主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。  </p>
<p>​                2、<strong>故障恢复：</strong>当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>
<p>​                3、<strong>负载均衡：</strong>在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连                        接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负                        载，可以大大提高Redis服务器的并发量。</p>
<p>​                4、<strong>高可用基石：</strong>除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。  </p>
<p>​        一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：<br>​            1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；<br>​            2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般    来说，单台Redis最大使用内存不应该超过20G。电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。<br>​        对于这种场景，我们可以使如下这种架构  :</p>
<img src="Redis.assets/image-20210628192413232.png" alt="image-20210628192413232" style="zoom: 50%;" />

<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><blockquote>
<h3 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h3></blockquote>
<p>配从库不配主库，从库配置：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos bin]<span class="comment"># redis-server myredis/redis.conf </span></span><br><span class="line">[root@VM-0-4-centos bin]<span class="comment"># redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; info replication	<span class="comment"># 查看信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master	<span class="comment">#角色						</span></span><br><span class="line">connected_slaves:0	<span class="comment">#没有主机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:1731bad0ad9964f2e9bafcc11517928cc38b55fb</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line">slaveof 主库ip 主库端口 <span class="comment"># 配置主从</span></span><br></pre></td></tr></table></figure>

<p>每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件！  </p>
<blockquote>
<h3 id="修改配置文件！"><a href="#修改配置文件！" class="headerlink" title="修改配置文件！"></a>修改配置文件！</h3></blockquote>
<p>准备工作：我们配置主从复制，至少需要三个，一主二从！配置三个客户端！  </p>
<p>1、拷贝多个redis.conf 文件  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># cp redis.conf redis1.conf</span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># cp redis.conf redis2.conf</span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># cp redis.conf redis3.conf</span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># ls</span></span><br><span class="line">redis1.conf  redis2.conf  redis3.conf  redis.conf</span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># vim redis1.conf </span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># vim redis2.conf </span></span><br><span class="line">[root@VM-0-4-centos myredis]<span class="comment"># vim redis3.conf </span></span><br></pre></td></tr></table></figure>

<p>2、指定端口 6379，依次类推</p>
<p>3、开启daemonize yes</p>
<p>4、Pid文件名字 pidfile /var/run/redis_6379.pid , 依次类推</p>
<p>5、Log文件名字 logfile “6379.log” , 依次类推</p>
<p>6、Dump.rdb 名字 dbfilename dump6379.rdb , 依次类推  </p>
<p>上面都配置完毕后，3个服务通过3个不同的配置文件开启，我们的准备环境就OK 了！  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos bin]# redis-server myredis/redis1.conf </span><br><span class="line">[root@VM-0-4-centos bin]# redis-server myredis/redis2.conf </span><br><span class="line">[root@VM-0-4-centos bin]# redis-server myredis/redis3.conf </span><br><span class="line">[root@VM-0-4-centos bin]# ll</span><br><span class="line">total 21964</span><br><span class="line">-rw-r--r-- 1 root root      958 Jun 28 20:34 6379.log</span><br><span class="line">-rw-r--r-- 1 root root      958 Jun 28 20:35 6380.log</span><br><span class="line">-rw-r--r-- 1 root root      958 Jun 28 20:35 6381.log</span><br><span class="line">[root@VM-0-4-centos bin]# ps -ef|grep redis</span><br><span class="line">root      6635     1  0 20:34 ?        00:00:00 redis-server 127.0.0.1:6379</span><br><span class="line">root      6813     1  0 20:35 ?        00:00:00 redis-server 127.0.0.1:6380</span><br><span class="line">root      6925     1  0 20:35 ?        00:00:00 redis-server 127.0.0.1:6381</span><br><span class="line">root      7142 23419  0 20:36 pts/1    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure>

<h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><blockquote>
<h3 id="1、一主二从"><a href="#1、一主二从" class="headerlink" title="1、一主二从"></a>1、一主二从</h3></blockquote>
<p>1、环境初始化  </p>
<p>默认三个都是Master 主节点  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos bin]# redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">root@VM-0-4-centos bin]# redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">root@VM-0-4-centos bin]# redis-cli -p 6381</span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br></pre></td></tr></table></figure>

<p>2、配置为一个Master 两个Slave  ,一主（79）二从（80,81）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line"></span><br><span class="line"><span class="comment">#从机6380</span></span><br><span class="line">127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line"></span><br><span class="line"><span class="comment">#从机6381</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=126,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=126,lag=0</span><br></pre></td></tr></table></figure>

<p>这只是暂时的，不是永久的，永久的需要在配置文件中配置。</p>
<blockquote>
<h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3></blockquote>
<p>3、在主机设置值，在从机都可以取到！从机不能写值  </p>
<p>测试一：主机挂了，查看从机信息，主机恢复，再次查看信息<br>测试二：从机挂了，查看主机信息，从机恢复，查看从机信息  </p>
<p>如果是使用命令行，来配置主从，如果重启会变成主机！只要变为从机，立马就会从主机中获取值！</p>
<blockquote>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3></blockquote>
<p>​    Slave 启动成功连接到 master 后会发送一个sync同步，Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p>
<ul>
<li><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
</li>
<li><p>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行  </p>
</li>
</ul>
<blockquote>
<h3 id="2、层层链路"><a href="#2、层层链路" class="headerlink" title="2、层层链路"></a>2、层层链路</h3></blockquote>
<p>上一个Slave 可以是下一个slave 和 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 slave 作为了链条中下一个的master，可以有效减轻 master 的写压力！ </p>
<p><img src="Redis.assets/image-20210628211022643.png" alt="image-20210628211022643"> </p>
<img src="Redis.assets/image-20210628211048900.png" alt="image-20210628211048900" style="zoom:67%;" />

<blockquote>
<h3 id="谋朝篡位"><a href="#谋朝篡位" class="headerlink" title="谋朝篡位"></a>谋朝篡位</h3></blockquote>
<p>一主二从的情况下，如果主机断了，从机可以使用命令 SLAVEOF NO ONE 将自己改为主机！这个时候其余的从机链接到这个节点。对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。  </p>
<p>哨兵模式  </p>
<h2 id="哨兵模式-自动选老大"><a href="#哨兵模式-自动选老大" class="headerlink" title="哨兵模式  [自动选老大]"></a>哨兵模式  [自动选老大]</h2><blockquote>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>​        主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。<br>​        哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。<strong>其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong>  </p>
<p><img src="Redis.assets/image-20210628213441135.png" alt="image-20210628213441135"></p>
<p><strong>这里的哨兵有两个作用：</strong></p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服<br>务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>​        然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了<strong>多哨兵模式</strong>。 </p>
<p><img src="Redis.assets/image-20210628213537501.png" alt="image-20210628213537501"></p>
<p>​        假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次<strong>投票</strong>，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为==<strong>客观下线</strong>==。  </p>
<blockquote>
<h3 id="配置测试"><a href="#配置测试" class="headerlink" title="配置测试"></a>配置测试</h3></blockquote>
<p>1、调整结构，6379带着80、81<br>2、自定义的 /myredis 目录下新建 sentinel.conf 文件，名字千万不要错<br>3、配置哨兵，填写内容</p>
<ul>
<li>sentinel monitor 被监控主机名字 127.0.0.1 6379 1</li>
<li>上面最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<p>4、启动哨兵</p>
<ul>
<li>Redis-sentinel /myredis/sentinel.conf</li>
<li>上述目录依照各自的实际情况配置，可能目录不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-4-centos bin]# redis-sentinel myredis/sentinel.conf</span><br><span class="line">4178:X 28 Jun 2021 22:26:00.724 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">4178:X 28 Jun 2021 22:26:00.724 # Redis version=6.2.1, bits=64, commit=00000000, modified=0, pid=4178, just started</span><br><span class="line">4178:X 28 Jun 2021 22:26:00.724 # Configuration loaded</span><br><span class="line">4178:X 28 Jun 2021 22:26:00.725 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &#x27;&#x27;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 6.2.1 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._                                   </span><br><span class="line"> (    &#x27;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 26379</span><br><span class="line"> |    `-._   `._    /     _.-&#x27;    |     PID: 4178</span><br><span class="line">  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">      `-._    `-.__.-&#x27;    _.-&#x27;                                       </span><br><span class="line">          `-._        _.-&#x27;                                           </span><br><span class="line">              `-.__.-&#x27;                                           </span><br></pre></td></tr></table></figure>

<p>5、正常主从演示<br>6、原有的Master 挂了<br>7、投票新选<br>8、重新主从继续开工，info replication 查查看<br>9、问题：如果之前的master 重启回来，会不会双master 冲突？ 之前的回来只能做小弟了  </p>
<blockquote>
<h3 id="哨兵模式的优缺点"><a href="#哨兵模式的优缺点" class="headerlink" title="哨兵模式的优缺点"></a>哨兵模式的优缺点</h3></blockquote>
<ol>
<li><strong>优点</strong><ol>
<li>哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有。</li>
<li>主从可以切换，故障可以转移，系统可用性更好。</li>
<li>哨兵模式是主从模式的升级，系统更健壮，可用性更高。</li>
</ol>
</li>
<li><strong>缺点</strong><ol>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
<li>实现哨兵模式的配置也不简单，甚至可以说有些繁琐  </li>
</ol>
</li>
</ol>
<blockquote>
<h3 id="哨兵配置说明"><a href="#哨兵配置说明" class="headerlink" title="哨兵配置说明"></a>哨兵配置说明</h3></blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>

<h1 id="缓存穿透和雪崩"><a href="#缓存穿透和雪崩" class="headerlink" title="缓存穿透和雪崩"></a>缓存穿透和雪崩</h1><p>​        Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。<br>​        另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3></blockquote>
<p>​        缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。 【查不到】 </p>
<ul>
<li>应用服务器压力变大</li>
<li>redis命中率低，查不到</li>
<li>一直查询数据库</li>
</ul>
<img src="Redis.assets/image-20210629082127204.png" alt="image-20210629082127204" style="zoom: 50%;" />

<p><img src="Redis.assets/image-20210629085239091.png" alt="image-20210629085239091"></p>
<blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3></blockquote>
<p><strong>布隆过滤器</strong>  </p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；  </p>
<p><img src="Redis.assets/image-20210628223943146.png" alt="image-20210628223943146"></p>
<p><strong>缓存空对象</strong>  </p>
<p>​        当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；  </p>
<p><img src="Redis.assets/image-20210628224016105.png" alt="image-20210628224016105"></p>
<p>但是这种方法会存在两个问题：<br>    1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；<br>    2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。  </p>
<p><strong>设置可访问的名单（白名单）：</strong></p>
<p>​        使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p>
<p><strong>进行实时监控：</strong></p>
<p>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote>
<h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3></blockquote>
<p>​            这里需要注意和缓存击穿的区别，缓存击穿，是指<strong>一个key非常热点</strong>，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。<strong>当某个key在过期的瞬间，有大量的请求并发访问</strong>，这类数据一般是<strong>热点数据，由于缓存过期，会同时访问数据库来查询最新数据</strong>，并且回写缓存，会导使数据库瞬间压力过大。 【微博服务器宕机】【量太大，缓存过期】 </p>
<img src="Redis.assets/image-20210629090241082.png" alt="image-20210629090241082" style="zoom:33%;" />

<img src="Redis.assets/image-20210629090027844.png" alt="image-20210629090027844"  />

<blockquote>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3></blockquote>
<p><strong>设置热点数据永不过期</strong><br>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长。<br><strong>加互斥锁</strong><br>分布式锁【setnx】：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。  </p>
<img src="Redis.assets/image-20210629084011295.png" alt="image-20210629084011295" style="zoom:50%;" />

<p><img src="Redis.assets/image-20210629090810299.png" alt="image-20210629090810299"></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3></blockquote>
<p>​        缓存雪崩，是指在某一个时间段，缓存集中过期失效。<br>​        产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<img src="Redis.assets/image-20210629090942875.png" alt="image-20210629090942875" style="zoom: 67%;" />  

<p><img src="Redis.assets/image-20210628224518800.png" alt="image-20210628224518800"></p>
<p>​        其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。  </p>
<p>​        双十一：停掉一些服务，保证主要的服务可用。</p>
<p>​        缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p>
<blockquote>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3></blockquote>
<p><strong>redis高可用</strong>【<strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）】<br>        这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。<br><strong>限流降级</strong>【 <strong>使用锁或队列：</strong>】<br>        这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。<br><strong>数据预热</strong>：<br>        数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。  </p>
<p><strong>将缓存失效时间分散开：</strong></p>
<p>​            比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>​        随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种<strong>跨JVM的互斥机制来控制共享资源的访问</strong>，这就是分布式锁要解决的问题！</p>
<p>分布式锁主流的实现方案：</p>
<ol>
<li><p><strong>基于数据库实现分布式锁</strong></p>
</li>
<li><p><strong>基于缓存（Redis等）</strong></p>
</li>
<li><p><strong>基于Zookeeper</strong></p>
</li>
</ol>
<p>每一种分布式锁解决方案都有各自的优缺点：</p>
<ol>
<li><p><strong>性能：redis最高</strong></p>
</li>
<li><p><strong>可靠性：zookeeper最高</strong></p>
</li>
</ol>
<p>这里，我们就基于redis实现分布式锁。</p>
<h3 id="使用redis实现分布式锁"><a href="#使用redis实现分布式锁" class="headerlink" title="使用redis实现分布式锁"></a><strong>使用redis实现分布式锁</strong></h3><p>​        NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。XX ：只在键已经存在时，才对键进行设置操作。</p>
<p><img src="Redis.assets/image-20210629092044287.png" alt="image-20210629092044287"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx users 10   <span class="comment">#setnx加锁</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 20</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; del users		<span class="comment">#删除锁</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 30</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; expire users 10		<span class="comment">#设置锁的过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl users</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl users</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; setnx users 40</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#防止加锁的时候出现异常 实现原子操作</span></span><br><span class="line"><span class="built_in">set</span> users 10 nx ex 12</span><br></pre></td></tr></table></figure>

<ol>
<li><p>多个客户端同时获取锁（setnx）</p>
</li>
<li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p>
</li>
<li><p>其他客户端等待重试</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//1获取锁，setnx lock 111  3秒以后过期</span></span><br><span class="line">		Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">		<span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">		<span class="keyword">if</span>(lock)&#123;</span><br><span class="line">			Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">			<span class="comment">//2.1判断num为空return</span></span><br><span class="line">			<span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//2.2有值就转成成int</span></span><br><span class="line">			<span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="comment">//2.3把redis的num加1</span></span><br><span class="line">			redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">			<span class="comment">//2.4释放锁，del</span></span><br><span class="line">			redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				testLock();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题一：优化UUID防止误删"><a href="#问题一：优化UUID防止误删" class="headerlink" title="问题一：优化UUID防止误删"></a>问题一：优化UUID防止误删</h3><img src="Redis.assets/image-20210629100331986.png" alt="image-20210629100331986" style="zoom:67%;" />

<p><strong>解决：</strong></p>
<img src="Redis.assets/image-20210629100525010.png" alt="image-20210629100525010" style="zoom:50%;" />

<img src="Redis.assets/image-20210629100549964.png" alt="image-20210629100549964" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line">		<span class="comment">//1获取锁，setnx lock 111  3秒以后过期</span></span><br><span class="line">		Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;uuid&quot;</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">			<span class="comment">//2.4释放锁，del</span></span><br><span class="line">			<span class="comment">//判断比较uuid是否一样</span></span><br><span class="line">			String lockUuid = (String) redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(lockUuid.equals(uuid))&#123;</span><br><span class="line">				redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题二：优化之LUA脚本保证删除的原子性"><a href="#问题二：优化之LUA脚本保证删除的原子性" class="headerlink" title="问题二：优化之LUA脚本保证删除的原子性"></a>问题二：<strong>优化之LUA脚本保证删除的原子性</strong></h3><img src="Redis.assets/image-20210629101740773.png" alt="image-20210629101740773" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLockLua&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLockLua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span></span><br><span class="line">		String uuid = UUID.randomUUID().toString();</span><br><span class="line">		<span class="comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span></span><br><span class="line">		String skuId = <span class="string">&quot;25&quot;</span>; <span class="comment">// 访问skuId 为25号的商品 100008348542</span></span><br><span class="line">		String locKey = <span class="string">&quot;lock:&quot;</span> + skuId; <span class="comment">// 锁住的是每个商品的数据</span></span><br><span class="line">		<span class="comment">// 3 获取锁</span></span><br><span class="line">		Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">		<span class="comment">// 第一种： lock 与过期时间中间不写任何的代码。</span></span><br><span class="line">		<span class="comment">// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间</span></span><br><span class="line">		<span class="comment">// 如果true</span></span><br><span class="line">		<span class="keyword">if</span> (lock) &#123;</span><br><span class="line">			<span class="comment">// 执行的业务逻辑开始</span></span><br><span class="line">			<span class="comment">// 获取缓存中的num 数据</span></span><br><span class="line">			Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">			<span class="comment">// 如果是空直接返回</span></span><br><span class="line">			<span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span></span><br><span class="line">			<span class="keyword">int</span> num = Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="comment">// 使num 每次+1 放入缓存</span></span><br><span class="line">			redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, String.valueOf(++num));</span><br><span class="line">			<span class="comment">/*使用lua脚本来锁，保证删除锁的原子性*/</span></span><br><span class="line">			<span class="comment">// 定义lua 脚本</span></span><br><span class="line">			String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">			<span class="comment">// 使用redis执行lua执行</span></span><br><span class="line">			DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">			redisScript.setScriptText(script);</span><br><span class="line">			<span class="comment">// 设置一下返回值类型 为Long</span></span><br><span class="line">			<span class="comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span></span><br><span class="line">			<span class="comment">// 那么返回字符串与0 会有发生错误。</span></span><br><span class="line">			redisScript.setResultType(Long.class);</span><br><span class="line">			<span class="comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span></span><br><span class="line">			redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 其他线程等待</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 睡眠</span></span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				<span class="comment">// 睡醒了之后，调用方法。</span></span><br><span class="line">				testLockLua();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<img src="Redis.assets/image-20210629102543152.png" alt="image-20210629102543152" style="zoom:150%;" />

<p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p>
<ul>
<li> 互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
<li>加锁和解锁必须具有原子性。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/01/Redis/">http://example.com/2021/07/01/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/07/01/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NoSQL%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">NoSQL概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.</span> <span class="toc-text">发展历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%9C%BAMySQL"><span class="toc-number">1.2.</span> <span class="toc-text">单机MySQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memcached%EF%BC%88%E7%BC%93%E5%AD%98%EF%BC%89-MySQL-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-number">1.3.</span> <span class="toc-text">Memcached（缓存）+ MySQL + 垂直拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%BB%E4%BB%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">1.4.</span> <span class="toc-text">MySQL主从读写分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93-%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86-Mysql-%E9%9B%86%E7%BE%A4"><span class="toc-number">1.5.</span> <span class="toc-text">分表分库 + 水平拆分 + Mysql 集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E7%9A%84%E6%89%A9%E5%B1%95%E6%80%A7%E7%93%B6%E9%A2%88"><span class="toc-number">1.6.</span> <span class="toc-text">MySQL 的扩展性瓶颈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8NoSQL%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">为什么用NoSQL？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFNoSQL"><span class="toc-number">1.8.</span> <span class="toc-text">什么是NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.8.1.</span> <span class="toc-text">NoSQL的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.9.</span> <span class="toc-text">经典应用分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NoSQL%E5%9B%9B%E5%A4%A7%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">NoSQL四大分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.</span> <span class="toc-text">四者对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%EF%BC%88%E4%B8%89%E8%BF%9B%E4%BA%8C%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">CAP（三进二）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BASE-%E7%90%86%E8%AE%BA"><span class="toc-number">2.3.</span> <span class="toc-text">BASE 理论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%85%A5%E9%97%A8"><span class="toc-number">3.</span> <span class="toc-text">Redis入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.</span> <span class="toc-text">Redis是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">3.3.</span> <span class="toc-text">Redis能干嘛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">3.4.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E5%AE%89%E8%A3%85"><span class="toc-number">3.5.</span> <span class="toc-text">Windows安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%AE%89%E8%A3%85"><span class="toc-number">3.6.</span> <span class="toc-text">Linux安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.7.</span> <span class="toc-text">安装步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%93Redis-benchmark"><span class="toc-number">3.8.</span> <span class="toc-text">redis压力测试工具—–Redis-benchmark</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-number">3.9.</span> <span class="toc-text">Redis为什么这么快</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">String （字符串类型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%8C%E7%B1%BB%E4%BC%BC-Java%E9%87%8C%E7%9A%84Map%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">Hash（哈希，类似 Java里的Map）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">List（列表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.1.</span> <span class="toc-text">性能总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">Set（集合）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zset%EF%BC%88sorted-set%EF%BC%9A%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">Zset（sorted set：有序集合）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%94%AE%EF%BC%88key%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">Redis键（key）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">三种特殊数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GEO%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.1.</span> <span class="toc-text">GEO地理位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geoadd-%E6%B7%BB%E5%8A%A0%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%88%E7%BB%8F%E5%BA%A6%EF%BC%8C%E7%BA%AC%E5%BA%A6%EF%BC%8C%E5%90%8D%E7%A7%B0%EF%BC%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">geoadd  添加地理位置（经度，纬度，名称）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geopos-%E8%8E%B7%E5%BE%97%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%8C%BA%E7%9A%84%E5%9D%90%E6%A0%87%E5%80%BC"><span class="toc-number">5.1.3.</span> <span class="toc-text">geopos  获得指定地区的坐标值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geodist-%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E4%BD%8D%E7%BD%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B4%E7%BA%BF%E8%B7%9D%E7%A6%BB"><span class="toc-number">5.1.4.</span> <span class="toc-text">geodist  获取两个位置之间的直线距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#georadius-%E4%BB%A5%E7%BB%99%E5%AE%9A%E7%9A%84%E7%BB%8F%E7%BA%AC%E5%BA%A6%E4%B8%BA%E4%B8%AD%E5%BF%83%EF%BC%8C%E6%89%BE%E5%87%BA%E6%9F%90%E4%B8%80%E5%8D%8A%E5%BE%84%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">5.1.5.</span> <span class="toc-text">georadius  以给定的经纬度为中心，找出某一半径内的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#georadiusbymember"><span class="toc-number">5.1.6.</span> <span class="toc-text">georadiusbymember</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geohash"><span class="toc-number">5.1.7.</span> <span class="toc-text">geohash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zrem"><span class="toc-number">5.1.8.</span> <span class="toc-text">zrem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLog"><span class="toc-number">5.2.</span> <span class="toc-text">HyperLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E6%95%B0"><span class="toc-number">5.2.2.</span> <span class="toc-text">什么是基数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">5.2.3.</span> <span class="toc-text">基本命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BitMap"><span class="toc-number">5.3.</span> <span class="toc-text">BitMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setbit-%E8%AE%BE%E7%BD%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.1.</span> <span class="toc-text">setbit 设置操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getbit-%E8%8E%B7%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.2.</span> <span class="toc-text">getbit 获取操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitcount-%E7%BB%9F%E8%AE%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.3.</span> <span class="toc-text">bitcount 统计操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">6.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.2.</span> <span class="toc-text">实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.2.1.</span> <span class="toc-text">正常执行事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.2.2.</span> <span class="toc-text">放弃事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8B%A5%E5%9C%A8%E4%BA%8B%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%91%BD%E4%BB%A4%E6%80%A7%E9%94%99%E8%AF%AF%EF%BC%88%E7%B1%BB%E4%BC%BC%E4%BA%8Ejava%E7%BC%96%E8%AF%91%E6%80%A7%E9%94%99%E8%AF%AF%EF%BC%89%EF%BC%8C%E5%88%99%E6%89%A7%E8%A1%8CEXEC%E5%91%BD%E4%BB%A4%E6%97%B6%EF%BC%8C%E6%89%80%E6%9C%89%E5%91%BD%E4%BB%A4%E9%83%BD%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C"><span class="toc-number">6.2.3.</span> <span class="toc-text">若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8B%A5%E5%9C%A8%E4%BA%8B%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD%E5%AD%98%E5%9C%A8%E8%AF%AD%E6%B3%95%E6%80%A7%E9%94%99%E8%AF%AF%EF%BC%88%E7%B1%BB%E4%BC%BC%E4%BA%8Ejava%E7%9A%841-0%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%EF%BC%89%EF%BC%8C%E5%88%99%E6%89%A7%E8%A1%8CEXEC%E5%91%BD%E4%BB%A4%E6%97%B6%EF%BC%8C%E5%85%B6%E4%BB%96%E6%AD%A3%E7%A1%AE%E5%91%BD%E4%BB%A4%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%94%99%E8%AF%AF%E5%91%BD%E4%BB%A4%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">6.2.4.</span> <span class="toc-text">若在事务队列中存在语法性错误（类似于java的1&#x2F;0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watch-%E7%9B%91%E6%8E%A7"><span class="toc-number">6.2.5.</span> <span class="toc-text">Watch 监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Jedis"><span class="toc-number">7.</span> <span class="toc-text">Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%81%94%E9%80%9A"><span class="toc-number">7.1.</span> <span class="toc-text">测试联通</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-number">7.2.</span> <span class="toc-text">常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">7.2.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9key%E6%93%8D%E4%BD%9C%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">7.2.2.</span> <span class="toc-text">对key操作的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9String%E6%93%8D%E4%BD%9C%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">7.2.3.</span> <span class="toc-text">对String操作的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9List%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">7.2.4.</span> <span class="toc-text">对List操作命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9Set%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">7.2.5.</span> <span class="toc-text">对Set的操作命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9Hash%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">7.2.6.</span> <span class="toc-text">对Hash的操作命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="toc-number">7.3.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-1"><span class="toc-number">7.3.1.</span> <span class="toc-text">基本操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88"><span class="toc-number">8.</span> <span class="toc-text">SpringBoot整合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">8.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">8.1.2.</span> <span class="toc-text">导入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yaml%E9%85%8D%E7%BD%AE"><span class="toc-number">8.1.3.</span> <span class="toc-text">yaml配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">8.1.4.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">封装工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-conf%E8%AF%A6%E8%A7%A3"><span class="toc-number">9.</span> <span class="toc-text">Redis.conf详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="toc-number">9.1.</span> <span class="toc-text">基本配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Units-%E5%8D%95%E4%BD%8D"><span class="toc-number">9.1.1.</span> <span class="toc-text">Units 单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INCLUDES-%E5%8C%85%E5%90%AB"><span class="toc-number">9.1.2.</span> <span class="toc-text">INCLUDES 包含</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NETWORK-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-number">9.1.3.</span> <span class="toc-text">NETWORK 网络配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GENERAL-%E9%80%9A%E7%94%A8"><span class="toc-number">9.1.4.</span> <span class="toc-text">GENERAL 通用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SNAPSHOPTING-%E5%BF%AB%E7%85%A7"><span class="toc-number">9.1.5.</span> <span class="toc-text">SNAPSHOPTING 快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REPLICATION-%E5%A4%8D%E5%88%B6"><span class="toc-number">9.1.6.</span> <span class="toc-text">REPLICATION 复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SECURITY%E5%AE%89%E5%85%A8"><span class="toc-number">9.1.7.</span> <span class="toc-text">SECURITY安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6"><span class="toc-number">9.1.8.</span> <span class="toc-text">限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#append-only%E6%A8%A1%E5%BC%8F-AOF%E9%85%8D%E7%BD%AE"><span class="toc-number">9.1.9.</span> <span class="toc-text">append only模式  [AOF配置]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE"><span class="toc-number">9.2.</span> <span class="toc-text">常见配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB%EF%BC%88Redis-DataBase%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">RDB（Redis DataBase）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRDB"><span class="toc-number">10.1.1.</span> <span class="toc-text">什么是RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork"><span class="toc-number">10.1.2.</span> <span class="toc-text">Fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE%E5%8F%8ASNAPSHOTTING%E8%A7%A3%E6%9E%90"><span class="toc-number">10.1.3.</span> <span class="toc-text">配置位置及SNAPSHOTTING解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BD%99%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90"><span class="toc-number">10.1.4.</span> <span class="toc-text">其余命令解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">10.1.5.</span> <span class="toc-text">触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8Drdb%E6%96%87%E4%BB%B6"><span class="toc-number">10.1.6.</span> <span class="toc-text">恢复rdb文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">10.1.7.</span> <span class="toc-text">优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">10.1.8.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%EF%BC%88Append-Only-File%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">AOF（Append Only File）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">10.2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">10.2.2.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E5%90%AF%E5%8A%A8-%E4%BF%AE%E5%A4%8D-%E6%81%A2%E5%A4%8D"><span class="toc-number">10.2.3.</span> <span class="toc-text">AOF 启动&#x2F;修复&#x2F;恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rewrite"><span class="toc-number">10.2.4.</span> <span class="toc-text">Rewrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9-1"><span class="toc-number">10.2.5.</span> <span class="toc-text">优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">10.2.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">11.</span> <span class="toc-text">Redis 发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">11.0.1.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">11.0.2.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">11.0.3.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">Redis 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">12.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">12.2.</span> <span class="toc-text">环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE-1"><span class="toc-number">12.2.1.</span> <span class="toc-text">基本配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%81"><span class="toc-number">12.2.2.</span> <span class="toc-text">修改配置文件！</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">12.3.</span> <span class="toc-text">一主二从</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">12.3.1.</span> <span class="toc-text">1、一主二从</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">12.3.2.</span> <span class="toc-text">配置文件配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">12.3.3.</span> <span class="toc-text">复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B1%82%E5%B1%82%E9%93%BE%E8%B7%AF"><span class="toc-number">12.3.4.</span> <span class="toc-text">2、层层链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%8B%E6%9C%9D%E7%AF%A1%E4%BD%8D"><span class="toc-number">12.3.5.</span> <span class="toc-text">谋朝篡位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-%E8%87%AA%E5%8A%A8%E9%80%89%E8%80%81%E5%A4%A7"><span class="toc-number">12.4.</span> <span class="toc-text">哨兵模式  [自动选老大]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">12.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95"><span class="toc-number">12.4.2.</span> <span class="toc-text">配置测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">12.4.3.</span> <span class="toc-text">哨兵模式的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">12.4.4.</span> <span class="toc-text">哨兵配置说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9"><span class="toc-number">13.</span> <span class="toc-text">缓存穿透和雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">13.1.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">13.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">13.1.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">13.2.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">13.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">13.2.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">13.3.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">13.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-number">13.3.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">13.4.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">13.4.1.</span> <span class="toc-text">使用redis实现分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E4%BC%98%E5%8C%96UUID%E9%98%B2%E6%AD%A2%E8%AF%AF%E5%88%A0"><span class="toc-number">13.4.2.</span> <span class="toc-text">问题一：优化UUID防止误删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E4%BC%98%E5%8C%96%E4%B9%8BLUA%E8%84%9A%E6%9C%AC%E4%BF%9D%E8%AF%81%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">13.4.3.</span> <span class="toc-text">问题二：优化之LUA脚本保证删除的原子性</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/01/Redis/" title="No title"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2021/07/01/Redis/" title="No title">No title</a><time datetime="2021-07-01T10:42:11.741Z" title="Created 2021-07-01 18:42:11">2021-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/01/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="No title"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2021/07/01/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="No title">No title</a><time datetime="2021-07-01T10:42:11.740Z" title="Created 2021-07-01 18:42:11">2021-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/01/java%E9%9B%86%E5%90%88md/" title="No title"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2021/07/01/java%E9%9B%86%E5%90%88md/" title="No title">No title</a><time datetime="2021-07-01T10:42:11.738Z" title="Created 2021-07-01 18:42:11">2021-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="No title"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2021/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="No title">No title</a><time datetime="2021-07-01T10:42:11.737Z" title="Created 2021-07-01 18:42:11">2021-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/24/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/" title="#创建新的文章"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="#创建新的文章"/></a><div class="content"><a class="title" href="/2021/06/24/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/" title="#创建新的文章">#创建新的文章</a><time datetime="2021-06-24T01:28:01.000Z" title="Created 2021-06-24 09:28:01">2021-06-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>