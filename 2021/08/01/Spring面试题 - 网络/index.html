<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring面试题 | luckforever</title><meta name="keywords" content="Spring面试题"><meta name="author" content="刘恒运"><meta name="copyright" content="刘恒运"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring  1、Spring概述（11）1.1 什么是spring?Spring是一个轻量级Java开发框架，目的是为了&#x3D;&#x3D;解决企业级应用开发的业务逻辑层和其他各层的耦合问题&#x3D;&#x3D;。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 Sprin">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring面试题">
<meta property="og:url" content="http://example.com/2021/08/01/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="luckforever">
<meta property="og:description" content="Spring  1、Spring概述（11）1.1 什么是spring?Spring是一个轻量级Java开发框架，目的是为了&#x3D;&#x3D;解决企业级应用开发的业务逻辑层和其他各层的耦合问题&#x3D;&#x3D;。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 Sprin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/image-20210909092240317.png">
<meta property="article:published_time" content="2021-08-01T01:00:00.000Z">
<meta property="article:modified_time" content="2021-09-09T01:30:28.453Z">
<meta property="article:author" content="刘恒运">
<meta property="article:tag" content="IOC原理">
<meta property="article:tag" content="AOP面向切面编程">
<meta property="article:tag" content="Spring注解">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/image-20210909092240317.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/08/01/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%BD%91%E7%BB%9C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-09 09:30:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="luckforever" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/个人照片/刘恒运.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw iconfont icon-fenxiang"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-shuji"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/FilmAndTV/"><i class="fa-fw iconfont icon-yingshi1"></i><span> 影视</span></a></li><li><a class="site-page child" href="/daohang/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/image-20210909092240317.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">luckforever</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw iconfont icon-fenxiang"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-shuji"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/FilmAndTV/"><i class="fa-fw iconfont icon-yingshi1"></i><span> 影视</span></a></li><li><a class="site-page child" href="/daohang/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-01T01:00:00.000Z" title="发表于 2021-08-01 09:00:00">2021-08-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-09T01:30:28.453Z" title="更新于 2021-09-09 09:30:28">2021-09-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/">Spring面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/image-20210909092240317.png" alt="image-20210909092240317" style="zoom:50%;" />

<h2 id="1、Spring概述（11）"><a href="#1、Spring概述（11）" class="headerlink" title="1、Spring概述（11）"></a>1、Spring概述（11）</h2><h3 id="1-1-什么是spring"><a href="#1-1-什么是spring" class="headerlink" title="1.1 什么是spring?"></a>1.1 什么是spring?</h3><p>Spring是<strong>一个轻量级Java开发框架</strong>，目的是为了==解决企业级应用开发的业务逻辑层和其他各层的耦合问题==。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p>
<p>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发</strong>。</p>
<p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）</strong>。</p>
<p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</p>
<ul>
<li>基于POJO的轻量级和最小侵入性编程；</li>
<li>通过依赖注入和面向接口实现松耦合；</li>
<li>基于切面和惯例进行声明式编程；</li>
<li>通过切面和模板减少样板式代码。</li>
</ul>
<h3 id="1-2-Spring框架的设计目标，设计理念，和核心是什么"><a href="#1-2-Spring框架的设计目标，设计理念，和核心是什么" class="headerlink" title="1.2 Spring框架的设计目标，设计理念，和核心是什么"></a>1.2 Spring框架的设计目标，设计理念，和核心是什么</h3><p><strong>Spring设计目标</strong>：Spring为开发者提供一个一站式轻量级应用开发平台；</p>
<p><strong>Spring设计理念</strong>：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p>
<p><strong>Spring框架的核心</strong>：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p>
<p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p>
<h3 id="1-3-Spring的优缺点是什么？"><a href="#1-3-Spring的优缺点是什么？" class="headerlink" title="1.3 Spring的优缺点是什么？"></a>1.3 Spring的优缺点是什么？</h3><p>优点</p>
<ul>
<li><p><strong>方便解耦，简化开发</strong></p>
<p>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p>
</li>
<li><p><strong>AOP编程的支持</strong></p>
<p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>
</li>
<li><p><strong>声明式事务的支持</strong></p>
<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>
</li>
<li><p><strong>方便程序的测试</strong></p>
<p>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p>
</li>
<li><p><strong>方便集成各种优秀框架</strong></p>
<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>
</li>
<li><p><strong>降低JavaEE API的使用难度</strong></p>
<p>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li>Spring明明一个很轻量级的框架，却给人感觉大而全</li>
<li><strong>Spring依赖反射，反射影响性能</strong></li>
<li>使用门槛升高，入门Spring需要较长时间</li>
</ul>
<h3 id="1-4-Spring有哪些应用场景"><a href="#1-4-Spring有哪些应用场景" class="headerlink" title="1.4 Spring有哪些应用场景"></a>1.4 Spring有哪些应用场景</h3><p><strong>应用场景</strong>：JavaEE企业应用开发，包括SSH、SSM等</p>
<p><strong>Spring价值</strong>：</p>
<ul>
<li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；</li>
<li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；</li>
<li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</li>
</ul>
<h3 id="1-5-Spring由哪些模块组成？"><a href="#1-5-Spring由哪些模块组成？" class="headerlink" title="1.5 Spring由哪些模块组成？"></a>1.5 Spring由哪些模块组成？</h3><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在<code>核心容器（Core Container）</code> 、 <code>AOP（Aspect Oriented Programming）和设备支持（Instrmentation）</code> 、<code>数据访问与集成（Data Access/Integeration）</code> 、 <code>Web</code>、 <code>消息（Messaging）</code> 、 <code>Test</code>等 6 个模块中。 以下是 Spring 5 的模块结构图：</p>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/2019102923475419.png" alt="在这里插入图片描述" style="zoom:80%;" />

<ul>
<li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li>
<li>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</li>
<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>
<li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</li>
<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>
<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li>
<li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li>
</ul>
<h3 id="1-6-Spring-框架中都用到了哪些设计模式？"><a href="#1-6-Spring-框架中都用到了哪些设计模式？" class="headerlink" title="1.6 Spring 框架中都用到了哪些设计模式？"></a>1.6 Spring 框架中都用到了哪些设计模式？</h3><ol>
<li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li>
<li>单例模式：Bean默认为单例模式。</li>
<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li>
<li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li>
<li>适配器模式：AOP的处理中有Adapter模式，由于Advisor链需要的是MethodInterceptor对象，所以每一个Advisor中的Advice都要适配成对应的MethodInterceptor对象。</li>
</ol>
<h3 id="1-7-详细讲解一下核心容器（spring-context应用上下文-模块"><a href="#1-7-详细讲解一下核心容器（spring-context应用上下文-模块" class="headerlink" title="1.7 详细讲解一下核心容器（spring context应用上下文) 模块"></a>1.7 详细讲解一下核心容器（spring context应用上下文) 模块</h3><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p>
<h3 id="1-8-Spring框架中有哪些不同类型的事件"><a href="#1-8-Spring框架中有哪些不同类型的事件" class="headerlink" title="1.8 Spring框架中有哪些不同类型的事件"></a>1.8 Spring框架中有哪些不同类型的事件</h3><p>Spring 提供了以下5种标准的事件：</p>
<ol>
<li>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li>
</ol>
<h3 id="1-9-Spring-应用程序有哪些不同组件？"><a href="#1-9-Spring-应用程序有哪些不同组件？" class="headerlink" title="1.9 Spring 应用程序有哪些不同组件？"></a>1.9 Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<ul>
<li>接口 - 定义功能。</li>
<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>
<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>
<li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li>
<li>用户程序 - 它使用接口。</li>
</ul>
<h3 id="1-10-使用-Spring-有哪些方式？"><a href="#1-10-使用-Spring-有哪些方式？" class="headerlink" title="1.10 使用 Spring 有哪些方式？"></a>1.10 使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
<li>用于远程使用。</li>
</ul>
<h3 id="1-11-Spring和SpringMVC的关系"><a href="#1-11-Spring和SpringMVC的关系" class="headerlink" title="1.11 Spring和SpringMVC的关系"></a>1.11 Spring和SpringMVC的关系</h3><p>Spring是IOC和AOP的容器框架，SpringMVC是基于Spring功能之上添加的Web框架，想用SpringMVC必须先依赖Spring。</p>
<p>Spring可以说是一个管理bean的容器，也可以说是包括很多开源项目的总称，spring mvc是其中一个开源项目</p>
<h2 id="2、-Spring控制反转-IOC-（13）"><a href="#2、-Spring控制反转-IOC-（13）" class="headerlink" title="2、 Spring控制反转(IOC)（13）"></a>2、 Spring控制反转(IOC)（13）</h2><h3 id="2-1-什么是Spring-IOC-容器？"><a href="#2-1-什么是Spring-IOC-容器？" class="headerlink" title="2.1 什么是Spring IOC 容器？"></a>2.1 什么是Spring IOC 容器？</h3><p><strong>控制反转</strong>即IoC (Inversion of Control)，它==<strong>把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理</strong>==。所谓的“控制反转”概念就是**==对组件对象控制权的转移==**，从程序代码本身转移到了外部容器。</p>
<p>==Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。==</p>
<h3 id="2-2-控制反转-IoC-有什么作用"><a href="#2-2-控制反转-IoC-有什么作用" class="headerlink" title="2.2 控制反转(IoC)有什么作用"></a>2.2 控制反转(IoC)有什么作用</h3><ul>
<li><strong>管理对象的创建和依赖关系的维护</strong>。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</li>
<li><strong>解耦，由容器去维护具体的对象</strong></li>
<li><strong>托管了类的产生过程</strong>，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li>
</ul>
<h3 id="2-3-IOC的优点是什么？"><a href="#2-3-IOC的优点是什么？" class="headerlink" title="2.3 IOC的优点是什么？"></a>2.3 IOC的优点是什么？</h3><ul>
<li><strong>IOC 或 依赖注入把应用的代码量降到最低。</strong></li>
<li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li>
<li><strong>最小的代价和最小的侵入性使松散耦合得以实现</strong>。</li>
<li><strong>IOC容器支持加载服务时的饿汉式初始化和懒加载。</strong></li>
</ul>
<h3 id="2-4-Spring-IoC-的实现机制"><a href="#2-4-Spring-IoC-的实现机制" class="headerlink" title="2.4 Spring IoC 的实现机制"></a>2.4 Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射机制。</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Spring-的-IoC支持哪些功能"><a href="#2-5-Spring-的-IoC支持哪些功能" class="headerlink" title="2.5 Spring 的 IoC支持哪些功能"></a>2.5 Spring 的 IoC支持哪些功能</h3><p>Spring 的 IoC 设计支持以下功能：</p>
<ul>
<li><strong>依赖注入</strong></li>
<li><strong>依赖检查</strong></li>
<li><strong>自动装配</strong></li>
<li><strong>支持集合</strong></li>
<li><strong>指定初始化方法和销毁方法</strong></li>
<li><strong>支持回调某些方法</strong>（但是需要实现 Spring 接口，略有侵入）</li>
</ul>
<p>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p>
<p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p>
<h2 id="3、IOC原理"><a href="#3、IOC原理" class="headerlink" title="3、IOC原理"></a>3、IOC原理</h2><p>IOC:Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射机制。</strong></p>
<p>1.Spring的bean容器也叫beanfactory，我们常用的applicationcontext实际上内部有一个listablebeanfactory实际存储bean的map。</p>
<p>2 . bean加载过程：==<strong>spring容器加载时先读取配置文件，一般是xml，然后解析xml，找到其中所有bean，依次解析，然后生成每个bean的beandefinition，存在一个map中，根据beanid映射实际bean的map</strong>==。</p>
<p>3.bean初始化：加载完以后，如果不启用懒加载模式，则默认使用<strong>单例加载</strong>，==在注册完bean以后，可以获取到beandefinition信息，然后根据该信息首先先检查依赖关系，如果依赖其他bean则先加载其他bean，然后通过反射的方式即new   instance创建一个单例bean==。</p>
<p>为什么要用反射呢，因为实现类可以通过配置改变，但接口是一致的，使用==反射可以避免实现类改变时无法自动进行实例化==。</p>
<p>当然，bean也可以使用原型方式加载，使用原型的话，每次创建bean都会是全新的。</p>
<h3 id="3-1-BeanFactory-和-ApplicationContext有什么区别？"><a href="#3-1-BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="3.1  BeanFactory 和 ApplicationContext有什么区别？"></a>3.1  BeanFactory 和 ApplicationContext有什么区别？</h3><p><strong>==BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。==</strong></p>
<blockquote>
<h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4></blockquote>
<p><strong>BeanFactory：</strong>是Spring里面最底层的接口，<strong>包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</strong></p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了<strong>更完整的框架功能</strong>：</p>
<ul>
<li>继承MessageSource，因此<strong>支持国际化</strong>。</li>
<li><strong>统一的资源文件访问方式</strong>。</li>
<li><strong>提供在监听器中注册bean的事件</strong>。</li>
<li><strong>同时加载多个配置文件</strong>。</li>
<li><strong>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</strong></li>
</ul>
<blockquote>
<h4 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h4></blockquote>
<p>BeanFactroy采用的是<strong>延迟加载形式</strong>来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>ApplicationContext，<strong>它是在容器启动时，一次性创建了所有的Bean</strong>。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样<strong>有利于检查所依赖属性是否注入</strong>。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<blockquote>
<h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4></blockquote>
<p><strong>BeanFactory通常以==编程的方式==被创建</strong>，ApplicationContext还能以==声明的方式创建==，如使用ContextLoader。</p>
<blockquote>
<h4 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h4></blockquote>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<h3 id="3-2-Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解"><a href="#3-2-Spring-如何设计容器的，BeanFactory和ApplicationContext的关系详解" class="headerlink" title="3.2 Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解"></a>3.2 Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</h3><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p>
<ul>
<li>BeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 <strong>“低级容器”</strong>。</p>
<p>ApplicationContext 可以称之为 <strong>“高级容器”</strong>。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “<strong>应用上下文</strong>”， 代表着整个大容器的所有功能。==该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。==</p>
<p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p>
<p>BeanFactory和ApplicationContext的关系</p>
<p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/20191105111441363.png" alt="img"></p>
<p>有点复杂？ 先不要慌，我来解释一下。</p>
<p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p>
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p>
<p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p>
<p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p>
<p>小结</p>
<p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p>
<ol>
<li><strong>加载配置文件，解析成 BeanDefinition 放在 Map 里。</strong></li>
<li><strong>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</strong></li>
</ol>
<p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p>
<p>至于高级容器 ApplicationContext，他包含了低级容器的功能，<strong>当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean</strong>。同时其作为高级容器，包含了太多的功能。<strong>一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</strong></p>
<h3 id="3-3-ApplicationContext通常的实现是什么？"><a href="#3-3-ApplicationContext通常的实现是什么？" class="headerlink" title="3.3 ApplicationContext通常的实现是什么？"></a>3.3 ApplicationContext通常的实现是什么？</h3><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>
<p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>
<p><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p>
<h3 id="3-4-Spring单例Bean与单例模式的区别"><a href="#3-4-Spring单例Bean与单例模式的区别" class="headerlink" title="3.4 Spring单例Bean与单例模式的区别"></a>3.4 Spring单例Bean与单例模式的区别</h3><p><strong>单例模式是指在一个JVM进程中仅有一个实例</strong>，而<strong>Spring单例是指一个Spring Bean容器(ApplicationContext)中仅有一个实例</strong>。</p>
<p>首先看单例模式，在一个JVM进程中（理论上，一个运行的JAVA程序就必定有自己一个独立的JVM）仅有一个实例，于是无论在程序中的何处获取实例，始终都返回同一个对象。</p>
<p>与此相比，Spring的单例Bean是与其容器（ApplicationContext）密切相关的，所以在一个JVM进程中，如果有多个Spring容器，即使是单例bean，也一定会创建多个实例</p>
<h3 id="3-5-什么是Spring的依赖注入？"><a href="#3-5-什么是Spring的依赖注入？" class="headerlink" title="3.5 什么是Spring的依赖注入？"></a>3.5 什么是Spring的依赖注入？</h3><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：依赖注入和依赖查找</p>
<p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。==所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是<strong>由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中</strong>。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。==</p>
<h3 id="3-6-依赖注入的基本原则"><a href="#3-6-依赖注入的基本原则" class="headerlink" title="3.6 依赖注入的基本原则"></a>3.6 依赖注入的基本原则</h3><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p>
<h3 id="3-7-依赖注入有什么优势"><a href="#3-7-依赖注入有什么优势" class="headerlink" title="3.7 依赖注入有什么优势"></a>3.7 依赖注入有什么优势</h3><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>
<ul>
<li>查找定位操作与应用代码完全无关。</li>
<li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li>
<li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li>
</ul>
<h3 id="3-8-有哪些不同类型的依赖注入实现方式？"><a href="#3-8-有哪些不同类型的依赖注入实现方式？" class="headerlink" title="3.8 有哪些不同类型的依赖注入实现方式？"></a>3.8 有哪些不同类型的依赖注入实现方式？</h3><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为:</p>
<p>接口注入（Interface Injection）</p>
<p>Setter方法注入（Setter Injection）</p>
<p>构造器注入（Constructor Injection）三种方式。</p>
<p>其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p>
<p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<p><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>
<h3 id="构造器依赖注入和-Setter方法注入的区别"><a href="#构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="构造器依赖注入和 Setter方法注入的区别"></a>构造器依赖注入和 Setter方法注入的区别</h3><table>
<thead>
<tr>
<th><strong>构造函数注入</strong></th>
<th><strong>setter</strong> <strong>注入</strong></th>
</tr>
</thead>
<tbody><tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 setter 属性</td>
<td>会覆盖 setter 属性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody></table>
<p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p>
<h2 id="4、Spring-Beans（19）"><a href="#4、Spring-Beans（19）" class="headerlink" title="4、Spring Beans（19）"></a>4、Spring Beans（19）</h2><h3 id="4-1-什么是Spring-beans？"><a href="#4-1-什么是Spring-beans？" class="headerlink" title="4.1 什么是Spring beans？"></a>4.1 什么是Spring beans？</h3><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p>
<h3 id="4-2-一个-Spring-Bean-定义-包含什么？"><a href="#4-2-一个-Spring-Bean-定义-包含什么？" class="headerlink" title="4.2 一个 Spring Bean 定义 包含什么？"></a>4.2 一个 Spring Bean 定义 包含什么？</h3><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p>
<h3 id="4-3-如何给Spring-容器提供配置元数据？Spring有几种配置方式"><a href="#4-3-如何给Spring-容器提供配置元数据？Spring有几种配置方式" class="headerlink" title="4.3 如何给Spring 容器提供配置元数据？Spring有几种配置方式"></a>4.3 如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p>
<ul>
<li>XML配置文件。</li>
<li>基于注解的配置。</li>
<li>基于java的配置。</li>
</ul>
<h3 id="4-4-Spring配置文件包含了哪些信息"><a href="#4-4-Spring配置文件包含了哪些信息" class="headerlink" title="4.4 Spring配置文件包含了哪些信息"></a>4.4 Spring配置文件包含了哪些信息</h3><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p>
<h3 id="4-5-Spring基于xml注入bean的几种方式"><a href="#4-5-Spring基于xml注入bean的几种方式" class="headerlink" title="4.5 Spring基于xml注入bean的几种方式"></a>4.5 Spring基于xml注入bean的几种方式</h3><ol>
<li>Set方法注入；</li>
<li>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</li>
<li>静态工厂注入；</li>
<li>实例工厂；</li>
</ol>
<h3 id="4-6-你怎样定义类的作用域？"><a href="#4-6-你怎样定义类的作用域？" class="headerlink" title="4.6 你怎样定义类的作用域？"></a>4.6 你怎样定义类的作用域？</h3><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p>
<h3 id="4-7-解释Spring支持的几种bean的作用域"><a href="#4-7-解释Spring支持的几种bean的作用域" class="headerlink" title="4.7 解释Spring支持的几种bean的作用域"></a>4.7 解释Spring支持的几种bean的作用域</h3><p>Spring框架支持以下五种bean的作用域：</p>
<ul>
<li><strong>singleton :</strong> bean在每个Spring ioc 容器中只有一个实例。</li>
<li><strong>prototype</strong>：一个bean的定义可以有多个实例。</li>
<li><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
</ul>
<p><strong>注意：</strong> 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h3 id="4-8-Spring框架中的单例bean是线程安全的吗？"><a href="#4-8-Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="4.8 Spring框架中的单例bean是线程安全的吗？"></a>4.8 Spring框架中的单例bean是线程安全的吗？</h3><p>不是，Spring框架中的单例bean不是线程安全的。</p>
<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>==<strong>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</strong>==</p>
<ul>
<li>有状态就是有数据存储功能。</li>
<li>无状态就是不会保存数据。</li>
</ul>
<h3 id="4-9-Spring如何处理线程并发问题？"><a href="#4-9-Spring如何处理线程并发问题？" class="headerlink" title="4.9 Spring如何处理线程并发问题？"></a>4.9 Spring如何处理线程并发问题？</h3><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<p><strong>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题</strong>。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p>
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<h3 id="4-10-解释Spring框架中bean的生命周期"><a href="#4-10-解释Spring框架中bean的生命周期" class="headerlink" title="4.10 解释Spring框架中bean的生命周期"></a>4.10 解释Spring框架中bean的生命周期</h3><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/image-20210904184821051.png" alt="image-20210904184821051"  />

<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/image-20210904185242569.png" alt="image-20210904185242569" style="zoom:80%;" />

<p>（1）通过构造器创建bean实例（无参数构造）,由BeanFactory读取Bean定义文件【实例化对象】</p>
<p>（2）为bean的属性设置值和对其他bean引用（调用set方法）【依赖注入】</p>
<p>（3）把bean实例传递bean后置处理器的方法==postProcessBeforeInitialization==</p>
<p>（4）调用bean的初始化的方法（需要进行配置初始化的方法afterPropertiesSet()）（后置处理器技术，AOP基于这个技术实现）</p>
<p>（5）把bean实例传递bean后置处理器的方法==postProcessAfterInitialization==</p>
<p>（6）bean可以使用了（对象获取到了）</p>
<p>（7）当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁的方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ooders</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ooders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOname</span><span class="params">(String oname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建执行初始化的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步 执行初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建执行销毁的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destoryMethoh</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testoders</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context4 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean4.xml&quot;</span>);</span><br><span class="line">    Ooders ooders = context4.getBean(<span class="string">&quot;ooders&quot;</span>, Ooders.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四步 获取创建的bean实例对象&quot;</span>);</span><br><span class="line">    System.out.println(ooders);</span><br><span class="line">    context4.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;ooders&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aiguigu.bean.Ooders&quot;</span> init-method=<span class="string">&quot;initMethod&quot;</span> destroy-method=<span class="string">&quot;destoryMethoh&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;oname&quot;</span> value=<span class="string">&quot;手机&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-11-哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#4-11-哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="4.11 哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>4.11 哪些是重要的bean生命周期方法？ 你能重载它们吗？</h3><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p>
<p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<h3 id="4-12-什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#4-12-什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="4.12 什么是Spring的内部bean？什么是Spring inner beans？"></a>4.12 什么是Spring的内部bean？什么是Spring inner beans？</h3><p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p>
<h3 id="4-13-在-Spring中如何注入一个java集合？"><a href="#4-13-在-Spring中如何注入一个java集合？" class="headerlink" title="4.13 在 Spring中如何注入一个java集合？"></a>4.13 在 Spring中如何注入一个java集合？</h3><p>Spring提供以下几种集合的配置元素：</p>
<p>类型用于注入一列值，允许有相同的值。</p>
<p>类型用于注入一组值，不允许有相同的值。</p>
<p>类型用于注入一组键值对，键和值都可以为任意类型。</p>
<p>类型用于注入一组键值对，键和值都只能为String类型。</p>
<h3 id="4-14-什么是bean装配？"><a href="#4-14-什么是bean装配？" class="headerlink" title="4.14 什么是bean装配？"></a>4.14 什么是bean装配？</h3><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
<h3 id="4-15-什么是bean的自动装配？"><a href="#4-15-什么是bean的自动装配？" class="headerlink" title="4.15 什么是bean的自动装配？"></a>4.15 什么是bean的自动装配？</h3><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p>
<h3 id="4-16-解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#4-16-解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="4.16 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>4.16 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h3><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<p>在Spring框架xml配置中共有5种自动装配：</p>
<ul>
<li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li>
<li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li>
<li>byType：通过参数的数据类型进行自动装配。</li>
<li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li>
<li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li>
</ul>
<h3 id="4-17-使用-Autowired注解自动装配的过程是怎样的？"><a href="#4-17-使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="4.17 使用@Autowired注解自动装配的过程是怎样的？"></a>4.17 使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<ul>
<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</li>
</ul>
<h3 id="4-18-自动装配有哪些局限性？"><a href="#4-18-自动装配有哪些局限性？" class="headerlink" title="4.18 自动装配有哪些局限性？"></a>4.18 自动装配有哪些局限性？</h3><p>自动装配的局限性是：</p>
<p><strong>重写</strong>：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p>
<p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p>
<p><strong>模糊特性</strong>：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p>
<h3 id="4-19-你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#4-19-你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="4.19 你可以在Spring中注入一个null 和一个空字符串吗？"></a>4.19 你可以在Spring中注入一个null 和一个空字符串吗？</h3><p>可以。</p>
<h2 id="5、Spring注解（8）"><a href="#5、Spring注解（8）" class="headerlink" title="5、Spring注解（8）"></a>5、Spring注解（8）</h2><h3 id="5-1-什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#5-1-什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="5.1 什么是基于Java的Spring注解配置? 给一些注解的例子"></a>5.1 什么是基于Java的Spring注解配置? 给一些注解的例子</h3><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>
<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p>
<p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-怎样开启注解装配？"><a href="#5-2-怎样开启注解装配？" class="headerlink" title="5.2 怎样开启注解装配？"></a>5.2 怎样开启注解装配？</h3><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 <code>&lt;context:annotation-config/&gt;</code>元素。</p>
<h3 id="5-3-Component-Controller-Repository-Service-有何区别？"><a href="#5-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="5.3 @Component, @Controller, @Repository, @Service 有何区别？"></a>5.3 @Component, @Controller, @Repository, @Service 有何区别？</h3><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>
<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>
<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>
<h3 id="5-4-Required-注解有什么作用"><a href="#5-4-Required-注解有什么作用" class="headerlink" title="5.4 @Required 注解有什么作用"></a>5.4 @Required 注解有什么作用</h3><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-Autowired-注解有什么作用"><a href="#5-5-Autowired-注解有什么作用" class="headerlink" title="5.5 @Autowired 注解有什么作用"></a>5.5 @Autowired 注解有什么作用</h3><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-Autowired和-Resource之间的区别"><a href="#5-6-Autowired和-Resource之间的区别" class="headerlink" title="5.6 @Autowired和@Resource之间的区别"></a>5.6 @Autowired和@Resource之间的区别</h3><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>
<p>@Autowired和@Resource之间的区别</p>
<ul>
<li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>
<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>
</ul>
<h3 id="5-7-Qualifier-注解有什么作用"><a href="#5-7-Qualifier-注解有什么作用" class="headerlink" title="5.7 @Qualifier 注解有什么作用"></a>5.7 @Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<h3 id="5-8-RequestMapping-注解有什么用？"><a href="#5-8-RequestMapping-注解有什么用？" class="headerlink" title="5.8 @RequestMapping 注解有什么用？"></a>5.8 @RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h3 id="5-9-Conditional的使用"><a href="#5-9-Conditional的使用" class="headerlink" title="5.9 @Conditional的使用"></a>5.9 @Conditional的使用</h3><p>作用：根据条件，决定类是否加载到Spring Ioc容器中，在SpringBoot中有大量的运用</p>
<p>应用场景：在一些需要条件满足才是实例化的类中，使用此注解，我曾经在项目中需要根据不同的场景使用不同的mq中间件的时候使用过，在mq的实例化bean上，加上此注解，根据配置文件的不同，来决定这个bean是否加载至ioc容器中。</p>
<h2 id="6、Spring数据访问（14）"><a href="#6、Spring数据访问（14）" class="headerlink" title="6、Spring数据访问（14）"></a>6、Spring数据访问（14）</h2><h3 id="6-1-解释对象-关系映射集成模块"><a href="#6-1-解释对象-关系映射集成模块" class="headerlink" title="6.1 解释对象/关系映射集成模块"></a>6.1 解释对象/关系映射集成模块</h3><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p>
<h3 id="6-2-在Spring框架中如何更有效地使用JDBC？"><a href="#6-2-在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="6.2 在Spring框架中如何更有效地使用JDBC？"></a>6.2 在Spring框架中如何更有效地使用JDBC？</h3><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p>
<h3 id="6-3-解释JDBC抽象和DAO模块"><a href="#6-3-解释JDBC抽象和DAO模块" class="headerlink" title="6.3 解释JDBC抽象和DAO模块"></a>6.3 解释JDBC抽象和DAO模块</h3><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p>
<h3 id="6-4-spring-DAO-有什么用？"><a href="#6-4-spring-DAO-有什么用？" class="headerlink" title="6.4 spring DAO 有什么用？"></a>6.4 spring DAO 有什么用？</h3><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h3 id="6-5-spring-JDBC-API-中存在哪些类？"><a href="#6-5-spring-JDBC-API-中存在哪些类？" class="headerlink" title="6.5 spring JDBC API 中存在哪些类？"></a>6.5 spring JDBC API 中存在哪些类？</h3><p>JdbcTemplate</p>
<p>SimpleJdbcTemplate</p>
<p>NamedParameterJdbcTemplate</p>
<p>SimpleJdbcInsert</p>
<p>SimpleJdbcCall</p>
<h3 id="6-6-JdbcTemplate是什么"><a href="#6-6-JdbcTemplate是什么" class="headerlink" title="6.6 JdbcTemplate是什么"></a>6.6 JdbcTemplate是什么</h3><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<h3 id="6-7-使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#6-7-使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="6.7 使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>6.7 使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>在Spring中有两种方式访问Hibernate：</p>
<ul>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ul>
<h3 id="6-8-如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#6-8-如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="6.8 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>6.8 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h3><p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p>
<ul>
<li>配置the Hibernate SessionFactory</li>
<li>继承HibernateDaoSupport实现一个DAO</li>
<li>在AOP支持的事务中装配</li>
</ul>
<h3 id="6-9-Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#6-9-Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="6.9 Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>6.9 Spring支持的事务管理类型， spring 事务实现方式有哪些？</h3><p>Spring支持两种类型的事务管理：</p>
<p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
<p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
<h3 id="6-10-Spring事务的实现方式和实现原理"><a href="#6-10-Spring事务的实现方式和实现原理" class="headerlink" title="6.10 Spring事务的实现方式和实现原理"></a>6.10 Spring事务的实现方式和实现原理</h3><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p>
<h3 id="6-11-说一下Spring的事务传播行为"><a href="#6-11-说一下Spring的事务传播行为" class="headerlink" title="6.11 说一下Spring的事务传播行为"></a>6.11 说一下Spring的事务传播行为</h3><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>
<p>① PROPAGATION_<strong>REQUIRED</strong>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>
<p>② PROPAGATION_<strong>SUPPORTS</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>
<p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
<p>④ PROPAGATION_<strong>REQUIRES_NEW</strong>：创建新事务，无论当前存不存在事务，都创建新事务。</p>
<p>⑤ PROPAGATION_NOT_<strong>SUPPORTED</strong>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>⑥ PROPAGATION_<strong>NEVER</strong>：以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>⑦ PROPAGATION_<strong>NESTED</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>
<h3 id="6-12-说一下-spring-的事务隔离？"><a href="#6-12-说一下-spring-的事务隔离？" class="headerlink" title="6.12 说一下 spring 的事务隔离？"></a>6.12 说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<ol>
<li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li>
<li>ISOLATION_READ_UNCOMMITTED：<strong>未提交读</strong>，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li>
<li>ISOLATION_READ_COMMITTED：<strong>提交读</strong>，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li>
<li>ISOLATION_REPEATABLE_READ：<strong>可重复读</strong>，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li>
<li>ISOLATION_SERIALIZABLE：可串行化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>
</ol>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h3 id="6-13-Spring框架的事务管理有哪些优点？"><a href="#6-13-Spring框架的事务管理有哪些优点？" class="headerlink" title="6.13 Spring框架的事务管理有哪些优点？"></a>6.13 Spring框架的事务管理有哪些优点？</h3><ul>
<li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li>
<li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li>
<li>支持声明式事务管理。</li>
<li>和Spring各种数据访问抽象层很好得集成。</li>
</ul>
<h3 id="6-14-你更倾向用那种事务管理类型？"><a href="#6-14-你更倾向用那种事务管理类型？" class="headerlink" title="6.14 你更倾向用那种事务管理类型？"></a>6.14 你更倾向用那种事务管理类型？</h3><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h2 id="7、Spring面向切面编程-AOP-（13）"><a href="#7、Spring面向切面编程-AOP-（13）" class="headerlink" title="7、Spring面向切面编程(AOP)（13）"></a>7、Spring面向切面编程(AOP)（13）</h2><h3 id="7-1-什么是AOP"><a href="#7-1-什么是AOP" class="headerlink" title="7.1 什么是AOP"></a>7.1 什么是AOP</h3><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP(Aspect-Oriented Programming)，一般称为==面向切面编程==，==<strong>作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</strong>==</p>
<h3 id="7-2-Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#7-2-Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="7.2 Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>7.2 Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<h3 id="7-3-JDK动态代理和CGLIB动态代理的区别"><a href="#7-3-JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="7.3 JDK动态代理和CGLIB动态代理的区别"></a>7.3 JDK动态代理和CGLIB动态代理的区别</h3><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<ul>
<li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li>
<li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li>
</ul>
<p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<blockquote>
<p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p>
</blockquote>
<h3 id="7-3-如何理解-Spring-中的代理？"><a href="#7-3-如何理解-Spring-中的代理？" class="headerlink" title="7.3 如何理解 Spring 中的代理？"></a>7.3 如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<p>Advice + Target Object = Proxy</p>
<h3 id="7-4-解释一下Spring-AOP里面的几个名词"><a href="#7-4-解释一下Spring-AOP里面的几个名词" class="headerlink" title="7.4 解释一下Spring AOP里面的几个名词"></a>7.4 解释一下Spring AOP里面的几个名词</h3><p>（1）<strong>切面（Aspect）</strong>：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>
<p>（2）<strong>连接点（Join point</strong>）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>（3）<strong>通知（Advice</strong>）：在AOP术语中，切面的工作被称为通知。</p>
<p>（4）<strong>切入点（Pointcut）</strong>：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p>（5）<strong>引入（Introduction）</strong>：引入允许我们向现有类添加新方法或属性。</p>
<p>（6）<strong>目标对象（Target Object）</strong>： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p>
<p>（7）<strong>织入（Weaving）</strong>：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p>
<ul>
<li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li>
<li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li>
<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li>
</ul>
<h3 id="7-5-Spring在运行时通知对象"><a href="#7-5-Spring在运行时通知对象" class="headerlink" title="7.5 Spring在运行时通知对象"></a>7.5 Spring在运行时通知对象</h3><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p>
<h3 id="7-6-Spring只支持方法级别的连接点"><a href="#7-6-Spring只支持方法级别的连接点" class="headerlink" title="7.6 Spring只支持方法级别的连接点"></a>7.6 Spring只支持方法级别的连接点</h3><p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p>
<h3 id="7-7-在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#7-7-在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="7.7 在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>7.7 在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p>
<p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h3 id="7-8-Spring通知有哪些类型？"><a href="#7-8-Spring通知有哪些类型？" class="headerlink" title="7.8 Spring通知有哪些类型？"></a>7.8 Spring通知有哪些类型？</h3><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<ol>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ol>
<blockquote>
<p>同一个aspect，不同advice的执行顺序：</p>
<p>①没有异常情况下的执行顺序：</p>
<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p>
<p>②有异常情况下的执行顺序：</p>
<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p>
</blockquote>
<h3 id="7-9-什么是切面-Aspect？"><a href="#7-9-什么是切面-Aspect？" class="headerlink" title="7.9 什么是切面 Aspect？"></a>7.9 什么是切面 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ul>
<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>
<li>如何在 advice 中编写切面代码.</li>
</ul>
<p>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/2020021212264438.png" alt="在这里插入图片描述" style="zoom:80%;" />

<h3 id="7-10-解释基于注解的切面实现"><a href="#7-10-解释基于注解的切面实现" class="headerlink" title="7.10 解释基于注解的切面实现"></a>7.10 解释基于注解的切面实现</h3><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p>
<h3 id="7-11-有几种不同类型的自动代理？"><a href="#7-11-有几种不同类型的自动代理？" class="headerlink" title="7.11 有几种不同类型的自动代理？"></a>7.11 有几种不同类型的自动代理？</h3><p>BeanNameAutoProxyCreator</p>
<p>DefaultAdvisorAutoProxyCreator</p>
<p>Metadata autoproxying</p>
<h3 id="7-12-AOP使用场景"><a href="#7-12-AOP使用场景" class="headerlink" title="7.12 AOP使用场景"></a>7.12 AOP使用场景</h3><ol>
<li>Authentication 权限检查        </li>
<li>Caching 缓存        </li>
<li>Context passing 内容传递        </li>
<li>Error handling 错误处理        </li>
<li>Lazy loading　延迟加载        </li>
<li>Debugging　　调试      </li>
<li>logging, tracing, profiling and monitoring　日志记录，跟踪，优化，校准        </li>
<li>Performance optimization　性能优化，效率检查        </li>
<li>Persistence　　持久化        </li>
<li>Resource pooling　资源池        </li>
<li>Synchronization　同步        </li>
<li>Transactions 事务管理  </li>
</ol>
<h3 id="7-13-过滤器filter、拦截器interceptor、和AOP的区别与联系"><a href="#7-13-过滤器filter、拦截器interceptor、和AOP的区别与联系" class="headerlink" title="7.13 过滤器filter、拦截器interceptor、和AOP的区别与联系"></a>7.13 过滤器filter、拦截器interceptor、和AOP的区别与联系</h3><blockquote>
<h4 id="filter过滤器"><a href="#filter过滤器" class="headerlink" title="filter过滤器"></a>filter过滤器</h4></blockquote>
<ul>
<li>  <strong>过滤器拦截web访问url地址</strong>。 严格意义上讲，filter只是适用于web中，依赖于Servlet容器，利用<strong>Java的回调机制</strong>进行实现。</li>
<li>  Filter<strong>过滤器</strong>：和框架无关，可以控制最初的http请求，但是更细一点的类和方法控制不了。</li>
<li>  **过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletResponse response)**，并对请求响应做出像响应的过滤操作，</li>
<li>  比如<strong>设置字符编码，鉴权操作</strong>等</li>
</ul>
<blockquote>
<h4 id="Interceptor拦截器"><a href="#Interceptor拦截器" class="headerlink" title="Interceptor拦截器"></a>Interceptor拦截器</h4></blockquote>
<ul>
<li>  <strong>拦截器拦截以 .action结尾的url，拦截Action的访问</strong>。 Interfactor是基于<strong>Java的反射机制</strong>（APO思想）进行实现，不依赖Servlet容器。</li>
<li>  <strong>拦截器可以在方法执行之前(preHandle)和方法执行之后(afterCompletion)进行操作，回调操作(postHandle)<strong>，</strong>可以获取执行的方法的名称</strong>，请求(HttpServletRequest)</li>
<li>  Interceptor：<strong>可以控制请求的控制器和方法</strong>，但<strong>控制不了请求方法里的参数(只能获取参数的名称，不能获取到参数的值)</strong></li>
<li>  <strong>（</strong>用于处理页面提交的请求响应并进行处理，例如做国际化，做主题更换，过滤等）。</li>
</ul>
<blockquote>
<h4 id="Spring-AOP拦截器"><a href="#Spring-AOP拦截器" class="headerlink" title="Spring AOP拦截器"></a>Spring AOP拦截器</h4></blockquote>
<ul>
<li>  <strong>只能拦截Spring管理Bean的访问（业务层Service）</strong>。 具体AOP详情参照 <a target="_blank" rel="noopener" href="https://blog.csdn.net/fly910905/article/details/84025425">Spring AOP：原理、 通知、连接点、切点、切面、表达式</a></li>
<li>  实际开发中，AOP常和事务结合：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fly910905/article/details/83547744">Spring的事务管理:声明式事务管理(切面)</a></li>
<li>  <strong>AOP操作可以对操作进行横向的拦截</strong>，最大的优势在于他可**以获取执行方法的参数( ProceedingJoinPoint.getArgs() )**，对方法进行统一的处理。</li>
<li>Aspect : 可以自定义切入的点，有方法的参数，<strong>但是拿不到http请求，可以通过其他方式如RequestContextHolder</strong>获得(<br>  ServletRequestAttributes servletRequestAttributes= (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>  )。</li>
<li>  常见**使用日志，事务，请求参数安全验证</li>
</ul>
<h2 id="8、Spring-Transactional"><a href="#8、Spring-Transactional" class="headerlink" title="8、Spring @Transactional"></a>8、Spring @Transactional</h2><h3 id="8-1-工作原理"><a href="#8-1-工作原理" class="headerlink" title="8.1 工作原理"></a>8.1 工作原理</h3><ol>
<li>当spring遍历容器中所有的切面，查找与当前实例化bean匹配的切面，这里就是获取事务属性切面，查找@Transactional注解及其属性值，然后根据得到的切面进入createProxy方法，创建一个AOP代理。</li>
<li>默认是使用JDK动态代理创建代理，如果目标类是接口，则使用JDK动态代理，否则使用Cglib。</li>
<li>获取的是当前目标方法对应的拦截器，里面是根据之前获取到的切面来获取相对应拦截器，这时候会得到TransactionInterceptor实例。如果获取不到拦截器，则不会创建MethodInvocation，直接调用目标方法。</li>
<li>在需要进行事务操作的时候，Spring会在调用目标类的目标方法之前进行开启事务、调用异常回滚事务、调用完成会提交事务。是否需要开启新事务，是根据@Transactional注解上配置的参数值来判断的。如果需要开启新事务，获取Connection连接，然后将连接的自动提交事务改为false，改为手动提交</li>
<li>Spring并不会对所有类型异常都进行事务回滚操作，默认是只对Unchecked Exception(Error和RuntimeException)进行事务回滚操作。</li>
</ol>
<p>从上面的分析可以看到，Spring使用AOP实现事务的统一管理,基本都是下面这两种情况：</p>
<ol>
<li>A类的a1方法没有标注@Transactional，a2方法标注@Transactional，在a1里面调用a2。a1方法是目标类A的原生方法，调用a1的时候即直接进入目标类A进行调用，在目标类A里面只有a2的原生方法，在a1里调用a2，即直接执行a2的原生方法，并不通过创建代理对象进行调用，所以并不会进入TransactionInterceptor的invoke方法，不会开启事务。</li>
<li>将@Transactional注解标注在非public方法上。内部使用AOP，所以必须是public修饰的方法才可以被代理</li>
</ol>
<h3 id="8-2-参数配置"><a href="#8-2-参数配置" class="headerlink" title="8.2 参数配置"></a>8.2 参数配置</h3><ol>
<li>propagation参数，Propagation类型（枚举），默认值为Propogation.REQUIRED，支持的值有REQUIRED、MANDATORY、NESTED、NEVER、NOT_SUPPORTED、REQUIRE_NEW、SUPPORTS。关于这个问题的详细说明将在以后的文章中展开。</li>
<li>isolation参数，Isolation类型（枚举），默认值为Isolation.DEFAULT，支持的值有DEFAULT、READ_COMMITTED、READ_UNCOMMITTED、REPEATABLE_READ、SERIALIZABLE。关于这个问题的详细说明将在以后的文章中展开。</li>
<li>timeout参数，int类型，事务的超时时间，默认值为-1，即不会超时。</li>
<li>readOnly参数，boolean类型，true表示事务为只读，默认值为false。</li>
<li>rollbackFor参数，Class&lt;? extends Throwable&gt;[]类型，默认为空数组。</li>
<li>rollbackForClassName参数，String[]类型，默认为空数组。</li>
<li>noRollbackFor参数，Class&lt;? extends Throwable&gt;[]类型，默认为空数组。</li>
<li>noRollbackForClassName参数，String[]类型，默认为空数组。</li>
</ol>
<p>最后四个参数都与回滚有关，首先，一般不推荐使用rollbackForClassName和noRollbackForClassName两个参数，而用另外两个参数来代替，从参数的类型上就可以看出区别，使用字符串的缺点在于：如果不是用类的完整路径，就可能导致回滚设置对位于不同包中的同名类都生效；且如果类名写错，也无法得到IDE的动态提示。</p>
<p>但是，如果不配置任何与回滚有关的参数，不代表事务不会进行回滚，如果没有配置这四个选项，那么DefaultTransactionAttribute配置将会生效，具体的行为是，抛掷任何unchecked Exception都会触发回滚，当然包括所有的RuntimeException。</p>
<h3 id="8-3-Spring事务什么情况下回滚？"><a href="#8-3-Spring事务什么情况下回滚？" class="headerlink" title="8.3 Spring事务什么情况下回滚？"></a>8.3 Spring事务什么情况下回滚？</h3><p>Spring事务回滚机制是这样的：当所拦截的方法有指定异常抛出，事务才会自动进行回滚。</p>
<p>默认配置下，事务只会对Error与RuntimeException及其子类这些UNChecked异常，做出回滚。一般的Exception这些Checked异常不会发生回滚（如果一般Exception想回滚要做出配置）；</p>
<h3 id="8-4-Spring事务trycatch会回滚吗？"><a href="#8-4-Spring事务trycatch会回滚吗？" class="headerlink" title="8.4 Spring事务trycatch会回滚吗？"></a>8.4 Spring事务trycatch会回滚吗？</h3><p>依赖spring事物时，当service层进行try catch异常捕获时，事物不会产生回滚，代码如下 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertMsg</span><span class="params">(ConversationBean conversationBean)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">10</span>)&#123;</span><br><span class="line">                testDao.insert2(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                testDao.insert1(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时异常被捕获，这种业务方法也就等于脱离了spring事务的管理，因为没有任何异常会从业务方法中抛出，全被捕获，导致spring异常抛出触发事务回滚策略失效。</p>
<p>解决此类问题时，需要在try catch中显示的抛出异常RuntimeException 然后在Controller层捕获异常并编写返回值，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertMsg</span><span class="params">(ConversationBean conversationBean)</span></span>&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(i!=<span class="number">10</span>)&#123;</span><br><span class="line">                 testDao.insert2(i);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 testDao.insert1(i);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">刘恒运</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/01/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%BD%91%E7%BB%9C/">http://example.com/2021/08/01/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">luckforever</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/IOC%E5%8E%9F%E7%90%86/">IOC原理</a><a class="post-meta__tags" href="/tags/AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/">AOP面向切面编程</a><a class="post-meta__tags" href="/tags/Spring%E6%B3%A8%E8%A7%A3/">Spring注解</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/image-20210909092240317.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/01/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/spring-1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring源码分析</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/31/Spring/"><img class="next-cover" src="https://gitee.com/liu-hengyun/lhy/raw/master/images/spring/image-20210904221506360.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/个人照片/刘恒运.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">刘恒运</div><div class="author-info__description">学习录</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">不求事事如人意，但求无愧于我心！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">1.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Spring%E6%A6%82%E8%BF%B0%EF%BC%8811%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1、Spring概述（11）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFspring"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 什么是spring?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%EF%BC%8C%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%EF%BC%8C%E5%92%8C%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 Spring框架的设计目标，设计理念，和核心是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Spring%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 Spring的优缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Spring%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 Spring有哪些应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-Spring%E7%94%B1%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 Spring由哪些模块组成？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 Spring 框架中都用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8B%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%EF%BC%88spring-context%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87-%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7 详细讲解一下核心容器（spring context应用上下文) 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.1.8.</span> <span class="toc-text">1.8 Spring框架中有哪些不同类型的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-Spring-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.1.9.</span> <span class="toc-text">1.9 Spring 应用程序有哪些不同组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E4%BD%BF%E7%94%A8-Spring-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.1.10.</span> <span class="toc-text">1.10 使用 Spring 有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-Spring%E5%92%8CSpringMVC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.11.</span> <span class="toc-text">1.11 Spring和SpringMVC的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81-Spring%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IOC-%EF%BC%8813%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">2、 Spring控制反转(IOC)（13）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AFSpring-IOC-%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 什么是Spring IOC 容器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IoC-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 控制反转(IoC)有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-IOC%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 IOC的优点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Spring-IoC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 Spring IoC 的实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Spring-%E7%9A%84-IoC%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 Spring 的 IoC支持哪些功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81IOC%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3、IOC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-BeanFactory-%E5%92%8C-ApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1  BeanFactory 和 ApplicationContext有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">加载方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">注册方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Spring-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%B9%E5%99%A8%E7%9A%84%EF%BC%8CBeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-ApplicationContext%E9%80%9A%E5%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 ApplicationContext通常的实现是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Spring%E5%8D%95%E4%BE%8BBean%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 Spring单例Bean与单例模式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 什么是Spring的依赖注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 依赖注入的基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7 依赖注入有什么优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.3.8.</span> <span class="toc-text">3.8 有哪些不同类型的依赖注入实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C-Setter%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.9.</span> <span class="toc-text">构造器依赖注入和 Setter方法注入的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Spring-Beans%EF%BC%8819%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">4、Spring Beans（19）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AFSpring-beans%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 什么是Spring beans？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%B8%80%E4%B8%AA-Spring-Bean-%E5%AE%9A%E4%B9%89-%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 一个 Spring Bean 定义 包含什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%A6%82%E4%BD%95%E7%BB%99Spring-%E5%AE%B9%E5%99%A8%E6%8F%90%E4%BE%9B%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%9FSpring%E6%9C%89%E5%87%A0%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 如何给Spring 容器提供配置元数据？Spring有几种配置方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 Spring配置文件包含了哪些信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Spring%E5%9F%BA%E4%BA%8Exml%E6%B3%A8%E5%85%A5bean%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 Spring基于xml注入bean的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E4%BD%A0%E6%80%8E%E6%A0%B7%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">1.4.6.</span> <span class="toc-text">4.6 你怎样定义类的作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E8%A7%A3%E9%87%8ASpring%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8Dbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.7.</span> <span class="toc-text">4.7 解释Spring支持的几种bean的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8Bbean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">1.4.8.</span> <span class="toc-text">4.8 Spring框架中的单例bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-Spring%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.4.9.</span> <span class="toc-text">4.9 Spring如何处理线程并发问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-%E8%A7%A3%E9%87%8ASpring%E6%A1%86%E6%9E%B6%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.10.</span> <span class="toc-text">4.10 解释Spring框架中bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-%E5%93%AA%E4%BA%9B%E6%98%AF%E9%87%8D%E8%A6%81%E7%9A%84bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%EF%BC%9F-%E4%BD%A0%E8%83%BD%E9%87%8D%E8%BD%BD%E5%AE%83%E4%BB%AC%E5%90%97%EF%BC%9F"><span class="toc-number">1.4.11.</span> <span class="toc-text">4.11 哪些是重要的bean生命周期方法？ 你能重载它们吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E5%86%85%E9%83%A8bean%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFSpring-inner-beans%EF%BC%9F"><span class="toc-number">1.4.12.</span> <span class="toc-text">4.12 什么是Spring的内部bean？什么是Spring inner beans？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-13-%E5%9C%A8-Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5%E4%B8%80%E4%B8%AAjava%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-number">1.4.13.</span> <span class="toc-text">4.13 在 Spring中如何注入一个java集合？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-14-%E4%BB%80%E4%B9%88%E6%98%AFbean%E8%A3%85%E9%85%8D%EF%BC%9F"><span class="toc-number">1.4.14.</span> <span class="toc-text">4.14 什么是bean装配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-15-%E4%BB%80%E4%B9%88%E6%98%AFbean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%9F"><span class="toc-number">1.4.15.</span> <span class="toc-text">4.15 什么是bean的自动装配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-16-%E8%A7%A3%E9%87%8A%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%8Cspring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-bean-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.4.16.</span> <span class="toc-text">4.16 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-17-%E4%BD%BF%E7%94%A8-Autowired%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.4.17.</span> <span class="toc-text">4.17 使用@Autowired注解自动装配的过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-18-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%80%E9%99%90%E6%80%A7%EF%BC%9F"><span class="toc-number">1.4.18.</span> <span class="toc-text">4.18 自动装配有哪些局限性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-19-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%9C%A8Spring%E4%B8%AD%E6%B3%A8%E5%85%A5%E4%B8%80%E4%B8%AAnull-%E5%92%8C%E4%B8%80%E4%B8%AA%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%97%EF%BC%9F"><span class="toc-number">1.4.19.</span> <span class="toc-text">4.19 你可以在Spring中注入一个null 和一个空字符串吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Spring%E6%B3%A8%E8%A7%A3%EF%BC%888%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">5、Spring注解（8）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8EJava%E7%9A%84Spring%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE-%E7%BB%99%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 什么是基于Java的Spring注解配置? 给一些注解的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%80%8E%E6%A0%B7%E5%BC%80%E5%90%AF%E6%B3%A8%E8%A7%A3%E8%A3%85%E9%85%8D%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 怎样开启注解装配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Component-Controller-Repository-Service-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 @Component, @Controller, @Repository, @Service 有何区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Required-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 @Required 注解有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Autowired-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 @Autowired 注解有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-Autowired%E5%92%8C-Resource%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.6 @Autowired和@Resource之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-Qualifier-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.7 @Qualifier 注解有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-RequestMapping-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.5.8.</span> <span class="toc-text">5.8 @RequestMapping 注解有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-Conditional%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.9.</span> <span class="toc-text">5.9 @Conditional的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Spring%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%8814%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">6、Spring数据访问（14）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E8%A7%A3%E9%87%8A%E5%AF%B9%E8%B1%A1-%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%E9%9B%86%E6%88%90%E6%A8%A1%E5%9D%97"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 解释对象&#x2F;关系映射集成模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%9C%A8Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9B%B4%E6%9C%89%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8JDBC%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 在Spring框架中如何更有效地使用JDBC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E8%A7%A3%E9%87%8AJDBC%E6%8A%BD%E8%B1%A1%E5%92%8CDAO%E6%A8%A1%E5%9D%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 解释JDBC抽象和DAO模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-spring-DAO-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 spring DAO 有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-spring-JDBC-API-%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5 spring JDBC API 中存在哪些类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-JdbcTemplate%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.6 JdbcTemplate是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E4%BD%BF%E7%94%A8Spring%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AEHibernate%EF%BC%9F%E4%BD%BF%E7%94%A8-Spring-%E8%AE%BF%E9%97%AE-Hibernate-%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.6.7.</span> <span class="toc-text">6.7 使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87HibernateDaoSupport%E5%B0%86Spring%E5%92%8CHibernate%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5%EF%BC%9F"><span class="toc-number">1.6.8.</span> <span class="toc-text">6.8 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-Spring%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%8C-spring-%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.6.9.</span> <span class="toc-text">6.9 Spring支持的事务管理类型， spring 事务实现方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.10.</span> <span class="toc-text">6.10 Spring事务的实现方式和实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-%E8%AF%B4%E4%B8%80%E4%B8%8BSpring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.6.11.</span> <span class="toc-text">6.11 说一下Spring的事务传播行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-%E8%AF%B4%E4%B8%80%E4%B8%8B-spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9F"><span class="toc-number">1.6.12.</span> <span class="toc-text">6.12 说一下 spring 的事务隔离？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-13-Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">1.6.13.</span> <span class="toc-text">6.13 Spring框架的事务管理有哪些优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-14-%E4%BD%A0%E6%9B%B4%E5%80%BE%E5%90%91%E7%94%A8%E9%82%A3%E7%A7%8D%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.6.14.</span> <span class="toc-text">6.14 你更倾向用那种事务管理类型？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Spring%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-AOP-%EF%BC%8813%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">7、Spring面向切面编程(AOP)（13）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AFAOP"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 什么是AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Spring-AOP-and-AspectJ-AOP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9FAOP-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 JDK动态代理和CGLIB动态代理的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.3 如何理解 Spring 中的代理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BSpring-AOP%E9%87%8C%E9%9D%A2%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8D%E8%AF%8D"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.4 解释一下Spring AOP里面的几个名词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-Spring%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%80%9A%E7%9F%A5%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.5 Spring在运行时通知对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-Spring%E5%8F%AA%E6%94%AF%E6%8C%81%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%82%B9"><span class="toc-number">1.7.7.</span> <span class="toc-text">7.6 Spring只支持方法级别的连接点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E5%9C%A8Spring-AOP-%E4%B8%AD%EF%BC%8C%E5%85%B3%E6%B3%A8%E7%82%B9%E5%92%8C%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8-spring-aop-%E4%B8%AD-concern-%E5%92%8C-cross-cutting-concern-%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">1.7.8.</span> <span class="toc-text">7.7 在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-Spring%E9%80%9A%E7%9F%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.7.9.</span> <span class="toc-text">7.8 Spring通知有哪些类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%87%E9%9D%A2-Aspect%EF%BC%9F"><span class="toc-number">1.7.10.</span> <span class="toc-text">7.9 什么是切面 Aspect？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-%E8%A7%A3%E9%87%8A%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.11.</span> <span class="toc-text">7.10 解释基于注解的切面实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-%E6%9C%89%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-number">1.7.12.</span> <span class="toc-text">7.11 有几种不同类型的自动代理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-12-AOP%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.7.13.</span> <span class="toc-text">7.12 AOP使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-13-%E8%BF%87%E6%BB%A4%E5%99%A8filter%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8interceptor%E3%80%81%E5%92%8CAOP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">1.7.14.</span> <span class="toc-text">7.13 过滤器filter、拦截器interceptor、和AOP的区别与联系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#filter%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.7.14.1.</span> <span class="toc-text">filter过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Interceptor%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.7.14.2.</span> <span class="toc-text">Interceptor拦截器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.7.14.3.</span> <span class="toc-text">Spring AOP拦截器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Spring-Transactional"><span class="toc-number">1.8.</span> <span class="toc-text">8、Spring @Transactional</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 参数配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Spring%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%9B%9E%E6%BB%9A%EF%BC%9F"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 Spring事务什么情况下回滚？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-Spring%E4%BA%8B%E5%8A%A1trycatch%E4%BC%9A%E5%9B%9E%E6%BB%9A%E5%90%97%EF%BC%9F"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 Spring事务trycatch会回滚吗？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/07/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%BD%91%E7%BB%9C/" title="SpringMVC面试"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/springmvc/image-20210905105137663.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC面试"/></a><div class="content"><a class="title" href="/2021/08/07/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E7%BD%91%E7%BB%9C/" title="SpringMVC面试">SpringMVC面试</a><time datetime="2021-08-07T09:00:00.000Z" title="发表于 2021-08-07 17:00:00">2021-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/07/SpringMVC-%E7%BD%91%E7%BB%9C/" title="SpringMVC"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/springmvc/image-20210905125144476.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC"/></a><div class="content"><a class="title" href="/2021/08/07/SpringMVC-%E7%BD%91%E7%BB%9C/" title="SpringMVC">SpringMVC</a><time datetime="2021-08-07T05:00:00.000Z" title="发表于 2021-08-07 13:00:00">2021-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/05/mybatis%20-%20%E7%BD%91%E7%BB%9C/" title="Mybatis"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/mybatis/1569633932712.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis"/></a><div class="content"><a class="title" href="/2021/08/05/mybatis%20-%20%E7%BD%91%E7%BB%9C/" title="Mybatis">Mybatis</a><time datetime="2021-08-05T02:00:00.000Z" title="发表于 2021-08-05 10:00:00">2021-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/02/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E5%89%AF%E6%9C%AC/" title="MyBatis面试题"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/mybatis%E9%9D%A2%E8%AF%95%E9%A2%98/1569660357745.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis面试题"/></a><div class="content"><a class="title" href="/2021/08/02/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E5%89%AF%E6%9C%AC/" title="MyBatis面试题">MyBatis面试题</a><time datetime="2021-08-02T09:00:00.000Z" title="发表于 2021-08-02 17:00:00">2021-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/01/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20%E7%BD%91%E7%BB%9C/" title="Spring源码分析"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/Spring%E9%9D%A2%E8%AF%95/spring-1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring源码分析"/></a><div class="content"><a class="title" href="/2021/08/01/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20%E7%BD%91%E7%BB%9C/" title="Spring源码分析">Spring源码分析</a><time datetime="2021-08-01T09:00:00.000Z" title="发表于 2021-08-01 17:00:00">2021-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 刘恒运</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>