<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM | luckforever</title><meta name="keywords" content="-JVM"><meta name="author" content="刘恒运"><meta name="copyright" content="刘恒运"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="请谈谈你对JVM的理解？java8虚拟机和之前的变化更新？  什么是OOM，什么是栈溢出StackOVerFlowError？怎么分析？ JVM常用的调优参数有哪些？ 内存快照如何抓取？怎么分析Dump文件？ 谈谈JVM中，类加载器你的认识？rt.jar  JVM的体系结构 JVM的位置     JVM结构   类加载器和双亲委派类的加载过程类的生命周期  类加载过程系统加载 Class 类型的文">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2021/05/06/JVM%20-%20%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="luckforever">
<meta property="og:description" content="请谈谈你对JVM的理解？java8虚拟机和之前的变化更新？  什么是OOM，什么是栈溢出StackOVerFlowError？怎么分析？ JVM常用的调优参数有哪些？ 内存快照如何抓取？怎么分析Dump文件？ 谈谈JVM中，类加载器你的认识？rt.jar  JVM的体系结构 JVM的位置     JVM结构   类加载器和双亲委派类的加载过程类的生命周期  类加载过程系统加载 Class 类型的文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731191949036.png">
<meta property="article:published_time" content="2021-05-06T00:00:00.000Z">
<meta property="article:modified_time" content="2021-07-31T14:42:03.877Z">
<meta property="article:author" content="刘恒运">
<meta property="article:tag" content="-类的加载过程 -运行时数据区 -GC垃圾回收">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731191949036.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/05/06/JVM%20-%20%E7%BD%91%E7%BB%9C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-31 22:42:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="luckforever" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw iconfont icon-fenxiang"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-shuji"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/FilmAndTV/"><i class="fa-fw iconfont icon-yingshi1"></i><span> 影视</span></a></li><li><a class="site-page child" href="/daohang/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731191949036.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">luckforever</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw iconfont icon-liaotian-04"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw iconfont icon-fenxiang"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw iconfont icon-shuji"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/FilmAndTV/"><i class="fa-fw iconfont icon-yingshi1"></i><span> 影视</span></a></li><li><a class="site-page child" href="/daohang/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-06T00:00:00.000Z" title="发表于 2021-05-06 08:00:00">2021-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-31T14:42:03.877Z" title="更新于 2021-07-31 22:42:03">2021-07-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">-JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>请谈谈你对JVM的理解？java8虚拟机和之前的变化更新？</p>
<ul>
<li>什么是OOM，什么是栈溢出StackOVerFlowError？怎么分析？</li>
<li>JVM常用的调优参数有哪些？</li>
<li>内存快照如何抓取？怎么分析Dump文件？</li>
<li>谈谈JVM中，类加载器你的认识？<code>rt.jar</code></li>
</ul>
<h1 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h1><blockquote>
<p>JVM的位置</p>
</blockquote>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731191949036.png" alt="image-20210731191949036"  />

<blockquote>
<p>JVM结构</p>
</blockquote>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/37d12f2eb9389b50828b0dfd61271ed9e6116ec5.jpeg" alt="JVM结构"></p>
<h1 id="类加载器和双亲委派"><a href="#类加载器和双亲委派" class="headerlink" title="类加载器和双亲委派"></a>类加载器和双亲委派</h1><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731112058469.png" alt="image-20210731112058469" style="zoom:80%;" />

<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>系统加载 Class 类型的文件主要三步:<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>类加载过程的第一步，主要完成下面3件事情：</p>
<ol>
<li>==通过全类名获取定义此类的二进制字节流==</li>
<li>==将字节流所代表的静态存储结构转换为方法区的运行时数据结构==</li>
<li>==在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口==</li>
</ol>
<p>虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如：“通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p>
<p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p>
<p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p>
<p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>
<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><blockquote>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5></blockquote>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731112407307.png" alt="image-20210731112407307" style="zoom:80%;" />

<blockquote>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5></blockquote>
<p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ol>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
<li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li>
</ol>
<p><strong>基本数据类型的零值：</strong></p>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731112527785.png" alt="image-20210731112527785" style="zoom:80%;" />

<blockquote>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5></blockquote>
<p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>​        <strong>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程。</strong></p>
<p>对于<code>&lt;clinit&gt;（）</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;（）</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p>
<p>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p>
<ol>
<li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</li>
</ol>
<ul>
<li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li>
<li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>
<li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li>
<li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li>
</ul>
<ol>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 ，如果类没初始化，需要触发其初始化。</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li>
<li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</li>
<li><strong>「补充，来自issue745」</strong> 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><p>卸载类即该类的Class对象被GC。</p>
<p>卸载类需要满足3个要求:</p>
<ol>
<li><strong>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</strong></li>
<li><strong>该类没有在其他任何地方被引用</strong></li>
<li><strong>该类的类加载器的实例已被GC</strong></li>
</ol>
<p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h2 id="对象实例化过程"><a href="#对象实例化过程" class="headerlink" title="对象实例化过程"></a>对象实例化过程</h2><p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200722054641601.png" alt="对象实例化"></p>
<p><strong>类加载器就是用来加载<code>.class</code>文件，到<code>JVM</code>中变成<code>Class</code>文件</strong>。</p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731113939805.png" alt="image-20210731113939805"></p>
<h2 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h2><p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/u=977934582,3403249916&fm=26&gp=0.jpg" alt="类加载器"></p>
<ul>
<li><p><strong>启动类加载器</strong>：这个类加载器负责放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的类库。==用户无法直接使用==。</p>
</li>
<li><p><strong>扩展类加载器</strong>：这个类加载器由<code>sun.misc.Launcher$ExtClassLoader</code>r实现。它负责<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。==用户可以直接使用==。</p>
</li>
<li><p><strong>应用程序类加载器</strong>：这个类由<code>sun.misc.Launcher$AppClassLoader</code>实现。是<code>ClassLoader中getSystemClassLoader()</code>方法的返回值。它负责用户路径（ClassPath）所指定的类库。用户可以直接使用。==如果用户没有自己定义类加载器，默认使用这个==。</p>
</li>
<li><p><strong>自定义加载器</strong>：用户自己定义的类加载器。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ymy.jvm;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 类是模板,对象是具体的</span></span><br><span class="line">		</span><br><span class="line">		Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">		Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line">		Car car3 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">		System.out.println(car1.hashCode()); <span class="comment">// 366712642</span></span><br><span class="line">		System.out.println(car2.hashCode()); <span class="comment">// 1829164700</span></span><br><span class="line">		System.out.println(car3.hashCode()); <span class="comment">// 2018699554</span></span><br><span class="line"></span><br><span class="line">		Class&lt;? extends Car&gt; class1 = car1.getClass();</span><br><span class="line">		Class&lt;? extends Car&gt; class2 = car2.getClass();</span><br><span class="line">		Class&lt;? extends Car&gt; class3 = car3.getClass();</span><br><span class="line"></span><br><span class="line">		System.out.println(class1.hashCode()); <span class="comment">// 705927765</span></span><br><span class="line">		System.out.println(class2.hashCode()); <span class="comment">// 705927765</span></span><br><span class="line">		System.out.println(class3.hashCode()); <span class="comment">// 705927765</span></span><br><span class="line">		</span><br><span class="line">		ClassLoader classLoader1 = class1.getClassLoader();</span><br><span class="line">		</span><br><span class="line">		System.out.println(classLoader1); <span class="comment">// sun.misc.Launcher$AppClassLoader@73d16e93</span></span><br><span class="line">		System.out.println(classLoader1.getParent()); <span class="comment">// sun.misc.Launcher$ExtClassLoader@4e25154f</span></span><br><span class="line">		System.out.println(classLoader1.getParent().getParent()); <span class="comment">// null 这里是启动类加载器,用户根本就获取不到，所以返回的是null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ul>
<li>第一步：类加载器收到类加载的请求。</li>
<li>第二步：将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器。</li>
<li>第三步：启动类加载器检查是否能够加载当前这个类，能加载就结束，使用当前加载器；否则，抛出异常，通知子加载器。</li>
<li>第四步：重复步骤三，一直找到不到就会抛出<code>ClassNotFoundException</code>异常。</li>
</ul>
<h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>​        双亲委派模型保证了Java程序的稳定运行，可以<strong>避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），<strong>也保证了 Java 的核心 API 不被篡改。</strong>如果不用没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<h3 id="如果我们不想用双亲委派模型怎么办？"><a href="#如果我们不想用双亲委派模型怎么办？" class="headerlink" title="如果我们不想用双亲委派模型怎么办？"></a>如果我们不想用双亲委派模型怎么办？</h3><p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重载 <code>loadClass()</code> 即可。</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>。</p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>​        自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt. jar包中java\lang\String. class)，报错信息说没有main方法，.就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200722172211603.png" alt="JVM"></p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈非常相似，区别在于本地方法栈为虚拟机的Native方法服务【管理本地方法】；Hotspot将JVM栈和本地方法栈合二为一</p>
<ul>
<li><strong>凡是带了<code>native</code>关键字的，说明java的作用范围达不到了，需要回去调用本地C语言的库。这些本地方法会进入到本地方法栈(Native Method Stack)，调用本地方法接口(Java Native Interface)，就可以调用本地方法库了！</strong></li>
<li><strong>JNI的作用：扩展Java的使用，融合不同的编程语言为Java所用！最初是融合C、C++。Java诞生的时候C、C++横行，Java想要立足，必须要有调用C、C++的方法。</strong></li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器：Program Counter Register。</p>
<p>**==每个线程都有一个程序计数器，是线程私有的==<strong>，由于CPU执行指令是可中断的，会有线程切换，程序计数器会</strong>记录当前线程执行的字节码指令地址(**行号)，以便线程切换后能恢复到正确的执行位置。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731115248277.png" alt="image-20210731115248277" style="zoom:80%;" />

<p>​        方法区与 Java 堆一样，==<strong>是各个线程共享的内存区域</strong>==，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来，在JVM启动时创建，并且它的实际的物理内存空间和java堆区一样都可以是不连续的。</p>
<p><strong>==类信息（构造方法、接口定义）、常量（final）、静态变量（static）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关。==</strong></p>
<h4 id="方法区和永久代的关系"><a href="#方法区和永久代的关系" class="headerlink" title="方法区和永久代的关系"></a>方法区和永久代的关系</h4><blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。  <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。</p>
</blockquote>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>

<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。**</p>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>

<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<h4 id="为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?"></a>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h4><p>整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<p>当然这只是其中一个原因，还有很多底层的原因，这里就不提了。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>​        运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p>
<ul>
<li><strong>常量池表</strong>(Constant Pool Table) 是Class文件的一部分， 用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是:具备动态性。</li>
<li>运行时常量池类似于传统编程语言中的符号表(symbol table) ，但是它所包含的数 据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outOfMemoryError异常。</li>
</ul>
<p><strong>常量池有什么：</strong></p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/26038433.jpg"></p>
<h3 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h3><p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731115951616.png" alt="image-20210731115951616"></p>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731120010981.png" alt="image-20210731120010981" style="zoom:67%;" />

<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731120053227.png" alt="image-20210731120053227" style="zoom:67%;" />

<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731120115004.png" alt="image-20210731120115004" style="zoom:67%;" />

<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h2 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a>JVM栈</h2><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731120320792.png" alt="image-20210731120320792"  />

<p>栈：栈内存，主管程序的运行，生命周期和线程同步；线程结束，栈内存也就释放，==<strong>对于栈来说，不存在垃圾回收。</strong>==</p>
<p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>可以理解为用于计算的临时数据存储区，使用load指令将数据加载到此</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接（多态，编译期没有指明运行时才指明对象），【指向运行时常量池中方法的引用】</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>记录出站地址即方法返回地址或者异常地址</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p>
<ul>
<li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。</li>
<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>栈中存放的数据：8大基本数据类型(byte、short、int、long、float、double、boolean、char)、对象引用、实例的方法。</strong></p>
<blockquote>
<p>栈运行流程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ymy.jvm;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行顺序：</span></span><br><span class="line"><span class="comment"> * main方法开始...</span></span><br><span class="line"><span class="comment"> * add()....</span></span><br><span class="line"><span class="comment"> * increment()....</span></span><br><span class="line"><span class="comment"> * test()....</span></span><br><span class="line"><span class="comment"> * main方法结束...</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 执行流程：</span></span><br><span class="line"><span class="comment"> * 1.打印&quot;main方法开始...&quot;,main()进栈;</span></span><br><span class="line"><span class="comment"> * 2.add()进栈,打印&quot;add()....&quot;;</span></span><br><span class="line"><span class="comment"> * 3.increment()进栈,打印&quot;increment()....&quot;;</span></span><br><span class="line"><span class="comment"> * 4.increment()执行完毕出栈;</span></span><br><span class="line"><span class="comment"> * 5.add()执行完毕出栈;</span></span><br><span class="line"><span class="comment"> * 6.test()进栈,打印&quot;test()....&quot;;</span></span><br><span class="line"><span class="comment"> * 7.test()执行完毕出栈;</span></span><br><span class="line"><span class="comment"> * 8.打印&quot;main方法结束...&quot;,main()出栈。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法开始...&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">		stack.add();</span><br><span class="line">		stack.test();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法结束...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test()....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;add()....&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.increment();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;increment()....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序正在执行的方法，一定在栈的顶部，方法执行完毕之后，就会弹出栈。</li>
<li>栈满了就会有<code>StackOverflowError</code>。</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p>
<p><code>OutOfMemoryError</code>：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</p>
<p><strong>JVM中的堆一般分为三大部分：新生代、老年代、元空间（逻辑存在），其大致的占比如下：</strong></p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200722184148151.png" alt="Heap"></p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>​        新生代主要用来存放新生的对象。一般占据堆空间的<code>1/3</code>。在新生代中，保存着大量的刚刚创建的对象，但是大部分的对象都是朝生夕死，所以在新生代中会频繁的进行<code>MinorGC</code>，进行垃圾回收。新生代又细分为三个区：<code>Eden</code>区、<code>SurvivorFrom</code>、<code>ServivorTo</code>区，三个区的默认比例为：<code>8：1：1</code>。</p>
<ul>
<li><p><strong>Eden区：</strong>Java新创建的对象绝大部分会分配在<code>Eden</code>区（如果对象太大，则直接分配到老年代）。当Eden区内存不够的时候，就会触发<code>MinorGC</code>（新生代采用的是==<strong>复制算法</strong>==），对新生代进行一次垃圾回收。</p>
</li>
<li><p><strong>SurvivorFrom区和To区：</strong>在<code>GC</code>开始的时候，对象只会存在于<code>Eden</code>区和名为<code>From</code>的<code>Survivor</code>区，<code>To</code>区是空的，一次<code>MinorGC</code>过后，<code>Eden</code>区和<code>From</code>区存活的对象会移动到<code>SurvivorTo</code>区中，然后会清空<code>Eden</code>区和<code>From</code>区，并对存活的对象的年龄+1，如果对象的年龄达到15，则直接分配到老年代。<code>MinorGC</code>完成后，<code>From</code>区和<code>To</code>区的功能进行互换**==(谁空是是To区)==**。下一次<code>MinorGC</code>时，会把<code>To</code>区和<code>Eden</code>区存活的对象放入<code>From</code>区中，并计算对象存活的年龄。</p>
</li>
</ul>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>　　老年代主要存放应用中生命周期长的内存对象。老年代比较稳定，不会频繁的进行<code>MajorGC</code>。而在<code>MaiorGC</code>之前才会先进行一次<code>MinorGC</code>，使得新生的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次<code>MajorGC</code>进行垃圾回收腾出空间。</p>
<p>　　在老年代中，<code>MajorGC</code>采用了==<strong>标记—清除算法</strong>==：首先扫描一次所有老年代里的对象，标记出存活的对象，然后回收没有标记的对象。<code>MajorGC</code>的耗时比较长。因为要扫描再回收。<code>MajorGC</code>会产生内存碎片，当老年代也没有内存分配给新来的对象的时候，就会抛出OOM（Out of Memory）异常。</p>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p>　　永久代指的是永久保存区域。主要存放Class和Meta（元数据）的信息。Class在被加载的时候被放入永久区域，它和存放的实例的区域不同，在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（元空间）的区域。元空间和永久代类似，都是对JVM中规范中方法的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。类的元数据放入<code>native memory</code>，字符串池和类的静态变量放入java堆中。这样可以加载多少类的元数据就不再由<code>MaxPermSize</code>控制，而由系统的实际可用空间来控制。</p>
<p>采用元空间而不用永久代的原因：</p>
<ul>
<li>为了解决永久代的OOM问题，元数据和<code>Class</code>对象存放在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代大小指定比较困难，大小容易出现永久代溢出，太大容易导致老年代溢出（堆内存不变，此消彼长）。</li>
<li>永久代会为GC带来不必要的复杂度，并且回收效率偏低。</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731150301315.png" alt="image-20210731150301315" style="zoom:80%;" />

<h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。<br><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/16561e59a4135869" alt="Java 对象的创建过程 "></p>
<h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/16561e59a40a2c3d"></p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>
<ol>
<li><p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；<br><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/16306b9573968946" alt="使用句柄 "></p>
</li>
<li><p><strong>直接指针：</strong>  如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p>
</li>
</ol>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/16306ba3a41b6b65" alt="使用直接指针 "></p>
<p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
<h1 id="分析OOM原因"><a href="#分析OOM原因" class="headerlink" title="分析OOM原因"></a>分析OOM原因</h1><p>在一个项目中，突然出现了OOM故障，那么该如何排除错呢？？</p>
<ul>
<li>能够看到第几行代码出错：内存快照分析工具，MAT，JProfiler。</li>
<li>Debug，一行行分析代码。</li>
</ul>
<p><strong>MAT，JProfiler的作用：</strong></p>
<ul>
<li>分析Dump内存文件，快速定位内存定位问题。</li>
<li>获得堆中的数据。</li>
<li>获得大的对象。</li>
</ul>
<blockquote>
<p>使用JProfiler</p>
</blockquote>
<p>1、<code>Idea</code>安装<code>JProfiler</code>插件</p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200722215849316.png" alt="JProfiler插件"></p>
<p>2、下载**<code>JProfiler</code>** 软件</p>
<p><strong>官网网址：<a target="_blank" rel="noopener" href="https://www.ej-technologies.com/download/jprofiler/version_92">https://www.ej-technologies.com/download/jprofiler/version_92</a></strong></p>
<p>3、<code>Idea</code>安装<code>JProfiler</code>软件位置</p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200723095956836.png" alt="位置"></p>
<p>4、加入虚拟机参数并测试代码</p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200723101436565.png" alt="虚拟机参数"></p>
<p>5、在项目路径下会生成<code>java_pid15264.hprof</code>文件，使用<code>JProfilter</code>工具打开即可分析了。</p>
<ul>
<li><code>-Xms</code>：设置初始化内存分配大小。</li>
<li><code>-Xmx</code>：设置最大分配内存，默认 1/64。</li>
<li><code>-XX:+PrintGC</code>：打印GC信息。</li>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：OOM DUMP。</li>
</ul>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><ul>
<li><p>JVM在进行GC时，并不是対这三个区域统一回收。大部分时候，回收都是在新生代。</p>
</li>
<li><p>GC分为两种类型：<code>MinorGC</code>和<code>MajorGC/FullGC</code>。</p>
</li>
<li><p>GC的算法：标记清除法、标记压缩算法、复制算法、引用计数法（用的少）。</p>
</li>
<li><p><code>MinorGC</code>和<code>FullGC</code>分别在什么时候发生？</p>
</li>
</ul>
<h2 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200723103554674.png" alt="引用计数法"></p>
<p>每个对象在创建的时候，就给这个对象绑定一个计数器。每当有一个引用指向该对象时，计数器加一；每当有一个指向它的引用被删除时，计数器减一。这样，当没有引用指向该对象时，该对象死亡，计数器为0，这时就应该对这个对象进行垃圾回收操作。</p>
<ul>
<li>优点：<ul>
<li>实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。</li>
<li> 在垃圾回收过程中，应用无需挂起。</li>
<li>如果申请内存时，内存不足，则立刻报outofmember 错误。</li>
<li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。</li>
</ul>
</li>
<li> 缺点： </li>
<li>每次对象被引用时，都需要去更新计数器，有一点时间开销。</li>
<li>浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。 </li>
<li>无法解决循环引用问题。（最大的缺点）。</li>
</ul>
<h3 id="根可达算法"><a href="#根可达算法" class="headerlink" title="根可达算法"></a>根可达算法</h3><p>​        相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效的解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p>
<blockquote>
<p><strong>基本思路：</strong></p>
</blockquote>
<p>所谓”GC Roots “根集合就是一组必须活跃的引用。</p>
<p>基本思路:</p>
<p>➢可达性分析算法是以根对象集合(GC Roots) 为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</p>
<p>➢使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)</p>
<p>➢如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</p>
<p>➢在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
<blockquote>
<p><strong>GC Roots包括以下元素</strong></p>
</blockquote>
<ol>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区常量引用的对象 </li>
<li>JVM内部引用</li>
<li>JVM内部情况</li>
<li>同步锁的持有者</li>
<li>分代收集和局部回收</li>
</ol>
<p>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下:</p>
<p>**➢可触及的:**从根节点开始，可以到达这个对象。</p>
<p>**➢可复活的:**对象的所有引用都被释放，但是对象有可能在finalize()中复活。.</p>
<p>**➢不可触及的:**对象的finalize()被调用，并且没有复活，那么就会进入不可触 及状态。不可 触及的对象不可能被复活，因为finalize()只会被调用一次。</p>
<p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h3><p>　　HotSpot 把新生代分为三个部分：Eden区和两个Survivor区（From区和To区），默认比例8:1:1。对象创建时会被放在Eden区，当Eden区触发GC（Minor GC），GC会对Eden和Survivor区进行垃圾回收，幸存下来的独享会被 “复制” 到Survivor1区（To区），然后清空Eden和From区，最后将To和From交换，让刚才被清空的From作新的To区，让刚才保存对象的To区作新的From区，以保证下一次GC可以扫描到这些对象。这个过程中涉及到了一个 “复制” 的操作，就是 “复制算法” 的实现。顺带一提：当一个对象在多次GC后依然无法被回收，在From区和To区来回复制，每复制一次“年龄”加1，==<strong>一旦“年龄”达到MaxTenuringThreshold的值（默认为15）就会被移动到老年代</strong>==。</p>
<p>　　将活着的内存空间分为两块，每次只使用其中的一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731153227564.png" alt="image-20210731153227564" style="zoom:80%;" />

<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731153243884.png" alt="image-20210731153243884"></p>
<ul>
<li><p>优点：由于“复制算法”采用了==<strong>复制—清空</strong>==的方法，所以不会导致内存空间的碎片化。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>由于复制算法需要另外的空间来 “周转” 这些幸存的对象，所以内存消耗比较大。</li>
<li>如果存在“极端情况”，比如大量的对象循环引用而导致无法回收的幸存对象占比很大，假设为80%，那么就需要将这些数量庞大的对象都复制一遍，并将所有的引用地址重置一遍，这回耗费比较多的时间。**==所以复制算法的最佳工作环境就是这一块的对象存活率比较低，所以在新生代中采用了这一算法。==**</li>
</ul>
</li>
</ul>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p><strong>标记-清除</strong>的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为<strong>stop the world</strong>），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<p><strong>标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</strong></p>
<p><strong>清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</strong></p>
<p><strong>一句话：就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</strong></p>
<blockquote>
<p>标记-清除算法图示</p>
</blockquote>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200723121048827.png" alt="未标记" style="zoom: 80%;" />

<p>这张图代表的是程序运行期间所有对象的状态，<strong>它们的标志位全部是0</strong>（也就是未标记，以下默认0就是未标记，1为已标记），假设这会儿<strong>有效内存空间耗尽</strong>了，JVM将会停止应用程序的运行并开启GC线程，然后开始进行标记工作，按照根搜索算法，标记完以后，对象的状态如下图。</p>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200723121550578.png" alt="标记" style="zoom: 80%;" />

<p>可以看到，按照根搜索算法，所有从root对象可达的对象就被标记为了存活的对象，此时已经完成了第一阶段标记。接下来，就要执行第二阶段清除了，那么清除完以后，剩下的对象以及对象的状态如下图所示。</p>
<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200723122359462.png" alt="清除" style="zoom: 80%;" />

<p>优点：不需要额外的空间。</p>
<p>标记—清除算法缺点：</p>
<ul>
<li>效率不算高。</li>
<li>在进行GC的时候,需要停止整个应用程序,导致用户体验差。</li>
<li>这种方式清理出来的空闲内存是不连续的,产生内存碎片。需要维护一个空闲列表。</li>
</ul>
<p><strong>注意:何为清除?</strong></p>
<p>这里所谓的清除并不是真的置空,而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时,判断垃圾的位置空间是否够,如果够,就存放。</p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用的对象，第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/20200723123710525.png" alt="标记—清除—压缩"></p>
<p>标记压缩其实就是在标记清除后加了一个 “压缩” 操作，将分散的数据压缩到一块连续的内存空间。就是慢，但慢工出细活。</p>
<p><strong>优点:</strong> </p>
<ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配. 内存时，JVM只 需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。移动过程中，需要全程暂停用户应用程序。即:STW</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　针对老年的GC，标记清除和标记压缩都不完美，最好的方式是组合使用，在多次使用标记清除后进行一次压缩。**==总的来说四种方式没有孰优孰劣，只有谁更合适==**。总结一下就是：</p>
<p>执行效率（算法的时间复杂度）：复制算法&gt;标记清除&gt;标记压缩</p>
<p>内存整齐度：复制算法=标记压缩&gt;标记清除</p>
<p>内存利用率：标记清除=标记压缩&gt;复制算法</p>
<p>在Java9默认采用了G1垃圾回收器，采用了时间复杂度和空间利用率都非常出色的算法。</p>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731153617482.png" alt="image-20210731153617482"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p>
<h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h4 id="system-gc"><a href="#system-gc" class="headerlink" title="system. gc()"></a>system. gc()</h4><p>在默认情况下，通过system. gc()或者Runtime . getRuntime() .gc() 的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而System.gc()调用附带一一个免责声明，无法保证对垃圾收集器的调用。</p>
<p>JVM实现者可以通过System. gc ()调用来决定JVM的GC行为。而- -般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写-一个性能基准，我们可以在运行之间调用System.gc()。</p>
<h4 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h4><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731165501029.png" alt="image-20210731165501029" style="zoom:80%;" />

<img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731165513641.png" alt="image-20210731165513641" style="zoom:80%;" />

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>
<p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<p><strong>1．强引用</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空 间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p><strong>2．软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>3．弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>4．虚引用（PhantomReference）</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731170129825.png" alt="image-20210731170129825" style="zoom:80%;" />

<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为知道现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/46873026.jpg" alt=" Serial 收集器 "></p>
<p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong>并行回收，STW。</p>
<p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/22018368.jpg" alt="ParNew 收集器 "></p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<p><strong>并行和并发概念补充：</strong></p>
<ul>
<li><p><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>
</li>
<li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p>
</li>
</ul>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器类似于 ParNew 收集器。 <strong>那么它有什么特别之处呢？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC </span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731223550624.png" alt="image-20210731223550624"></p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p> <strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。</li>
</ul>
<p><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/82825079.jpg" alt="CMS 垃圾收集器 "></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
</ul>
<p>​     仅仅是标记一下GC Roots能直接关联到的对象，并修改TIMES指针的值，让下一阶段用户线程并发运行，能正确的在可用的Region中分配新的对象，借用Minor GC停顿线程，但是时间很短。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p>
<ul>
<li><p><strong>并发标记</strong></p>
<p>​    从GC Roots开始对堆中的对象进行可达性分析，扫描堆里的对象图，找出要回收的对象，可与用户线程并发执行，对象图扫描完成后，还要重新处理STAB记录下的在并发时有引用变动的对象。</p>
</li>
<li><p><strong>最终标记</strong></p>
<p>​    对用户线程STW，用于处理并发阶段结束后仍遗留下来的最后少量的SATB记录。</p>
</li>
<li><p><strong>筛选回收</strong></p>
<p>​    负责更新Region的统计数据，根据用户所期望的停顿时间来制定回收计划，把决定回收的那一部分Region的存活对象复制到空的Region中，清理旧的Region的全部空间。</p>
</li>
</ul>
<p>**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731170953604.png" alt="image-20210731170953604" style="zoom:80%;" />

<h1 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h1><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731174325771.png" alt="image-20210731174325771" style="zoom:80%;" />

<h2 id="内存溢出错误"><a href="#内存溢出错误" class="headerlink" title="内存溢出错误"></a>内存溢出错误</h2><p><strong>学习目的:</strong></p>
<ul>
<li>通过异常信息及时定位到发生内存溢出的运行时数据区域</li>
<li>了解什么样的代码会导致内存溢出，防止写出这样的代码</li>
<li>出现异常后该如何处理，也就是学习事中的处理手段</li>
</ul>
<p><strong>内存溢出和内存泄露的区别</strong></p>
<ul>
<li>内存泄露：不该留存在进程中的内存数据，虽然很小，但是在经过多次长期的积累后，会导致内存溢出</li>
<li>内存溢出：程序申请内存时，内存不足的现象</li>
</ul>
<h3 id="堆溢出错误和预判堆溢出的错误"><a href="#堆溢出错误和预判堆溢出的错误" class="headerlink" title="堆溢出错误和预判堆溢出的错误"></a>堆溢出错误和预判堆溢出的错误</h3><p>如何复现出堆溢出错误？</p>
<ul>
<li>JVM参数部分：最大堆和最小堆设置相同并且设置的比较小，比如只有10M，这样就不会自动扩展堆</li>
<li>代码部分：在一个方法中不断地往集合中加入元素</li>
</ul>
<p>代码实践</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xmx10M -Xms10M -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">float</span> c = <span class="number">2.1f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的出现了我们想要的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid24476.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">13268403</span> bytes in <span class="number">0.077</span> secs]</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:<span class="number">265</span>)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:<span class="number">239</span>)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:<span class="number">231</span>)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:<span class="number">462</span>)</span><br><span class="line">	at org.example.App.main(App.java:<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果把参数调大，调整20M，那么会报另外的error</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">Dumping heap to java_pid8796.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">27391983</span> bytes in <span class="number">0.141</span> secs]</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">	at org.example.App.main(App.java:<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个错误的原因是，JVMGC时间占据了整个运行时间的98%，但是回收只得到了2%可用的内存，至少出现5次，就会报这个异常。</p>
<p>这个异常是Jdk1.6定义的策略， 通过统计GC时间来<strong>预测是否要OOM了，提前抛出异常</strong>，防止OOM发生。</p>
<p><strong>案例心得：</strong></p>
<ul>
<li>堆内存溢出的识别：java.lang.OutOfMemoryError: Java heap space 或者 java.lang.OutOfMemoryError: GC overhead limit exceeded</li>
<li>死循环中不断创建对象这种代码应该规避</li>
<li>提前设置好自动转储的参数，出现异常能够恢复现场查看问题</li>
<li>事后排查思路：先用JvisualVM这样的软件查看具体对象，核查是内存溢出还是内存泄漏，如果确定没有泄露，需要排查堆的参数设置是否合理，从代码上分析对象存活时长比较长是否必要，是否可以优化等等。</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出错误"><a href="#虚拟机栈和本地方法栈溢出错误" class="headerlink" title="虚拟机栈和本地方法栈溢出错误"></a>虚拟机栈和本地方法栈溢出错误</h3><p>一般我们会遇到两种栈相关的错误：</p>
<ul>
<li>单个线程中，不断的调用方法入栈，当栈深度超过虚拟机所允许的最大深度时，抛出StackOverflowError</li>
<li>不断地创建线程，创建线程就需要创建栈，当无法申请到足够的内存，就会报 unable to create new native thread错误</li>
</ul>
<p>如何复现？</p>
<ul>
<li>JVM参数：-Xss128k，每个线程的栈内存大小</li>
<li>代码部分：没有出口的递归调用</li>
</ul>
<p>代码实践</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xss128k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        length++;</span><br><span class="line">        reverse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reverse();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;length:&quot;</span> + length);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">length:<span class="number">1096</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at org.example.App.reverse(App.java:<span class="number">10</span>)</span><br><span class="line">	at org.example.App.reverse(App.java:<span class="number">11</span>)</span><br><span class="line">	at org.example.App.reverse(App.java:<span class="number">11</span>)</span><br><span class="line">	at org.example.App.reverse(App.java:<span class="number">11</span>)</span><br><span class="line">    太多了，这里只截取部分</span><br></pre></td></tr></table></figure>

<p>关于unable to create new native thread这个异常，这里就不尝试了，因为可能会导致操作系统假死等问题。</p>
<p><strong>案例心得：</strong></p>
<ul>
<li>栈错误的识别：StackOverflowError 或者 java.lang.OutOfMemoryError: unable to create new native thread</li>
<li>没有出口的递归调用要避免；默认的JVM栈大小的参数针对一般的方法调用深度是足够的</li>
<li>如果必须要创建大量的常驻线程，并且是32位的虚拟机，要测试协调好 <strong>栈内存和其他内存的大小</strong>，防止出现溢出错误</li>
<li>事后排查思路：先确定是哪种错误，然后检查递归调用或者检查线程数</li>
</ul>
<h3 id="方法区（元数据区）和运行时常量池溢出"><a href="#方法区（元数据区）和运行时常量池溢出" class="headerlink" title="方法区（元数据区）和运行时常量池溢出"></a>方法区（元数据区）和运行时常量池溢出</h3><h4 id="方法区和运行时常量池异常"><a href="#方法区和运行时常量池异常" class="headerlink" title="方法区和运行时常量池异常"></a>方法区和运行时常量池异常</h4><p>在JDK1.6以及以前的版本中，运行时常量池是放在方法区中的，我们可以通过限制方法区的大小然后增大常量池来模拟溢出。</p>
<p>如何模拟：</p>
<ul>
<li>JDK使用1.6版本，这里注意，要统一idea所有的版本，否则出错</li>
<li>JVM参数：–XX:PermSize=10M -XX:MaxPermSize=10M</li>
<li>应用代码：使用String.intern方法不断创建新的常量对象到常量池中，并一直用集合保持强引用</li>
</ul>
<p>代码实践：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">	at java.lang.String.intern(Native Method)</span><br><span class="line">	at org.example.App.main(App.java from InputFileObject:<span class="number">15</span>)</span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在JDK1.7以后，常量池就被移动到了堆中，所以如果限制了堆的大小，那么最终会报堆溢出异常或者预判堆异常的错误的。</p>
<p>同样的代码使用JDK1.8版本测试，并指定了堆的最大和初始大小后，果然出现了我预计的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数：-XX:PermSize=10M -XX:MaxPermSize=10M -Xmx10M -Xms10M</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">	at java.lang.Integer.toString(Integer.java:<span class="number">403</span>)</span><br><span class="line">	at java.lang.String.valueOf(String.java:<span class="number">3099</span>)</span><br><span class="line">	at org.example.App.main(App.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<p>如果加上不使用 预判断限制参数 -XX:-UseGCOverheadLimit，就会直接报堆溢出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=10M -XX:MaxPermSize=10M -Xmx10M -Xms10M -XX:-UseGCOverheadLimit</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.lang.Integer.toString(Integer.java:<span class="number">401</span>)</span><br><span class="line">	at java.lang.String.valueOf(String.java:<span class="number">3099</span>)</span><br><span class="line">	at org.example.App.main(App.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<p>说明，常量池分配在堆中。</p>
<h4 id="元数据区异常"><a href="#元数据区异常" class="headerlink" title="元数据区异常"></a>元数据区异常</h4><p>JDK1.8之后，元数据区被放在了直接内存中，可以指定下面的参数来模拟溢出情况</p>
<ul>
<li>JVM参数：<ul>
<li>-XX:MetaspaceSize=10M</li>
<li>-XX:MaxMetaspaceSize=10M</li>
<li>-XX:+HeapDumpOnOutOfMemoryError</li>
</ul>
</li>
<li>代码：通过使用cglib生成大量的动态类</li>
</ul>
<p>代码实战：</p>
<p>pom文件中添加cglib的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">Dumping heap to java_pid26272.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">3395669</span> bytes in <span class="number">0.015</span> secs]</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&gt;<span class="keyword">null</span></span><br><span class="line">	at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:<span class="number">345</span>)</span><br><span class="line">	at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:<span class="number">492</span>)</span><br><span class="line">	at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:<span class="number">114</span>)</span><br><span class="line">	at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:<span class="number">291</span>)</span><br><span class="line">	at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:<span class="number">480</span>)</span><br><span class="line">	at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:<span class="number">305</span>)</span><br><span class="line">	at org.example.App.main(App.java:<span class="number">23</span>)</span><br><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:<span class="number">413</span>)</span><br><span class="line">	at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:<span class="number">336</span>)</span><br><span class="line">	... <span class="number">6</span> more</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">756</span>)</span><br><span class="line">	... <span class="number">11</span> more</span><br></pre></td></tr></table></figure>

<h4 id="案例心得"><a href="#案例心得" class="headerlink" title="案例心得"></a>案例心得</h4><ul>
<li>元数据区和方法区错误的识别：java.lang.OutOfMemoryError: Metaspace；java.lang.OutOfMemoryError: PermGen space</li>
<li>元数据区的溢出一般和框架代码或者本地代码中大量创建动态类有关</li>
<li>核查问题时，也是根据具体的问题分析是哪个动态类被大量创建，是否有必要，是否需要调整方法区的大小。</li>
</ul>
<h3 id="直接内存区域的溢出"><a href="#直接内存区域的溢出" class="headerlink" title="直接内存区域的溢出"></a>直接内存区域的溢出</h3><p>直接内存区域，如果内存达到设置的MaxDirectMemorySize后，就会触发垃圾回收，如果垃圾回收不能有效回收内存，也会引起OOM溢出。</p>
<p>如何复现？</p>
<ul>
<li>JVM参数：-XX:MaxDirectMemorySize，如果不指定，和-Xmx指定的最大堆一样</li>
<li>代码部分：使用unsafe不断的分配直接内存</li>
</ul>
<p>代码实战</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        Field unsafeFiled = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeFiled.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeFiled.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError</span><br><span class="line">	at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">	at org.example.App.main(App.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p><strong>案例心得：</strong></p>
<ul>
<li>直接内存溢出的识别：Exception in thread “main” java.lang.OutOfMemoryError，并且dump出的堆栈文件不大</li>
<li>核查问题时，根据异常堆栈检查引发error的代码，一般都是NIO代码引起的。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">刘恒运</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/05/06/JVM%20-%20%E7%BD%91%E7%BB%9C/">http://example.com/2021/05/06/JVM%20-%20%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">luckforever</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">-类的加载过程 -运行时数据区 -GC垃圾回收</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731191949036.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/30/java%E5%90%84%E7%A7%8D%E9%94%81%20-%20%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="https://gitee.com/liu-hengyun/lhy/raw/master/images/java%E5%90%84%E7%A7%8D%E9%94%81/image-20210727084424434.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JAVA锁</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/04/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BD%91%E7%BB%9C/"><img class="next-cover" src="https://gitee.com/liu-hengyun/lhy/raw/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210722111819594.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC并发编程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">刘恒运</div><div class="author-info__description">学习录</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">JVM的体系结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="toc-number">2.</span> <span class="toc-text">类加载器和双亲委派</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.2.0.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.1.2.0.2.</span> <span class="toc-text">连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">2.1.2.0.3.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">2.1.2.0.4.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.2.0.5.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.2.0.6.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">2.1.2.0.7.</span> <span class="toc-text">卸载</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">对象实例化过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">类加载器类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">双亲委派模型的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E4%B8%8D%E6%83%B3%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">如果我们不想用双亲委派模型怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">沙箱安全机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">3.</span> <span class="toc-text">运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">方法区和永久代的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">常用参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3-PermGen-%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%85%83%E7%A9%BA%E9%97%B4-MetaSpace-%E5%91%A2"><span class="toc-number">3.3.0.3.</span> <span class="toc-text">为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.3.1.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">3.3.2.</span> <span class="toc-text">方法区的演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">3.3.3.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E6%A0%88"><span class="toc-number">3.4.</span> <span class="toc-text">JVM栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">3.4.2.</span> <span class="toc-text">操作数栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.4.3.</span> <span class="toc-text">动态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.4.4.</span> <span class="toc-text">方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-number">3.4.5.</span> <span class="toc-text">附加信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.5.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="toc-number">3.5.1.</span> <span class="toc-text">新生代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">3.5.2.</span> <span class="toc-text">老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-number">3.5.3.</span> <span class="toc-text">元空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String"><span class="toc-number">4.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSpot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98"><span class="toc-number">4.1.</span> <span class="toc-text">HotSpot 虚拟机对象探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.1.1.</span> <span class="toc-text">对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">Step1:类加载检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">Step2:分配内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">Step3:初始化零值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step4-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">Step4:设置对象头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step5-%E6%89%A7%E8%A1%8C-init-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">Step5:执行 init 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">4.1.2.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.1.3.</span> <span class="toc-text">对象的访问定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%9E%90OOM%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.</span> <span class="toc-text">分析OOM原因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GC"><span class="toc-number">6.</span> <span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">垃圾判断算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E5%8F%AF%E8%BE%BE%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">根可达算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">标记复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.2.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.5.</span> <span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">6.3.</span> <span class="toc-text">垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#system-gc"><span class="toc-number">6.3.0.1.</span> <span class="toc-text">system. gc()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">6.3.0.2.</span> <span class="toc-text">内存溢出与内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">6.3.0.3.</span> <span class="toc-text">引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.4.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.4.1.</span> <span class="toc-text">Serial 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.4.2.</span> <span class="toc-text">ParNew 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.4.3.</span> <span class="toc-text">Parallel Scavenge 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.4.4.</span> <span class="toc-text">Serial Old 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.4.5.</span> <span class="toc-text">Parallel Old 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.4.6.</span> <span class="toc-text">CMS 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.4.7.</span> <span class="toc-text">G1 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">6.4.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">7.</span> <span class="toc-text">JVM性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-number">7.1.</span> <span class="toc-text">内存溢出错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF%E5%92%8C%E9%A2%84%E5%88%A4%E5%A0%86%E6%BA%A2%E5%87%BA%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">7.1.1.</span> <span class="toc-text">堆溢出错误和预判堆溢出的错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-number">7.1.2.</span> <span class="toc-text">虚拟机栈和本地方法栈溢出错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%89%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%BA%A2%E5%87%BA"><span class="toc-number">7.1.3.</span> <span class="toc-text">方法区（元数据区）和运行时常量池溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%BC%82%E5%B8%B8"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">方法区和运行时常量池异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">元数据区异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%BF%83%E5%BE%97"><span class="toc-number">7.1.3.3.</span> <span class="toc-text">案例心得</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E6%BA%A2%E5%87%BA"><span class="toc-number">7.1.4.</span> <span class="toc-text">直接内存区域的溢出</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/02/MySQL%20-%20%E7%BD%91%E7%BB%9C/" title="MySQL"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/mysql/20180831173911997" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL"/></a><div class="content"><a class="title" href="/2021/08/02/MySQL%20-%20%E7%BD%91%E7%BB%9C/" title="MySQL">MySQL</a><time datetime="2021-08-02T07:45:59.648Z" title="发表于 2021-08-02 15:45:59">2021-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/30/java%E5%90%84%E7%A7%8D%E9%94%81%20-%20%E7%BD%91%E7%BB%9C/" title="JAVA锁"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/java%E5%90%84%E7%A7%8D%E9%94%81/image-20210727084424434.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAVA锁"/></a><div class="content"><a class="title" href="/2021/07/30/java%E5%90%84%E7%A7%8D%E9%94%81%20-%20%E7%BD%91%E7%BB%9C/" title="JAVA锁">JAVA锁</a><time datetime="2021-07-30T14:49:59.405Z" title="发表于 2021-07-30 22:49:59">2021-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/06/JVM%20-%20%E7%BD%91%E7%BB%9C/" title="JVM"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/JVM/image-20210731191949036.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/2021/05/06/JVM%20-%20%E7%BD%91%E7%BB%9C/" title="JVM">JVM</a><time datetime="2021-05-06T00:00:00.000Z" title="发表于 2021-05-06 08:00:00">2021-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/04/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BD%91%E7%BB%9C/" title="JUC并发编程"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210722111819594.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC并发编程"/></a><div class="content"><a class="title" href="/2021/05/04/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BD%91%E7%BB%9C/" title="JUC并发编程">JUC并发编程</a><time datetime="2021-05-04T02:00:00.000Z" title="发表于 2021-05-04 10:00:00">2021-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/22/java%E9%9B%86%E5%90%88%20-%20%E7%BD%91%E7%BB%9C/" title="JAVA集合"><img src="https://gitee.com/liu-hengyun/lhy/raw/master/images/Java%E9%9B%86%E5%90%88/image-20210630191902744.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAVA集合"/></a><div class="content"><a class="title" href="/2021/04/22/java%E9%9B%86%E5%90%88%20-%20%E7%BD%91%E7%BB%9C/" title="JAVA集合">JAVA集合</a><time datetime="2021-04-22T00:00:00.000Z" title="发表于 2021-04-22 08:00:00">2021-04-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 刘恒运</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>